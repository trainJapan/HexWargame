<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Scenario Editor v0.9.5 - Dynamic Units</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        :root {
            --bg-dark: #1e1e1e;
            --bg-panel: #2d2d2d;
            --accent: #d4a017; /* Gold */
            --text-main: #e0e0e0;
            --border: #444;
        }

        body { 
            margin: 0; padding: 0; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-dark);
            color: var(--text-main);
            height: 100vh;
            display: grid;
            grid-template-columns: 300px 1fr 300px; /* Wider panels for unit lists */
            overflow: hidden;
        }

        /* PANELS */
        #left-panel, #right-panel {
            background: var(--bg-panel);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            border-right: 1px solid var(--border);
        }
        #right-panel { border-left: 1px solid var(--border); border-right: none; }

        .panel-header {
            color: var(--accent);
            font-size: 16px;
            font-weight: bold;
            border-bottom: 2px solid var(--accent);
            padding-bottom: 5px;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        /* FORMS & INPUTS */
        .form-group { margin-bottom: 10px; }
        label { display: block; font-size: 11px; color: #aaa; margin-bottom: 3px; }
        input, textarea, select {
            width: 100%;
            background: #222; border: 1px solid #444;
            color: #fff; padding: 6px;
            border-radius: 4px; font-size: 12px;
            box-sizing: border-box;
        }
        textarea { resize: vertical; }

        /* BUTTONS */
        .btn {
            background: #444; color: #fff;
            border: 1px solid #555;
            padding: 8px; cursor: pointer;
            border-radius: 4px; font-weight: bold;
            text-align: center; font-size: 12px;
            transition: all 0.2s;
        }
        .btn:hover { background: #555; border-color: #777; }
        .btn.active { background: var(--accent); color: #000; border-color: var(--accent); }
        .btn-danger { background: #800; border-color: #a00; }
        .btn-danger:hover { background: #a00; }

        /* UNIT PALETTE */
        .unit-list { display: flex; flex-direction: column; gap: 4px; }
        .unit-btn {
            display: flex; align-items: center; gap: 10px;
            background: #222; border: 1px solid #444;
            padding: 5px; cursor: pointer; text-align: left;
        }
        .unit-btn:hover { background: #333; border-color: #666; }
        .unit-btn.selected { border-color: var(--accent); background: #3a3a20; }
        .unit-icon { width: 32px; height: 32px; object-fit: contain; }
        .unit-name { font-size: 12px; font-weight: bold; }
        .unit-type { font-size: 10px; color: #888; }

        /* CENTER MAP */
        #editor-container { position: relative; overflow: hidden; background: #111; }
    </style>
</head>
<body>

<div id="left-panel">
    <div class="panel-header">Metadata</div>
    <div class="form-group">
        <label>Scenario Title</label>
        <input type="text" id="meta-title" value="New Scenario">
    </div>
    <div class="form-group">
        <label>Author</label>
        <input type="text" id="meta-author" value="Designer">
    </div>
    <div class="form-group">
        <label>Description</label>
        <textarea id="meta-desc" rows="3">A short description...</textarea>
    </div>
    <div class="form-group">
        <label>Max Turns</label>
        <input type="number" id="meta-turns" value="10">
    </div>

    <div class="panel-header">Map Tools</div>
    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px;">
        <button class="btn" onclick="resizeMap(15, 10)">Small (15x10)</button>
        <button class="btn" onclick="resizeMap(20, 15)">Medium (20x15)</button>
        <button class="btn" onclick="resizeMap(30, 20)">Large (30x20)</button>
    </div>
    
    <div class="panel-header" style="margin-top:10px;">Terrain</div>
    <div id="terrain-palette" style="display:grid; grid-template-columns: 1fr 1fr; gap:5px;">
        </div>
    
    <button class="btn" style="margin-top:10px;" onclick="setTool('road')">Road Tool (Toggle)</button>
    <div style="font-size:10px; color:#aaa; margin-top:2px;">Click sequential hexes to draw roads.</div>
</div>

<div id="editor-container"></div>

<div id="right-panel">
    <div class="panel-header">Unit Placement</div>
    <div id="unit-palette-container">
        </div>

    <div class="panel-header" style="margin-top:20px;">Objectives</div>
    <button class="btn" id="btn-obj" onclick="setTool('objective')">Place Objective (VP)</button>

    <div class="panel-header" style="margin-top:20px;">Zones</div>
    <button class="btn" id="btn-zone-blue" onclick="setTool('zone_blue')" style="border-color:#4488ff; color:#4488ff;">Blue Setup Zone</button>
    <button class="btn" id="btn-zone-red" onclick="setTool('zone_red')" style="border-color:#ff4444; color:#ff4444; margin-top:5px;">Red Setup Zone</button>

    <div style="flex-grow:1;"></div>
    <button class="btn btn-danger" onclick="clearMap()">Clear Map</button>
    <button class="btn active" onclick="exportJSON()">Export JSON</button>
</div>

<script>
// --- Configuration ---
const ASSETS_URL = 'https://raw.githubusercontent.com/trainJapan/HexWargame/main/artwork/';

// --- DYNAMIC FILE LIST (Synced with Engine) ---
const UNIT_FILES = [
    "UK_S_Rifle_Squad.png",
    "GER_S_Rifle_Squad.png",
    "UK_V_M3_Stuart.png",
    "GER_V_Schwerer_Panzerspähwagen.png",
    "UK_WT_HMG_Team.png",
    "GER_WT_HMG_Team.png",
    "UK_WT_PIAT_Team.png",
    "GER_HWT_Leichtes_Infanteriegeschütz.png"
];

// Registry to store parsed info
const UNIT_DATA_REGISTRY = {};

const TERRAIN_TYPES = ['clear', 'fields', 'broken', 'orchard', 'rural', 'forest', 'urban', 'industrial', 'water', 'hill', 'beach'];
const TERRAIN_COLORS = {
    'clear': 0x98FB98, 'fields': 0xCCAA00, 'broken': 0x8B4513, 'orchard': 0x00FF00,
    'rural': 0xFF9999, 'forest': 0x228B22, 'urban': 0xCC0000, 'industrial': 0x808080,
    'water': 0x4169E1, 'hill': 0x8B7355, 'beach': 0xFFFF99
};

const HEX_RADIUS = 35;

// Editor State
let mapCols = 20;
let mapRows = 15;
let hexMap = {}; // { "q,r": { terrain, road, zone, obj... } }
let units = []; // Array of placed units
let currentTool = null; // 'terrain', 'unit', 'road', 'objective', 'zone_blue', 'zone_red'
let selectedTerrain = 'clear';
let selectedUnitInfo = null; // Stores info from UNIT_DATA_REGISTRY for the active brush
let roadPathStart = null;

// Phaser
let scene, hexGroup, unitGroup, overlayGraphics;

const config = {
    type: Phaser.AUTO,
    parent: 'editor-container',
    width: window.innerWidth - 600,
    height: window.innerHeight,
    backgroundColor: '#111',
    scene: { preload: preload, create: create, update: update }
};

const game = new Phaser.Game(config);

// --- PARSING HELPER (Identical to Engine) ---
function parseUnitFromFileName(filename) {
    const nameOnly = filename.replace(/\.[^/.]+$/, "");
    const parts = nameOnly.split('_');

    let side = 'neutral';
    let category = 'squad';
    let unitName = nameOnly;
    let type = 'infantry';

    if (parts.length >= 3) {
        const sideCode = parts[0].toUpperCase();
        const catCode = parts[1].toUpperCase();
        unitName = parts.slice(2).join(' '); // Replace _ with space

        if (sideCode === 'GER') side = 'red';
        if (sideCode === 'UK' || sideCode === 'US') side = 'blue';

        switch (catCode) {
            case 'S': category = 'squad'; break;
            case 'T': category = 'team'; break;
            case 'WT': category = 'team'; break;
            case 'HWT': category = 'hwt'; break;
            case 'V': category = 'vehicle'; break;
        }
    }
    return {
        key: nameOnly,
        side: side,
        category: category,
        name: unitName,
        filename: filename
    };
}

function preload() {
    // Load Terrain Variants
    TERRAIN_TYPES.forEach(t => {
        for(let i=1; i<=3; i++) this.load.image(`${t}${i}`, `${ASSETS_URL}map/${t}${i}.png`);
    });

    // Load Dynamic Units
    UNIT_FILES.forEach(filename => {
        const info = parseUnitFromFileName(filename);
        this.load.image(info.key, `${ASSETS_URL}counters/${filename}`);
        UNIT_DATA_REGISTRY[info.key] = info;
    });
}

function create() {
    scene = this;
    hexGroup = this.add.group();
    unitGroup = this.add.group();
    overlayGraphics = this.add.graphics().setDepth(1000);

    // Mouse Input
    this.input.on('pointerdown', handlePointer);
    this.input.on('pointermove', (pointer) => {
        if (pointer.isDown) handlePointer(pointer);
    });

    // Camera Controls
    this.input.on('wheel', (pointer, gameObjects, deltaX, deltaY) => {
        const zoom = scene.cameras.main.zoom - (deltaY * 0.001);
        scene.cameras.main.setZoom(Phaser.Math.Clamp(zoom, 0.3, 2));
    });
    
    // Right click pan
    this.input.mouse.disableContextMenu();

    initializeMap();
    buildTerrainPalette();
    buildUnitPalette();
}

function update() {
    if (this.input.activePointer.rightButtonDown()) {
        const pointer = this.input.activePointer;
        this.cameras.main.scrollX -= (pointer.x - pointer.prevPosition.x) / this.cameras.main.zoom;
        this.cameras.main.scrollY -= (pointer.y - pointer.prevPosition.y) / this.cameras.main.zoom;
    }
}

// --- Initialization & UI Builders ---

function buildTerrainPalette() {
    const container = document.getElementById('terrain-palette');
    container.innerHTML = '';
    TERRAIN_TYPES.forEach(t => {
        const btn = document.createElement('button');
        btn.className = 'btn';
        btn.innerText = t.charAt(0).toUpperCase() + t.slice(1);
        btn.style.borderColor = '#' + TERRAIN_COLORS[t].toString(16);
        btn.onclick = () => {
            currentTool = 'terrain';
            selectedTerrain = t;
            highlightBtn(btn);
        };
        container.appendChild(btn);
    });
}

function buildUnitPalette() {
    const container = document.getElementById('unit-palette-container');
    container.innerHTML = '';

    // Separate by Side
    const allies = [];
    const axis = [];
    
    Object.values(UNIT_DATA_REGISTRY).forEach(info => {
        if(info.side === 'blue') allies.push(info);
        else axis.push(info);
    });

    const createGroup = (title, list, color) => {
        const header = document.createElement('div');
        header.innerText = title;
        header.style.color = color;
        header.style.fontSize = '12px';
        header.style.fontWeight = 'bold';
        header.style.marginTop = '10px';
        container.appendChild(header);

        const listDiv = document.createElement('div');
        listDiv.className = 'unit-list';
        
        list.forEach(info => {
            const btn = document.createElement('div');
            btn.className = 'unit-btn';
            btn.innerHTML = `
                <img src="${ASSETS_URL}counters/${info.filename}" class="unit-icon">
                <div>
                    <div class="unit-name">${info.name}</div>
                    <div class="unit-type">${info.category.toUpperCase()}</div>
                </div>
            `;
            btn.onclick = () => {
                currentTool = 'unit';
                selectedUnitInfo = info;
                // clear other selected styles
                document.querySelectorAll('.unit-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
            };
            listDiv.appendChild(btn);
        });
        container.appendChild(listDiv);
    };

    if(allies.length > 0) createGroup("ALLIES (BLUE)", allies, "#4488ff");
    if(axis.length > 0) createGroup("AXIS (RED)", axis, "#ff4444");
}

function highlightBtn(activeBtn) {
    document.querySelectorAll('#left-panel .btn').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('#right-panel .btn').forEach(b => b.classList.remove('active'));
    if(activeBtn) activeBtn.classList.add('active');
}

function setTool(tool) {
    currentTool = tool;
    if (tool === 'road') roadPathStart = null;
    
    // Highlight logic for static buttons
    if(tool === 'road') highlightBtn(document.querySelector("button[onclick=\"setTool('road')\"]"));
    if(tool === 'objective') highlightBtn(document.getElementById('btn-obj'));
    if(tool === 'zone_blue') highlightBtn(document.getElementById('btn-zone-blue'));
    if(tool === 'zone_red') highlightBtn(document.getElementById('btn-zone-red'));
}

// --- Map Logic ---

function initializeMap() {
    hexGroup.clear(true, true);
    hexMap = {};
    for (let q = 0; q < mapCols; q++) {
        for (let r = 0; r < mapRows; r++) {
            const key = `${q},${r}`;
            hexMap[key] = { q, r, terrain: 'clear', variant: Phaser.Math.Between(1,3), road: false, zone: null, obj: 0 };
        }
    }
    redrawMap();
}

function resizeMap(c, r) {
    mapCols = c; mapRows = r;
    initializeMap();
}

function clearMap() {
    if(confirm("Clear everything?")) {
        initializeMap();
        units = [];
        redrawUnits();
    }
}

function handlePointer(pointer) {
    const hex = getHexAtPoint(pointer.worldX, pointer.worldY);
    if (!hex) return;
    const key = `${hex.q},${hex.r}`;
    const data = hexMap[key];
    if (!data) return;

    if (currentTool === 'terrain') {
        data.terrain = selectedTerrain;
        data.variant = Phaser.Math.Between(1,3);
        redrawHex(data);
    } 
    else if (currentTool === 'road') {
        if(!pointer.isDown) return; // Only clicks
        // Toggle road on single hex (simple implementation)
        // Ideally roads are edges, but for this simplified engine we mark hexes as containing roads
        // If clicking multiple, we could link them. For now, simple toggle.
        // Better: just mark hasRoad = true
        data.road = !data.road;
        redrawHex(data);
        drawOverlays();
    }
    else if (currentTool === 'zone_blue') {
        data.zone = (data.zone === 'blue') ? null : 'blue';
        drawOverlays();
    }
    else if (currentTool === 'zone_red') {
        data.zone = (data.zone === 'red') ? null : 'red';
        drawOverlays();
    }
    else if (currentTool === 'objective') {
        data.obj = (data.obj === 0) ? 50 : 0; // Toggle 50 VP
        drawOverlays();
    }
    else if (currentTool === 'unit' && selectedUnitInfo) {
        if(pointer.downX !== pointer.upX) return; // prevent drag-painting units
        
        // Check if unit exists there, remove it if so (toggle)
        const existingIdx = units.findIndex(u => u.q === hex.q && u.r === hex.r);
        if (existingIdx >= 0) {
            units.splice(existingIdx, 1);
        } else {
            // Place new unit
            units.push({
                type: selectedUnitInfo.key, // store texture key
                q: hex.q,
                r: hex.r,
                // Add default properties expected by engine
                side: selectedUnitInfo.side,
                category: selectedUnitInfo.category,
                name: selectedUnitInfo.name
            });
        }
        redrawUnits();
    }
}

// --- Drawing ---

function getHexPosition(q, r) {
    const x = q * HEX_RADIUS * 1.5 + HEX_RADIUS;
    const y = r * HEX_RADIUS * Math.sqrt(3) + (q % 2 === 1 ? HEX_RADIUS * Math.sqrt(3) / 2 : 0) + HEX_RADIUS;
    return { x, y };
}

function getHexAtPoint(worldX, worldY) {
    // Brute force is fine for editor size
    let closest = null; let minD = Infinity;
    for (const key in hexMap) {
        const h = hexMap[key];
        const pos = getHexPosition(h.q, h.r);
        const d = Phaser.Math.Distance.Between(worldX, worldY, pos.x, pos.y);
        if (d < HEX_RADIUS && d < minD) {
            minD = d; closest = h;
        }
    }
    return closest;
}

function redrawMap() {
    hexGroup.clear(true, true);
    for (const key in hexMap) {
        redrawHex(hexMap[key]);
    }
    drawOverlays();
}

function redrawHex(hex) {
    // Remove old sprite at this pos if needed? 
    // Optimization: In editor just clear/redraw is safer or track sprite refs.
    // We'll just draw on top for now, or clear full map on heavy ops.
    // For paintbrush, let's just add new sprite on top. 
    
    const pos = getHexPosition(hex.q, hex.r);
    const key = `${hex.terrain}${hex.variant}`;
    
    if (scene.textures.exists(key)) {
        const img = scene.add.image(pos.x, pos.y, key).setDisplaySize(HEX_RADIUS*2, HEX_RADIUS*2);
        
        // Hex Mask
        const shape = scene.make.graphics().fillStyle(0xffffff).beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i;
            const hx = pos.x + HEX_RADIUS * Math.cos(angle);
            const hy = pos.y + HEX_RADIUS * Math.sin(angle);
            if (i === 0) shape.moveTo(hx, hy); else shape.lineTo(hx, hy);
        }
        shape.closePath().fillPath();
        img.setMask(shape.createGeometryMask());
        hexGroup.add(img);

        // Hex Outline
        const outline = scene.add.graphics().lineStyle(1, 0x333333, 0.5).beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i;
            const hx = pos.x + HEX_RADIUS * Math.cos(angle);
            const hy = pos.y + HEX_RADIUS * Math.sin(angle);
            if (i === 0) outline.moveTo(hx, hy); else outline.lineTo(hx, hy);
        }
        outline.closePath().strokePath();
        hexGroup.add(outline);
    }
}

function drawOverlays() {
    overlayGraphics.clear();
    
    // Roads, Zones, Objs
    for (const key in hexMap) {
        const h = hexMap[key];
        const pos = getHexPosition(h.q, h.r);
        
        // Zones
        if (h.zone) {
            const color = (h.zone === 'blue') ? 0x4488ff : 0xff4444;
            overlayGraphics.fillStyle(color, 0.3);
            const pts = [];
            for (let i = 0; i < 6; i++) {
                const a = Math.PI / 3 * i;
                pts.push({x: pos.x + HEX_RADIUS*Math.cos(a), y: pos.y + HEX_RADIUS*Math.sin(a)});
            }
            overlayGraphics.fillPoints(pts);
        }

        // Road (Simple dot for now, Engine does lines)
        if (h.road) {
            overlayGraphics.fillStyle(0x555555, 1);
            overlayGraphics.fillCircle(pos.x, pos.y, 8);
        }

        // Objective
        if (h.obj > 0) {
            overlayGraphics.lineStyle(2, 0xffd700, 1);
            overlayGraphics.strokeCircle(pos.x, pos.y, 10);
            // We can't easily add text to graphics, so skipping text for perf in editor or add scene.add.text and track it
        }
    }
}

function redrawUnits() {
    unitGroup.clear(true, true);
    units.forEach(u => {
        const pos = getHexPosition(u.q, u.r);
        if (scene.textures.exists(u.type)) {
            const sprite = scene.add.image(pos.x, pos.y, u.type).setDisplaySize(HEX_RADIUS*1.4, HEX_RADIUS*1.4);
            unitGroup.add(sprite);
        }
    });
}

// --- Export ---

function exportJSON() {
    // 1. Terrain List
    const terrainList = [];
    const roadList = []; // Engine expects road segments, we have hexes. 
    // *Simplified Road Export*: We will just export connections between adjacent road hexes.
    
    for (const key in hexMap) {
        const h = hexMap[key];
        if (h.terrain !== 'clear') {
            terrainList.push({ q: h.q, r: h.r, type: h.terrain });
        }
        
        // Road Logic: Check neighbors
        if (h.road) {
            // Check SE, SW, S neighbors to avoid duplicates (one-way check)
            const neighbors = [
                {dq:1, dr:0}, {dq:0, dr:1}, {dq:-1, dr:1} // E, SE, SW in axial? No.
                // Axial neighbors: (+1,0), (+1,-1), (0,-1), (-1,0), (-1,+1), (0,+1)
                // We check half to create unique edges.
            ];
            // ... Actually simpler: Just export list of road hexes and let engine connect?
            // Engine v0.9.5 expects: map.roads = [ {from:{q,r}, to:{q,r}}, ... ]
            // We need to generate segments.
            
            // Axial offsets
            const offsets = [[1,0], [0,1], [-1,1]]; 
            offsets.forEach(off => {
                const nKey = `${h.q + off[0]},${h.r + off[1]}`;
                if (hexMap[nKey] && hexMap[nKey].road) {
                    roadList.push({
                        from: {q: h.q, r: h.r},
                        to: {q: h.q + off[0], r: h.r + off[1]}
                    });
                }
            });
        }
    }

    // 2. Zones
    const zones = [];
    for (const key in hexMap) {
        if(hexMap[key].zone) zones.push({ q: hexMap[key].q, r: hexMap[key].r, side: hexMap[key].zone });
    }

    // 3. Objectives
    const objectives = [];
    for (const key in hexMap) {
        if(hexMap[key].obj > 0) objectives.push({ q: hexMap[key].q, r: hexMap[key].r, points: hexMap[key].obj });
    }

    // 4. Units
    // Engine expects: { locked: [], tray: [] }
    // Editor units are "Locked" (pre-placed on map) unless we add a "Tray Mode" later.
    // Actually, usually map units are "Pre-deployed" (Locked isFixed=true? or just start on map?)
    // In Engine v0.9.5: "locked" array sets isFixed=true.
    // If we want them editable in setup, we might need a flag. 
    // For now, let's export them as 'locked' so they appear on map.
    
    // We also need to separate "Tray" units. Since this editor is simple placement,
    // let's assume everything on map is a STARTING UNIT.
    // If you want tray units, we'd need a separate list in UI.
    // For now, let's put all placed units into 'locked' (Start on map).
    
    const exportUnits = {
        locked: units,
        tray: [] // Empty for now
    };

    const data = {
        info: {
            title: document.getElementById('meta-title').value,
            author: document.getElementById('meta-author').value,
            description: document.getElementById('meta-desc').value,
            maxTurns: parseInt(document.getElementById('meta-turns').value)
        },
        map: {
            cols: mapCols,
            rows: mapRows,
            terrain: terrainList,
            roads: roadList,
            zones: zones
        },
        victory: {
            locations: objectives
        },
        units: exportUnits
    };

    const jsonStr = JSON.stringify(data, null, 2);
    
    // Download
    const blob = new Blob([jsonStr], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = "scenario.json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

</script>
</body>
</html>
