<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Wargame Editor v0.9.8 - Data Driven</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        :root {
            --bg-dark: #1e1e1e;
            --bg-panel: #2d2d2d;
            --accent: #d4a017;
            --text-main: #e0e0e0;
            --border: #444;
        }
        body { margin: 0; padding: 0; background: var(--bg-dark); color: var(--text-main); font-family: sans-serif; height: 100vh; display: grid; grid-template-columns: 280px 1fr 300px; overflow: hidden; }
        
        /* PANELS */
        .panel { background: var(--bg-panel); padding: 10px; border-right: 1px solid var(--border); display: flex; flex-direction: column; gap: 10px; overflow-y: auto; }
        #right-panel { border-left: 1px solid var(--border); border-right: none; }
        
        h3 { border-bottom: 2px solid var(--accent); padding-bottom: 5px; margin: 0 0 10px 0; font-size: 16px; color: var(--accent); }
        
        /* CONTROLS */
        .control-group { margin-bottom: 15px; border: 1px solid #444; padding: 8px; border-radius: 4px; background: #222; }
        .control-group label { display: block; margin-bottom: 5px; font-size: 12px; color: #aaa; }
        input, select, textarea { width: 100%; background: #333; color: #fff; border: 1px solid #555; padding: 5px; border-radius: 3px; box-sizing: border-box; }
        button { width: 100%; padding: 8px; background: #444; color: #fff; border: 1px solid #555; cursor: pointer; margin-bottom: 5px; border-radius: 3px; font-weight: bold; }
        button:hover { background: #555; border-color: #888; }
        button.active { background: var(--accent); color: #000; border-color: #fff; }
        
        /* PALETTE GRIDS */
        .palette-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; }
        .palette-item { aspect-ratio: 1; border: 1px solid #444; cursor: pointer; position: relative; }
        .palette-item img { width: 100%; height: 100%; object-fit: cover; }
        .palette-item:hover { border-color: #fff; }
        .palette-item.selected { border-color: var(--accent); box-shadow: 0 0 0 2px var(--accent); z-index: 10; }
        
        /* UNIT LIST */
        .unit-list-item { display: flex; align-items: center; gap: 8px; padding: 5px; background: #333; border: 1px solid #444; margin-bottom: 4px; cursor: pointer; }
        .unit-list-item:hover { background: #444; }
        .unit-list-item.selected { border-color: var(--accent); }
        .unit-icon { width: 30px; height: 30px; object-fit: contain; }

        /* MODAL */
        #json-modal { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 600px; height: 400px; background: #222; border: 2px solid var(--accent); padding: 20px; z-index: 1000; display: none; flex-direction: column; }
        #json-output { flex-grow: 1; background: #111; color: #0f0; font-family: monospace; margin-bottom: 10px; resize: none; }
    </style>
</head>
<body>

<div class="panel" id="left-panel">
    <h3>MAP TOOLS</h3>
    
    <div class="control-group">
        <label>Map Size (Cols x Rows)</label>
        <div style="display:flex; gap:5px">
            <input type="number" id="map-cols" value="15" min="5" max="50">
            <input type="number" id="map-rows" value="10" min="5" max="50">
        </div>
        <button onclick="resizeMap()" style="margin-top:5px">Apply Size</button>
    </div>

    <div class="control-group">
        <label>Terrain Palette</label>
        <div class="palette-grid" id="terrain-palette"></div>
    </div>

    <div class="control-group">
        <label>Drawing Mode</label>
        <button id="btn-draw-terrain" class="active" onclick="setMode('terrain')">Paint Terrain</button>
        <button id="btn-draw-road" onclick="setMode('road')">Place Roads</button>
        <button id="btn-draw-setup" onclick="setMode('setup')">Setup Zones</button>
    </div>
    
    <div style="margin-top:auto">
        <button style="border-color:#fa0; color:#fa0" onclick="exportMap()">EXPORT JSON</button>
        <button onclick="toggleModal()">Close/Open JSON</button>
    </div>
</div>

<div id="game-container"></div>

<div class="panel" id="right-panel">
    <h3>UNIT PLACEMENT</h3>
    
    <div class="control-group">
        <label>Faction Filter</label>
        <select id="faction-filter" onchange="renderUnitPalette()">
            <option value="ALL">All Factions</option>
            <option value="UK">British (UK)</option>
            <option value="GER">German (GER)</option>
        </select>
    </div>

    <div class="control-group">
        <label>Unit Palette</label>
        <div id="unit-palette-list" style="max-height:300px; overflow-y:auto;">
            </div>
    </div>

    <div class="control-group">
        <label>Selected Unit Properties</label>
        <div id="unit-props" style="display:none">
            <label>Name (Override)</label>
            <input type="text" id="prop-name">
            <label>Stance</label>
            <select id="prop-stance">
                <option value="deployed">Deployed</option>
                <option value="setup">Set Up</option>
                <option value="cover">In Cover</option>
            </select>
            <label>Status</label>
            <select id="prop-status">
                <option value="clear">Operational</option>
                <option value="shaken">Shaken</option>
            </select>
            <label>Placement Type</label>
            <div style="display:flex; gap:5px; margin-top:5px">
                <button onclick="setUnitMode('locked')">Locked</button>
                <button onclick="setUnitMode('tray')">Tray</button>
            </div>
            <div style="font-size:10px; color:#aaa; margin-top:5px">
                <b>Locked:</b> Starts on map.<br>
                <b>Tray:</b> Player places it.
            </div>
        </div>
        <div id="no-unit-msg" style="color:#666; font-style:italic">Select a unit from the list above to place it.</div>
    </div>
</div>

<div id="json-modal">
    <h3 style="margin:0 0 10px 0">SCENARIO JSON</h3>
    <textarea id="json-output"></textarea>
    <div style="display:flex; gap:10px">
        <button onclick="importMap()">Load from Text</button>
        <button onclick="toggleModal()">Close</button>
    </div>
</div>

<script>
// --- CONFIGURATION ---
const ASSETS_URL = 'https://raw.githubusercontent.com/trainJapan/HexWargame/main/artwork/';
const HEX_RADIUS = 40;

// --- STATE ---
let mapData = { cols: 15, rows: 10, terrain: [], roads: [], units: { locked: [], tray: [] }, zones: [] };
let terrainRegistry = {};
let unitRegistry = {};
let currentMode = 'terrain'; // terrain, road, setup
let selectedTerrain = 'clear';
let selectedUnitKey = null;
let isDrawing = false;
let roadStart = null;

// Phaser
let scene;
let hexMap = {};
let hexGroup, roadGraphics, unitGraphics, uiGraphics;

const config = {
    type: Phaser.AUTO,
    parent: 'game-container',
    width: window.innerWidth - 580,
    height: window.innerHeight,
    backgroundColor: '#111',
    scene: { preload: preload, create: create, update: update }
};
const game = new Phaser.Game(config);

function preload() {
    // 1. Load External Data
    this.load.json('units_uk', 'units_UK.json');
    this.load.json('units_ger', 'units_GER.json');
    this.load.json('terrain_data', 'terrain.json');

    // 2. We will load images in 'create' after parsing the JSONs
    //    because we don't know the filenames until we read the JSONs.
    
    // Fallback texture
    this.make.graphics({x:0,y:0,add:false}).fillStyle(0xffffff).fillRect(0,0,1,1).generateTexture('fallback', 1, 1);
}

function create() {
    scene = this;
    
    // --- PARSE DATA ---
    try {
        const ukData = this.cache.json.get('units_uk');
        const gerData = this.cache.json.get('units_ger');
        const tData = this.cache.json.get('terrain_data');

        if (!ukData || !gerData || !tData) {
            throw new Error("Failed to load JSON files. Ensure they are in the root directory.");
        }

        // Merge Units
        unitRegistry = { ...ukData, ...gerData };
        terrainRegistry = tData;

        // --- LOAD ASSETS DYNAMICALLY ---
        // 1. Terrain Images
        Object.values(terrainRegistry).forEach(t => {
            if(t.images) {
                t.images.forEach((imgFile, index) => {
                    // Key format: "clear1" derived from filename "clear1.png"
                    const key = imgFile.replace(/\.[^/.]+$/, "");
                    this.load.image(key, ASSETS_URL + 'map/' + imgFile);
                });
            }
        });

        // 2. Unit Images
        Object.entries(unitRegistry).forEach(([key, u]) => {
            if (u.image) {
                this.load.image(key, ASSETS_URL + 'counters/' + u.image);
            }
        });

        // Start Loader
        this.load.once('complete', () => {
            console.log("Assets loaded.");
            initEditor();
        });
        this.load.start();

    } catch (e) {
        alert("Error loading Data: " + e.message);
    }
}

function initEditor() {
    // Groups
    hexGroup = scene.add.group();
    roadGraphics = scene.add.graphics().setDepth(10);
    unitGraphics = scene.add.graphics().setDepth(20);
    uiGraphics = scene.add.graphics().setDepth(100);

    // Inputs
    scene.input.on('pointerdown', handlePointerDown);
    scene.input.on('pointerup', handlePointerUp);
    scene.input.on('pointermove', handlePointerMove);
    
    // UI Populators
    populateTerrainPalette();
    renderUnitPalette();
    
    // Initial Render
    resizeMap(); 
}

function update() {
    // Camera controls
    if (scene.input.activePointer.middleButtonDown()) {
        const p = scene.input.activePointer;
        scene.cameras.main.scrollX -= (p.x - p.prevPosition.x) / scene.cameras.main.zoom;
        scene.cameras.main.scrollY -= (p.y - p.prevPosition.y) / scene.cameras.main.zoom;
    }
}

// --- UI POPULATION ---

function populateTerrainPalette() {
    const container = document.getElementById('terrain-palette');
    container.innerHTML = '';
    
    Object.keys(terrainRegistry).forEach(key => {
        const t = terrainRegistry[key];
        // Use first image as preview
        const previewImg = t.images[0].replace(/\.[^/.]+$/, "");
        
        const div = document.createElement('div');
        div.className = 'palette-item';
        div.innerHTML = `<img src="${ASSETS_URL}map/${t.images[0]}">`;
        div.title = key.toUpperCase();
        div.onclick = () => {
            document.querySelectorAll('.palette-item').forEach(el => el.classList.remove('selected'));
            div.classList.add('selected');
            selectedTerrain = key;
            setMode('terrain');
        };
        
        if (key === 'clear') div.classList.add('selected');
        container.appendChild(div);
    });
}

function renderUnitPalette() {
    const filter = document.getElementById('faction-filter').value;
    const container = document.getElementById('unit-palette-list');
    container.innerHTML = '';
    
    Object.entries(unitRegistry).forEach(([key, unit]) => {
        // Filter Logic
        if (filter !== 'ALL') {
            if (filter === 'UK' && !key.startsWith('UK')) return;
            if (filter === 'GER' && !key.startsWith('GER')) return;
        }

        const div = document.createElement('div');
        div.className = 'unit-list-item';
        div.innerHTML = `
            <img src="${ASSETS_URL}counters/${unit.image}" class="unit-icon">
            <div style="font-size:11px">
                <div style="font-weight:bold; color:#fff">${unit.name}</div>
                <div style="color:#888">${unit.category}</div>
            </div>
        `;
        div.onclick = () => {
            document.querySelectorAll('.unit-list-item').forEach(el => el.classList.remove('selected'));
            div.classList.add('selected');
            selectedUnitKey = key;
            
            // Show properties
            document.getElementById('no-unit-msg').style.display = 'none';
            document.getElementById('unit-props').style.display = 'block';
            document.getElementById('prop-name').value = unit.name; // Default name
        };
        container.appendChild(div);
    });
}

// --- INTERACTION ---

function handlePointerDown(pointer) {
    if (pointer.rightButtonDown()) { roadStart = null; return; }
    
    const hex = getHexAt(pointer.worldX, pointer.worldY);
    if (!hex) return;

    if (currentMode === 'terrain') {
        isDrawing = true;
        setHexTerrain(hex, selectedTerrain);
    } 
    else if (currentMode === 'road') {
        if (!roadStart) {
            roadStart = hex;
        } else {
            addRoad(roadStart, hex);
            roadStart = hex; // Chain roads
        }
        drawRoads();
    }
    else if (currentMode === 'setup') {
        // Toggle setup zone
        if (hex.setupZone) delete hex.setupZone;
        else hex.setupZone = 'blue'; // Toggle cycle: null -> blue -> red -> null (implemented simply for now)
        drawGrid();
    }
}

function handlePointerMove(pointer) {
    if (isDrawing && currentMode === 'terrain') {
        const hex = getHexAt(pointer.worldX, pointer.worldY);
        if (hex) setHexTerrain(hex, selectedTerrain);
    }
}

function handlePointerUp() { isDrawing = false; }

function setMode(mode) {
    currentMode = mode;
    document.querySelectorAll('#left-panel button').forEach(b => b.classList.remove('active'));
    if(mode === 'terrain') document.getElementById('btn-draw-terrain').classList.add('active');
    if(mode === 'road') document.getElementById('btn-draw-road').classList.add('active');
    if(mode === 'setup') document.getElementById('btn-draw-setup').classList.add('active');
}

function setUnitMode(mode) {
    if (!selectedUnitKey) { alert("Select a unit first!"); return; }
    
    const hex = getHexAt(scene.input.activePointer.worldX, scene.input.activePointer.worldY);
    
    // Gather Props
    const props = {
        type: selectedUnitKey, // The key acts as the ID link to JSON
        name: document.getElementById('prop-name').value,
        stance: document.getElementById('prop-stance').value,
        status: document.getElementById('prop-status').value,
        quality: 'regular' // Default
    };

    if (mode === 'locked') {
        if (!hex) { alert("Hover over a hex to place locked unit."); return; }
        props.q = hex.q;
        props.r = hex.r;
        mapData.units.locked.push(props);
        alert(`Placed ${props.name} at ${hex.q},${hex.r}`);
    } else {
        mapData.units.tray.push(props);
        alert(`Added ${props.name} to Player Tray`);
    }
    drawUnits();
}

// --- MAP LOGIC ---

function resizeMap() {
    const cols = parseInt(document.getElementById('map-cols').value);
    const rows = parseInt(document.getElementById('map-rows').value);
    
    mapData.cols = cols;
    mapData.rows = rows;
    
    // Rebuild Map Object
    hexMap = {};
    for (let q = 0; q < cols; q++) {
        hexMap[q] = {};
        for (let r = 0; r < rows; r++) {
            const pos = getHexPoly(q, r);
            hexMap[q][r] = { 
                q: q, r: r, x: pos.x, y: pos.y, 
                terrain: 'clear', variant: 1 
            };
        }
    }
    
    // Restore preserved data if resizing
    drawGrid();
    drawRoads();
    drawUnits();
}

function setHexTerrain(hex, type) {
    hex.terrain = type;
    hex.variant = Phaser.Math.Between(1, 3);
    // Update data
    const existing = mapData.terrain.find(t => t.q === hex.q && t.r === hex.r);
    if (existing) existing.type = type;
    else mapData.terrain.push({ q: hex.q, r: hex.r, type: type });
    
    drawGrid();
}

function addRoad(h1, h2) {
    // Validate adjacency
    const dist = Math.abs(h1.q - h2.q) + Math.abs(h1.r - h2.r) + Math.abs((h1.q+h1.r)-(h2.q+h2.r)); // Cube dist approx
    // Simplified neighbor check for hexes
    // ... (Use engine logic for precision, assume valid for editor)
    
    mapData.roads.push({ from: {q:h1.q, r:h1.r}, to: {q:h2.q, r:h2.r} });
}

// --- DRAWING ---

function drawGrid() {
    hexGroup.clear(true, true);
    
    for (let q = 0; q < mapData.cols; q++) {
        for (let r = 0; r < mapData.rows; r++) {
            const hex = hexMap[q][r];
            const tKey = `${hex.terrain}${hex.variant}`;
            
            if (scene.textures.exists(tKey)) {
                const img = scene.add.image(hex.x, hex.y, tKey).setDisplaySize(HEX_RADIUS*2, HEX_RADIUS*2);
                // Masking would go here for perfect hexes
                hexGroup.add(img);
            } else {
                // Fallback color
                const color = 0x333333; // Default
                const g = scene.add.graphics().fillStyle(color).fillCircle(hex.x, hex.y, HEX_RADIUS-2);
                hexGroup.add(g);
            }
            
            // Setup Zone Overlay
            if (hex.setupZone) {
                const color = hex.setupZone === 'blue' ? 0x0000ff : 0xff0000;
                const z = scene.add.graphics().fillStyle(color, 0.3).fillCircle(hex.x, hex.y, HEX_RADIUS/2);
                hexGroup.add(z);
            }
        }
    }
}

function drawRoads() {
    roadGraphics.clear();
    roadGraphics.lineStyle(6, 0x666666);
    mapData.roads.forEach(r => {
        const h1 = hexMap[r.from.q][r.from.r];
        const h2 = hexMap[r.to.q][r.to.r];
        if (h1 && h2) roadGraphics.moveTo(h1.x, h1.y).lineTo(h2.x, h2.y).strokePath();
    });
}

function drawUnits() {
    unitGraphics.clear();
    mapData.units.locked.forEach(u => {
        const hex = hexMap[u.q][u.r];
        if(hex) {
            unitGraphics.fillStyle(0xffffff, 1);
            unitGraphics.fillCircle(hex.x, hex.y, 10);
            // In a real editor, draw the sprite
        }
    });
}

// --- HELPERS ---
function getHexPoly(q, r) {
    const x = q * HEX_RADIUS * 1.5;
    const y = r * HEX_RADIUS * Math.sqrt(3) + (q % 2 === 1 ? HEX_RADIUS * Math.sqrt(3) / 2 : 0);
    return { x, y };
}

function getHexAt(x, y) {
    let closest = null; let minD = Infinity;
    for(let q in hexMap) {
        for(let r in hexMap[q]) {
            const h = hexMap[q][r];
            const d = Phaser.Math.Distance.Between(x, y, h.x, h.y);
            if(d < HEX_RADIUS && d < minD) { minD = d; closest = h; }
        }
    }
    return closest;
}

// --- IO ---
function exportMap() {
    const json = JSON.stringify({
        info: { title: "New Scenario", author: "User" },
        map: mapData,
        units: mapData.units
    }, null, 2);
    document.getElementById('json-output').value = json;
    document.getElementById('json-modal').style.display = 'flex';
}

function toggleModal() {
    const el = document.getElementById('json-modal');
    el.style.display = (el.style.display === 'flex') ? 'none' : 'flex';
}
</script>
</body>
</html>
