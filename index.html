<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Wargame Engine v0.9.25 - The Vision & Arc Update</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        :root {
            --bg-dark: #1e1e1e;
            --bg-panel: #2a2a2a;
            --accent: #d4a017;
            --text-main: #e0e0e0;
            --text-dim: #a0a0a0;
            --border: #444;
            --blue-team: #4488ff;
            --red-team: #ff4444;
        }

        body { 
            margin: 0; padding: 0; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-dark);
            color: var(--text-main);
            height: 100vh;
            display: grid;
            grid-template-columns: 260px 1fr 320px;
            overflow: hidden;
        }

        /* --- LEFT PANEL --- */
        #left-panel {
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            padding: 15px;
            display: flex; flex-direction: column; gap: 10px;
            overflow-y: auto; z-index: 10;
        }

        .command-header {
            padding: 10px; text-align: center; font-weight: bold; font-size: 16px;
            border-radius: 4px; border: 2px solid transparent; cursor: default;
            text-transform: uppercase; box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: all 0.2s;
        }
        .cmd-blue { background: #223355; color: var(--blue-team); border-color: var(--blue-team); }
        .cmd-red { background: #552222; color: var(--red-team); border-color: var(--red-team); }

        .panel-header {
            color: var(--accent); font-size: 18px; font-weight: bold;
            margin-bottom: 5px; border-bottom: 2px solid var(--accent); padding-bottom: 5px;
        }
        .scenario-box {
            background: #333; border: 1px solid var(--border); padding: 10px;
            border-radius: 4px; font-size: 13px; min-height: 60px;
        }
        
        .score-box {
            display: grid; grid-template-columns: 1fr 1fr; gap: 5px;
            background: #222; padding: 8px; border-radius: 4px; border: 1px solid #444; margin-bottom: 5px;
        }
        .score-team { text-align: center; font-weight: bold; font-size: 14px; }
        .score-val { font-size: 18px; font-family: monospace; text-align: center; }
        .bar-container { grid-column: span 2; height: 6px; background: #444; margin-top: 5px; position: relative; border-radius:3px; overflow:hidden; }
        .bar-fill { height: 100%; background: var(--blue-team); width: 50%; transition: width 0.5s; }

        .turn-display {
            text-align: center; font-size: 14px; font-weight: bold;
            background: #222; padding: 8px;
            border: 1px solid var(--border); border-radius: 4px;
        }

        .menu-btn-group { display: flex; flex-direction: column; gap: 5px; }
        
        .btn {
            background: #444; color: var(--text-main); border: 1px solid #555;
            padding: 10px; cursor: pointer; border-radius: 4px;
            font-weight: bold; transition: background 0.2s; text-align: center;
        }
        .btn:hover { background: #555; border-color: #777; }
        .btn-primary { background: #d4a017; color: #111; border: none; }
        .btn-primary:hover { background: #b88a10; }
        .btn.active { background: var(--accent); color: #000; border-color: var(--accent); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .list-item {
            display: flex; align-items: center; gap: 10px;
            background: #222; border: 1px solid #444;
            padding: 5px; margin-bottom: 5px; cursor: pointer;
            border-left: 3px solid transparent;
            position: relative;
        }
        .list-item:hover { background: #333; border-color: #666; }
        .list-item.selected { border-color: var(--accent); background: #332200; }
        .list-item.arrival { border-left-color: #00ff00; }
        .list-icon { width: 32px; height: 32px; object-fit: contain; }
        .list-info { flex-grow: 1; }
        .list-title { font-weight:bold; font-size:12px; color:#fff; }
        .list-meta { font-size:10px; color:#aaa; }
        .list-stars { color: #ffd700; font-size: 10px; margin-left: 5px; }
        
        .reinf-rotate-box { display: flex; align-items: center; gap: 6px; margin-top: 4px; }
        .btn-rotate-mini { padding: 2px 6px; font-size: 10px; background: #555; border: 1px solid #777; color: #fff; cursor: pointer; border-radius: 3px; }
        .btn-rotate-mini:hover { background: #777; }
        .facing-label-mini { font-size: 10px; color: var(--accent); font-weight: bold; }

        /* --- DICE OVERLAY & RECEIPT --- */
        #dice-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); 
            display: none; flex-direction: column; align-items: center; justify-content: center; gap: 10px;
            z-index: 2000;
        }
        .dice-label {
            background: #111; color: var(--accent); padding: 10px 30px;
            border-radius: 4px; font-weight: bold; font-size: 20px;
            text-transform: uppercase; border: 1px solid var(--accent);
            box-shadow: 0 0 15px rgba(0,0,0,0.8); margin-bottom: 5px;
        }
        .dice-sub {
            color: #fff; font-size: 14px; font-weight: bold; 
            background: rgba(0,0,0,0.5); padding: 5px 15px; border-radius: 4px;
            border: 1px solid #555; text-align: center;
        }
        
        .d10-container { width: 120px; height: 120px; position: relative; filter: drop-shadow(0 15px 15px rgba(0,0,0,0.6)); margin: 10px 0; }
        .dice-shaking { animation: shake 0.1s infinite; }
        .d10-val {
            position: absolute; top: 38%; left: 50%; transform: translate(-50%, -50%);
            font-size: 40px; font-weight: bold; color: white;
            text-shadow: 2px 2px 4px black; font-family: 'Arial', sans-serif; pointer-events: none;
        }
        
        #dice-expl {
            color: #ccc; font-size: 13px;
            width: 380px; text-align: left;
            background: rgba(0,0,0,0.85); padding: 15px; border-radius: 6px; border: 1px solid var(--accent);
            font-family: 'Consolas', monospace; box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        .receipt-row { display: flex; justify-content: space-between; margin-bottom: 4px; border-bottom: 1px dashed #444; padding-bottom: 2px; }
        .receipt-total { display: flex; justify-content: space-between; margin-top: 8px; font-weight: bold; color: var(--accent); font-size: 16px; border-top: 2px solid var(--accent); padding-top: 5px; }

        .dice-result-text { font-size: 24px; font-weight: bold; text-transform: uppercase; margin-top: 5px; text-shadow: 0 0 10px rgba(0,0,0,0.8); display: none; }

        .dice-btn {
            background: var(--blue-team); color: white; border: none;
            padding: 10px 40px; font-size: 16px; font-weight: bold;
            border-radius: 4px; cursor: pointer; display: none;
            box-shadow: 0 0 10px rgba(68, 136, 255, 0.5); margin-top: 5px;
        }
        @keyframes shake { 0% { transform: rotate(0deg); } 25% { transform: rotate(5deg); } 50% { transform: rotate(-5deg); } 75% { transform: rotate(5deg); } 100% { transform: rotate(0deg); } }

        /* --- MODALS --- */
        .modal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 3000; display: none;
            flex-direction: column; align-items: center; justify-content: center;
        }
        .modal-card {
            background: #222; border: 2px solid var(--accent); padding: 30px;
            text-align: center; max-width: 400px; width: 80%;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }
        .mode-btn { width: 100%; margin-top: 10px; padding: 15px; font-size: 16px; }

        .tool-sub-options { display: flex; gap: 5px; margin-top: 5px; }
        .btn-small { padding: 5px; font-size: 11px; flex: 1; }

        #game-container { position: relative; overflow: hidden; background: #111; }

        /* --- RIGHT PANEL --- */
        #right-panel {
            background: var(--bg-panel); border-left: 1px solid var(--border);
            display: grid; grid-template-rows: auto 1fr 200px; overflow: hidden; z-index: 10;
        }
        #context-card { padding: 15px; background: #333; border-bottom: 1px solid var(--border); text-align: center; min-height: 140px; }
        .ctx-header-row { display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 5px; }
        .ctx-portrait { width: 80px; height: 80px; display: flex; align-items: center; justify-content: center; background: #222; border-radius: 4px; border: 1px solid #444; }
        .ctx-portrait img { width: 100%; height: 100%; object-fit: contain; }
        .ctx-side-info { width: 60px; font-size: 10px; font-weight: bold; text-align: center; padding: 4px; border-radius: 4px; background: #222; display: flex; align-items: center; justify-content: center; min-height: 24px; border: 1px solid #444; }
        .ctx-title { font-size: 16px; font-weight: bold; color: white; }
        .ctx-subtitle { font-size: 12px; color: var(--accent); margin-bottom: 5px; }
        .status-badges { display: flex; gap: 5px; justify-content: center; margin-top: 5px; flex-wrap: wrap; }
        .badge { font-size: 10px; padding: 3px 8px; border-radius: 3px; font-weight: bold; cursor: default; }
        .badge-terrain { cursor: pointer; border: 1px solid rgba(255,255,255,0.2); }
        .badge-vp { background: #000; color: #FFD700; border: 1px solid #FFD700; }
        #context-stats { padding: 15px; overflow-y: auto; }
        .stat-row { display: flex; justify-content: space-between; border-bottom: 1px solid #3a3a3a; padding: 4px 0; font-size: 13px; }
        .stat-label { color: var(--text-dim); }
        .stat-value { font-weight: bold; color: white; }

        #stack-list { display: flex; flex-direction: column; gap: 5px; margin-top: 10px; }
        .stack-item { cursor: pointer; border: 1px solid #444; border-radius: 4px; background: #222; padding: 5px; display: flex; align-items: center; gap: 10px; }
        .stack-item:hover { border-color: var(--accent); background: #333; }
        .stack-img { width: 40px; height: 40px; object-fit: contain; }
        .stack-info { flex-grow: 1; font-size: 11px; text-align: left; }
        .stack-name { font-weight:bold; color:white; }

        .stack-item.spent .stack-name { color: #ff4444 !important; }

        #log-container { background: #111; border-top: 1px solid var(--accent); padding: 10px; font-family: 'Consolas', monospace; font-size: 11px; overflow-y: auto; color: #ccc; }
        .log-entry { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }
        .log-turn { color: var(--accent); font-weight: bold; margin-top: 8px; }
        .log-combat { color: #ff5555; }
        .log-info { color: #88ccff; }
        .log-capture { color: #ffff00; }

        #json-modal { position: absolute; top: 50px; left: 50px; width: 300px; background: #222; border: 2px solid var(--accent); padding: 15px; z-index: 2000; display: none; }
    </style>
</head>
<body>

<div id="left-panel">
    <div id="command-header" class="command-header cmd-blue">
        UK COMMAND (BLUE)
    </div>

    <div class="panel-header">SCENARIO</div>
    <div class="scenario-box" id="scenario-info-box">
        <strong style="color:white">Wargame Engine</strong><br>
        <span style="color:#aaa">No Scenario Loaded</span><br>
        <p style="margin:5px 0 0 0; color:#888; font-style:italic">Load JSON to start...</p>
    </div>

    <div class="score-box">
        <div class="score-team" style="color:var(--blue-team)">UK</div>
        <div class="score-team" style="color:var(--red-team)">GER</div>
        <div class="score-val" style="color:var(--blue-team)" id="score-blue">0</div>
        <div class="score-val" style="color:var(--red-team)" id="score-red">0</div>
        <div class="bar-container">
            <div class="bar-fill" id="score-bar"></div>
        </div>
    </div>

    <div class="turn-display">
        TURN: <span id="turn-counter">1</span> / <span id="max-turns">-</span><br>
        <span style="color: var(--accent); font-size:12px;" id="phase-display">SETUP</span>
    </div>

    <div class="menu-btn-group">
        <button class="btn" onclick="toggleListMode('reinforcements')" id="btn-reinf">REINFORCEMENTS</button>
        <button class="btn" onclick="toggleListMode('strikes')" id="btn-strikes">OFF-BOARD STRIKES</button>
        <button class="btn btn-primary" id="btn-phase" onclick="nextPhase()">Finish Setup</button>
    </div>
    
    <div id="dynamic-list-area" style="flex-grow:1; overflow-y:auto; margin-top:10px;"></div>
    
    <div class="panel-header" style="margin-top:10px">TOOLS</div>
    <div>
        <button class="btn" id="btn-los" style="width:100%" onclick="toggleLOSTool()">Line of Sight Tool</button>
        <div id="los-options" class="tool-sub-options" style="display:none;">
            <button id="los-inf" class="btn btn-small active" onclick="setLOSType('infantry')">Infantry Height</button>
            <button id="los-veh" class="btn btn-small" onclick="setLOSType('vehicle')">Vehicle Height</button>
        </div>
        <button class="btn" id="btn-arc" style="width:100%; margin-top:5px;" onclick="toggleArcTool()">Show Frontal Arc</button>
    </div>
    <button class="btn" onclick="toggleMapLoader()" style="margin-top:5px;">Load Scenario JSON</button>
</div>

<div id="game-container">
    <div id="json-modal">
        <textarea id="json-input" rows="6" style="width:100%; background:#111; color:#fff; border:1px solid #444;" placeholder="Paste Scenario JSON..."></textarea>
        <button class="btn btn-primary" style="width:100%; margin-top:5px;" onclick="loadScenario()">Load</button>
        <button class="btn" style="width:100%; margin-top:5px;" onclick="toggleMapLoader()">Close</button>
    </div>

    <div id="mode-modal" class="modal-overlay">
        <div class="modal-card">
            <h2 style="color:var(--accent); margin-top:0">SELECT GAME MODE</h2>
            <button class="mode-btn btn btn-primary" onclick="startGameMode('hotseat')">HOTSEAT (2 Player)</button>
            <button class="mode-btn btn" disabled style="opacity:0.5; cursor:not-allowed">PLAYER VS AI (Coming Soon)</button>
        </div>
    </div>

    <div id="dice-overlay">
        <div class="dice-label" id="dice-label">Rolling...</div>
        <div class="dice-sub" id="dice-sub"></div>
        <div class="d10-container" id="dice-anim">
            <svg width="120" height="120" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <linearGradient id="diceGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#ffaa00;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#cc4400;stop-opacity:1" />
                    </linearGradient>
                </defs>
                <path d="M50 2 L95 38 L78 88 L22 88 L5 38 Z" fill="url(#diceGrad)" stroke="#fff" stroke-width="2" stroke-linejoin="round"/>
                <path d="M50 2 L80 38 L50 65 L20 38 Z" fill="none" stroke="#fff" stroke-width="2" stroke-linejoin="round"/>
                <path d="M5 38 L20 38" stroke="#fff" stroke-width="2"/> <path d="M95 38 L80 38" stroke="#fff" stroke-width="2"/> <path d="M22 88 L50 65" stroke="#fff" stroke-width="2"/>
                <path d="M78 88 L50 65" stroke="#fff" stroke-width="2"/>
            </svg>
            <div class="d10-val" id="dice-val">0</div>
        </div>
        <div id="dice-expl"></div>
        <div class="dice-result-text" id="dice-result-text"></div>
        <button class="dice-btn" id="dice-ok-btn">CONTINUE</button>
    </div>

    <div id="game-over-modal" class="modal-overlay">
        <div class="modal-card">
            <div style="font-size:32px; font-weight:bold; margin-bottom:10px;" id="end-title">VICTORY</div>
            <div style="color:#aaa; margin-bottom:20px; font-style:italic;" id="end-reason">Turns Limit Reached</div>
            <div style="margin-bottom:20px; font-size:18px;">
                <span style="color:var(--blue-team)">UK: <span id="end-blue">0</span></span> &nbsp;|&nbsp; 
                <span style="color:var(--red-team)">GER: <span id="end-red">0</span></span>
            </div>
            <button class="btn btn-primary" onclick="location.reload()">Return to Menu</button>
        </div>
    </div>
</div>

<div id="right-panel">
    <div id="context-card">
        <div class="ctx-header-row">
            <div id="ctx-status-left" class="ctx-side-info" style="color:#aaa;">-</div>
            <div class="ctx-portrait" id="ctx-img"></div>
            <div id="ctx-stance-right" class="ctx-side-info" style="color:#aaa;">-</div>
        </div>
        <div id="ctx-quality" style="color:#ffd700; font-size:16px; margin-bottom:5px; line-height:1;"></div>
        <div class="ctx-title" id="ctx-title">No Selection</div>
        <div class="ctx-subtitle" id="ctx-subtitle">-</div>
        <div class="status-badges" id="ctx-badges"></div>
        <div id="unit-actions" style="margin-top:10px; display:none; gap:5px; grid-template-columns: 1fr 1fr;">
            <button class="btn btn-game" style="padding:5px" onclick="selectAction('TACTICAL')">Tactical</button>
            <button class="btn btn-game" style="padding:5px" onclick="startHastyMove()">Hasty</button>
            <button class="btn btn-game" style="padding:5px" onclick="selectAction('FACING')">Face</button>
            <button class="btn btn-game" style="padding:5px; border-color:#ff5555; color:#ff5555" onclick="selectAction('FIRE')">FIRE</button>
            <button class="btn btn-setup" style="padding:5px; display:none" onclick="selectAction('FACING')">Rotate</button>
            <button class="btn btn-setup" style="padding:5px; border-color:#ffaa00; color:#ffaa00; display:none" onclick="redeployUnit()">Redeploy</button>
            
            <button class="btn btn-game" id="btn-finish-move" style="padding:5px; border-color:#d4a017; color:#d4a017; grid-column:span 2; display:none;" onclick="finishHastyMove()">FINISH MOVE</button>
        </div>
    </div>
    <div id="context-stats">
        <div class="panel-header" style="font-size:14px; border-width:1px;" id="stats-header">STATISTICS</div>
        <div id="stats-content"></div>
        <div id="stack-container" style="display:none; margin-top:15px;">
            <div class="panel-header" style="font-size:14px; border-width:1px;">STACK (Top First)</div>
            <div id="stack-list"></div>
        </div>
    </div>
    <div id="log-container">
        <div class="log-entry">System initialized.</div>
    </div>
</div>

<script>
// --- Configuration ---
const ASSETS_URL = 'https://raw.githubusercontent.com/trainJapan/HexWargame/main/artwork/';
const FACING_DIRS = ["N","NE","SE","S","SW","NW"];

// --- DYNAMIC REGISTRIES ---
let UNIT_DATA_REGISTRY = {};
let TERRAIN_TYPES = {};
let SPOTTING_RULES = null; 

const HEX_RADIUS = 40;

// Game State
let scenarioData = null; 
let mapData = null; 
let losTool = false;
let arcTool = false; 
let losStartHex = null;
let losUnitType = 'infantry';
let units = [];
let activeSide = 'blue'; 
let initiativeWinner = 'blue';

// Separate Data Lists
let setupTrayUnits = []; 
let reinforcementUnits = []; 
let strikes = [];    

let unitIdCounter = 2000;
let currentTurn = 1;
let currentPhase = 'SETUP'; 
let scores = { blue: 0, red: 0 };
let captureOwners = {}; 
let currentListMode = 'tray'; 

// Selection State
let selectedUnit = null; 
let selectedHex = null; 
let selectedTrayItem = null; 
let currentAction = null; 
let isDeploying = false; 

// Phaser Objects
let scene, hexGroup, zoneGraphics, roadGraphics, objGraphics, selectionGraphics, losGraphics, arcGraphics, unitGraphics, badgeGraphics, hexMap = {};
let unitSprites = {};
let objectiveSprites = []; 
let diceCallback = null; 
let cursors; 

const config = {
    type: Phaser.AUTO, parent: 'game-container',
    width: window.innerWidth - 580, height: window.innerHeight,
    backgroundColor: '#1a1a1a',
    fps: { target: 30, forceSetTimeOut: true },
    scene: { preload: preloadScene, create: createScene, update: updateScene }
};

const game = new Phaser.Game(config);

function preloadScene() {
    this.load.json('units_uk', 'units_UK.json');
    this.load.json('units_ger', 'units_GER.json');
    this.load.json('terrain_data', 'terrain.json');
    this.load.json('spotting_rules', 'spotting.json'); 
    this.make.graphics({x:0,y:0,add:false}).fillStyle(0xffffff).fillRect(0,0,1,1).generateTexture('fallback', 1, 1);
    
    // FOW Assets
    this.load.image('UK_FOW_Infantry', ASSETS_URL + 'counters/UK_FOW_Infantry.png');
    this.load.image('GER_FOW_Infantry', ASSETS_URL + 'counters/GER_FOW_Infantry.png');
    this.load.image('UK_FOW_Vehicle', ASSETS_URL + 'counters/UK_FOW_Vehicle.png');
    this.load.image('GER_FOW_Vehicle', ASSETS_URL + 'counters/GER_FOW_Vehicle.png');
}

function createScene() {
    scene = this;
    cursors = this.input.keyboard.createCursorKeys(); 
    
    createFOWTextures();

    try {
        const ukData = this.cache.json.get('units_uk') || {};
        const gerData = this.cache.json.get('units_ger') || {};
        const tData = this.cache.json.get('terrain_data') || {};
        SPOTTING_RULES = this.cache.json.get('spotting_rules') || null;

        if(!SPOTTING_RULES) console.warn("spotting.json failed to load!");
        
        Object.entries(ukData).forEach(([key, data]) => { data.key = key; data.side = 'blue'; UNIT_DATA_REGISTRY[key] = data; });
        Object.entries(gerData).forEach(([key, data]) => { data.key = key; data.side = 'red'; UNIT_DATA_REGISTRY[key] = data; });
        Object.entries(tData).forEach(([key, data]) => {
            TERRAIN_TYPES[key] = {
                images: data.images || [],
                color: 0x555555, los: (data.los_effect || 'clear').toLowerCase(), cost: data.movement_cost || 1,
                terrainHeight: data.terrain_height || 0, infantryUsable: data.unit_height_infantry || 0, vehicleUsable: data.unit_height_vehicle || 0
            };
        });
        
        let loadCount = 0;
        Object.values(UNIT_DATA_REGISTRY).forEach(u => { if(u.image) { this.load.image(u.key, ASSETS_URL + 'counters/' + u.image); loadCount++; } });
        Object.values(TERRAIN_TYPES).forEach(t => { if(t.images) { t.images.forEach(img => { const k = img.replace(/\.[^/.]+$/, ""); this.load.image(k, ASSETS_URL + 'map/' + img); }); loadCount++; } });
        if(loadCount > 0) { this.load.once('complete', () => { initEngine(); }); this.load.start(); } else { initEngine(); }
    } catch(e) { console.error("Error parsing JSON:", e); alert("Failed to load JSONs."); }
}
// --- END OF PART 1 ---
function createFOWTextures() {
    const types = ['UK_FOW_Infantry', 'GER_FOW_Infantry', 'UK_FOW_Vehicle', 'GER_FOW_Vehicle'];
    types.forEach(key => {
        if (!scene.textures.exists(key)) {
            const g = scene.make.graphics({x:0,y:0,add:false});
            g.fillStyle(0x444444);
            g.fillRect(0,0,40,40);
            g.lineStyle(2, 0xaaaaaa);
            g.strokeRect(0,0,40,40);
            g.generateTexture(key, 40, 40);
        }
    });
    const g = scene.make.graphics({x:0,y:0,add:false});
    g.fillStyle(0x333333); g.fillRect(0,0,40,40);
    g.generateTexture('fow_generic', 40, 40);
}

function initEngine() {
    hexGroup = scene.add.group(); 
    zoneGraphics = scene.add.graphics().setDepth(20); 
    roadGraphics = scene.add.graphics().setDepth(100);
    objGraphics = scene.add.graphics().setDepth(150); 
    selectionGraphics = scene.add.graphics().setDepth(500); 
    losGraphics = scene.add.graphics().setDepth(550);        
    arcGraphics = scene.add.graphics().setDepth(560); // Arc layer above LOS but below units
    unitGraphics = scene.add.graphics().setDepth(700);       
    badgeGraphics = scene.add.graphics().setDepth(800);     
    scene.cameras.main.setBounds(-2000, -2000, 8000, 8000); 
    scene.input.mouse.disableContextMenu();
    
    scene.input.on('wheel', (pointer, gameObjects, deltaX, deltaY) => {
        const zoom = scene.cameras.main.zoom - (deltaY * 0.001);
        scene.cameras.main.setZoom(Phaser.Math.Clamp(zoom, 0.3, 2));
    });
    
    scene.input.on('pointerdown', (pointer) => {
        if (pointer.leftButtonDown()) handleLeftClick(pointer);
        if (pointer.rightButtonDown()) {
            if (currentAction) { currentAction = null; uiUpdate(); addToLog("Action cancelled.", "log-info"); }
            if (selectedTrayItem) { 
                selectedTrayItem = null; 
                isDeploying = false; 
                displayMap(); 
                updateDynamicList(); 
            }
        }
    });
    
    document.getElementById('dice-ok-btn').addEventListener('click', closeDiceOverlay);
    addToLog("System initialized (v0.9.25).");
}

function updateScene() {
    if (this.input.activePointer.rightButtonDown()) {
        const pointer = this.input.activePointer;
        this.cameras.main.scrollX -= (pointer.x - pointer.prevPosition.x) / this.cameras.main.zoom;
        this.cameras.main.scrollY -= (pointer.y - pointer.prevPosition.y) / this.cameras.main.zoom;
    }
    if (cursors) {
        const cam = this.cameras.main;
        const speed = 15 / cam.zoom;
        if (cursors.left.isDown) cam.scrollX -= speed;
        if (cursors.right.isDown) cam.scrollX += speed;
        if (cursors.up.isDown) cam.scrollY -= speed;
        if (cursors.down.isDown) cam.scrollY += speed;
    }
}

// --- D10 DICE SYSTEM ---
function rollD10(label, callback, explanationHtml="", subLabel="", isSuccess=null) {
    const overlay = document.getElementById('dice-overlay');
    const container = document.getElementById('dice-anim');
    const valDisplay = document.getElementById('dice-val');
    const lbl = document.getElementById('dice-label');
    const sub = document.getElementById('dice-sub');
    const explDiv = document.getElementById('dice-expl');
    const resText = document.getElementById('dice-result-text');
    const btn = document.getElementById('dice-ok-btn');
    
    overlay.style.display = 'flex';
    btn.style.display = 'none'; 
    resText.style.display = 'none';
    lbl.innerText = label || "ROLLING...";
    sub.innerText = subLabel || "";
    explDiv.innerHTML = explanationHtml;
    
    container.classList.add('dice-shaking');
    diceCallback = callback;
    
    let result = 1;
    const interval = setInterval(() => {
        result = Phaser.Math.Between(1, 10);
        valDisplay.innerText = result === 10 ? "0" : result;
    }, 50);

    setTimeout(() => {
        clearInterval(interval);
        result = Phaser.Math.Between(1, 10);
        valDisplay.innerText = result === 10 ? "0" : result;
        container.classList.remove('dice-shaking');
        
        // Handle Success/Failure Verdict
        if(isSuccess !== null) {
            resText.style.display = 'block';
            if(isSuccess(result)) {
                resText.innerText = "SUCCESS! Target Revealed.";
                resText.style.color = "#00ff00";
            } else {
                resText.innerText = "FAILURE! Target Remains Hidden.";
                resText.style.color = "#ff4444";
            }
        }

        btn.style.display = 'block'; 
        diceCallback = () => { if(callback) callback(result); };
    }, 800);
}

function closeDiceOverlay() {
    document.getElementById('dice-overlay').style.display = 'none';
    if(diceCallback) diceCallback();
    diceCallback = null;
}

// --- ARC TOOL LOGIC ---
function toggleArcTool() {
    arcTool = !arcTool;
    document.getElementById('btn-arc').classList.toggle('active', arcTool);
    if (!arcTool) {
        arcGraphics.clear();
        addToLog("Arc Tool Deactivated.", "log-info");
    } else {
        addToLog("Arc Tool Activated. Select a unit to see its frontal arc.", "log-info");
        uiUpdate();
    }
}

function drawFrontalArc(unit) {
    arcGraphics.clear();
    if (!arcTool || !unit || unit.facing === 'X') return;

    const startHex = hexMap[unit.q][unit.r];
    const maxRange = 25; // Visual limit for the arc overlay

    // Check every hex on the map
    for (let q = 0; q < mapData.cols; q++) {
        for (let r = 0; r < mapData.rows; r++) {
            const targetHex = hexMap[q][r];
            if (targetHex === startHex) continue;

            // Use the existing Frontal Arc logic
            if (isInFrontalArc(unit, targetHex)) {
                const dist = getHexDistance(startHex, targetHex);
                if (dist <= maxRange) {
                    const p = getHexPosition(q, r);
                    const pts = [];
                    for (let i = 0; i < 6; i++) {
                        pts.push({
                            x: p.x + HEX_RADIUS * Math.cos(Math.PI / 3 * i),
                            y: p.y + HEX_RADIUS * Math.sin(Math.PI / 3 * i)
                        });
                    }
                    arcGraphics.fillStyle(0x000000, 0.4);
                    arcGraphics.fillPoints(pts, true);
                }
            }
        }
    }
}

// --- COMMAND VIEW LOGIC ---
function switchSideTo(side) {
    activeSide = side;
    const header = document.getElementById('command-header');
    
    selectedUnit = null;
    selectedHex = null;
    selectedTrayItem = null;
    isDeploying = false;
    currentAction = null;

    if (activeSide === 'blue') {
        header.className = 'command-header cmd-blue';
        header.innerText = 'UK COMMAND (BLUE)';
    } else {
        header.className = 'command-header cmd-red';
        header.innerText = 'GER COMMAND (RED)';
    }
    
    updateScenarioInfo();
    updateDynamicList();
    displayMap(); 
    uiUpdate();
    addToLog(`View switched to ${activeSide.toUpperCase()} Command.`);
}

function updateScenarioInfo() {
    if(!scenarioData) return;
    let briefing = "";
    if (scenarioData.info.briefing && typeof scenarioData.info.briefing === 'object') {
        briefing = scenarioData.info.briefing[activeSide] || "No Briefing.";
    } else {
        briefing = scenarioData.info.description || "No Briefing.";
    }

    document.getElementById('scenario-info-box').innerHTML = `
        <strong style="color:white">${scenarioData.info.title}</strong><br>
        <span style="color:#aaa">${scenarioData.info.author}</span><br>
        <div style="margin:5px 0 0 0; font-size:11px; color:#ddd; background:#222; padding:4px; border:1px solid #444;">
            <strong style="color:${activeSide==='blue'?'#4488ff':'#ff4444'}">BRIEFING:</strong> ${briefing}
        </div>`;
}
// --- END OF PART 2 ---
// --- ADVANCED SPOTTING ENGINE ---
let spottingQueue = [];
let isSpottingQueueRunning = false;

function queueSpottingCheck(observer, target, isReactive) {
    spottingQueue.push({observer, target, isReactive});
    if(!isSpottingQueueRunning) processSpottingQueue();
}

function processSpottingQueue() {
    if(spottingQueue.length === 0) {
        isSpottingQueueRunning = false;
        uiUpdate();
        return;
    }
    isSpottingQueueRunning = true;
    const task = spottingQueue.shift();
    executeSpottingCheck(task.observer, task.target, task.isReactive, processSpottingQueue);
}

function updateSpottingMemory(observer, target, level) {
    if(!observer.memory) observer.memory = {};
    const currentData = observer.memory[target.id] || { level: 0, turnSpotted: 0 };
    if (level > currentData.level) {
        observer.memory[target.id] = { level: level, turnSpotted: currentTurn };
        // Sharing Intel with adjacent friendly units
        if (level === 2) {
            units.filter(u => u.side === observer.side && u.q === observer.q && u.r === observer.r && u.id !== observer.id && u.hp > 0)
                 .forEach(friend => {
                     if(!friend.memory) friend.memory = {};
                     const fCurrent = friend.memory[target.id] ? friend.memory[target.id].level : 0;
                     if(fCurrent < 2) friend.memory[target.id] = { level: 2, turnSpotted: currentTurn };
                 });
        }
    }
}

// --- STICKY MEMORY: LOS REVOCATION ---
function reevaluateVisibility(movingUnit) {
    units.filter(u => u.side !== movingUnit.side && u.hp > 0).forEach(observer => {
        if (observer.memory && observer.memory[movingUnit.id] && observer.memory[movingUnit.id].level === 2) {
            const isObsInf = (observer.category !== 'vehicle' && observer.category !== 'hwt');
            const obsHeight = isObsInf ? 'infantry' : 'vehicle';
            const los = calculateLOS(hexMap[observer.q][observer.r], hexMap[movingUnit.q][movingUnit.r], obsHeight);
            
            // If LOS is now blocked or impossible terrain, downgrade memory to Level 1 (FOW)
            const tTerrain = hexMap[movingUnit.q][movingUnit.r].terrain;
            const isTargetInf = (movingUnit.category !== 'vehicle' && movingUnit.category !== 'hwt');
            const concealGroup = isTargetInf ? SPOTTING_RULES.terrain_concealment.infantry : SPOTTING_RULES.terrain_concealment.vehicle;
            
            if (los.status === 'blocked' || concealGroup[tTerrain] === null) {
                observer.memory[movingUnit.id].level = 1; 
                addToLog(`[VISION] ${observer.name} lost sight of ${movingUnit.name} [${movingUnit.q},${movingUnit.r}].`, "log-info");
            }
        }
    });
}

function isInFrontalArc(spotter, targetHex) {
    if (spotter.facing === 'X') return true; 
    const targetPos = getHexPosition(targetHex.q, targetHex.r);
    const spotterPos = getHexPosition(spotter.q, spotter.r);
    const angleRad = Phaser.Math.Angle.Between(spotterPos.x, spotterPos.y, targetPos.x, targetPos.y);
    const angleDeg = Phaser.Math.RadToDeg(angleRad);
    const idealAngles = [ -90, -30, 30, 90, 150, -150 ];
    let attackDirIndex = 0; let minDiff = 360;
    idealAngles.forEach((ideal, index) => {
        let diff = Math.abs(Phaser.Math.Angle.WrapDegrees(angleDeg - ideal));
        if (diff < minDiff) { minDiff = diff; attackDirIndex = index; }
    });
    let diff = Math.abs(spotter.facing - attackDirIndex);
    if (diff > 3) diff = 6 - diff;
    return diff <= 1; 
}

function calculateSpottingChance(observer, target) {
    let receipt = { chance: 100, html: "", log: "", autoSpot: false, autoFow: false, impossible: false, targetRoll: 0 };
    if(!SPOTTING_RULES) { receipt.autoSpot = true; return receipt; }

    const dist = getHexDistance(observer, target);
    const isTargetInf = (target.category !== 'vehicle' && target.category !== 'hwt');
    const isObsInf = (observer.category !== 'vehicle' && observer.category !== 'hwt');
    
    // Auto FOW adjacent
    if (dist <= SPOTTING_RULES.auto_fow_rules.adjacent_distance) {
        if (isObsInf && SPOTTING_RULES.auto_fow_rules.infantry_spotter_sees_all) receipt.autoFow = true;
        if (!isObsInf && !isTargetInf && SPOTTING_RULES.auto_fow_rules.vehicle_spotter_sees_vehicle) receipt.autoFow = true;
    }

    receipt.html += `<div class="receipt-row"><span>Base Chance:</span> <span>100%</span></div>`;
    receipt.log += `(Base 100%`;

    // Helpers to force the '+' sign
    const fmt = (val) => val > 0 ? `+${val}` : val;

    // Unit States
    const stateGroup = isTargetInf ? SPOTTING_RULES.unit_states.infantry : SPOTTING_RULES.unit_states.vehicle;
    let stanceKey = target.stance || 'deployed';
    if (target.hasMovedThisTurn) stanceKey = 'moving';
    const stateMod = stateGroup[stanceKey] || 0;
    if (stateMod !== 0) {
        receipt.chance += stateMod;
        receipt.html += `<div class="receipt-row"><span>Target ${stanceKey.toUpperCase()}:</span> <span>${fmt(stateMod)}%</span></div>`;
        receipt.log += ` ${fmt(stateMod)}% ${stanceKey}`;
    }

    // Terrain Concealment
    const tTerrain = hexMap[target.q][target.r].terrain;
    const concealGroup = isTargetInf ? SPOTTING_RULES.terrain_concealment.infantry : SPOTTING_RULES.terrain_concealment.vehicle;
    const concealMod = concealGroup[tTerrain];
    if (concealMod === null) { receipt.impossible = true; receipt.log += ` - Blocked by ${tTerrain})`; return receipt; }
    else if (concealMod !== 0) {
        receipt.chance += concealMod;
        receipt.html += `<div class="receipt-row"><span>Terrain (${tTerrain}):</span> <span>${fmt(concealMod)}%</span></div>`;
        receipt.log += ` ${fmt(concealMod)}% ${tTerrain}`;
    }

    // LOS Quality
    const obsHeight = isObsInf ? 'infantry' : 'vehicle';
    const los = calculateLOS(hexMap[observer.q][observer.r], hexMap[target.q][target.r], obsHeight);
    const losMod = SPOTTING_RULES.los_quality[los.status];
    if (losMod === null) { receipt.impossible = true; receipt.log += ` - LOS Blocked)`; return receipt; }
    else if (losMod !== 0) {
        receipt.chance += losMod;
        receipt.html += `<div class="receipt-row"><span>LOS (${los.status}):</span> <span>${fmt(losMod)}%</span></div>`;
        receipt.log += ` ${fmt(losMod)}% LOS`;
    }

    // Scenario
    if (dist > SPOTTING_RULES.scenario_modifiers.visibility.distance_threshold) {
        let visObj = scenarioData?.info?.visibility || 'normal';
        let visMod = SPOTTING_RULES.scenario_modifiers.visibility[visObj] || 0;
        if(visMod !== 0) { receipt.chance += visMod; receipt.html += `<div class="receipt-row"><span>Vis (${visObj}):</span> <span>${fmt(visMod)}%</span></div>`; receipt.log += ` ${fmt(visMod)}% vis`; }
    }
    if (dist > SPOTTING_RULES.scenario_modifiers.time.distance_threshold) {
        let timeObj = scenarioData?.info?.time || 'day';
        let timeMod = SPOTTING_RULES.scenario_modifiers.time[timeObj] || 0;
        if(timeMod !== 0) { receipt.chance += timeMod; receipt.html += `<div class="receipt-row"><span>Time (${timeObj}):</span> <span>${fmt(timeMod)}%</span></div>`; receipt.log += ` ${fmt(timeMod)}% time`; }
    }

    // Fired penalty (Snipers ignore)
    if (target.hasFiredThisTurn) {
        let isSniper = target.name && target.name.toLowerCase().includes("sniper");
        let fireMod = isSniper ? SPOTTING_RULES.situational_modifiers.fired_this_turn.sniper_penalty : SPOTTING_RULES.situational_modifiers.fired_this_turn.standard_penalty;
        if (fireMod !== 0) {
            receipt.chance += fireMod;
            receipt.html += `<div class="receipt-row"><span>Target Fired:</span> <span>+${fireMod}%</span></div>`;
            receipt.log += ` +${fireMod}% fired`;
        }
    }

    // Facing Arcs
    const inFront = isInFrontalArc(observer, hexMap[target.q][target.r]);
    if (!inFront) {
        let arcMod = 0;
        if (!isObsInf && isTargetInf) arcMod = SPOTTING_RULES.situational_modifiers.out_of_arc_penalties.infantry_spotted_by_vehicle;
        else if (!isObsInf && !isTargetInf) arcMod = SPOTTING_RULES.situational_modifiers.out_of_arc_penalties.vehicle_spotted_by_vehicle;
        else if (isObsInf && isTargetInf) arcMod = SPOTTING_RULES.situational_modifiers.out_of_arc_penalties.infantry_spotted_by_infantry;
        if (arcMod !== 0) {
            receipt.chance += arcMod;
            receipt.html += `<div class="receipt-row"><span>Out of Arc:</span> <span>${fmt(arcMod)}%</span></div>`;
            receipt.log += ` ${fmt(arcMod)}% arc`;
        }
    }

    receipt.log += `)`;
    if (receipt.chance >= 100) receipt.autoSpot = true;
    if (receipt.chance <= 0) receipt.impossible = true;
    receipt.targetRoll = Math.floor(receipt.chance / 10);
    if (receipt.targetRoll > 9) receipt.targetRoll = 9;

    receipt.html += `<div class="receipt-total"><span>FINAL CHANCE:</span> <span>${receipt.chance}%</span></div>`;
    return receipt;
}

function executeSpottingCheck(observer, target, isReactive, nextCallback) {
    const r = calculateSpottingChance(observer, target);
    if (r.autoFow) updateSpottingMemory(observer, target, 1);
    if (r.impossible) { nextCallback(); return; }
    
    const obsPos = `[${observer.q},${observer.r}]`;
    const tarPos = `[${target.q},${target.r}]`;
    const subHeader = `${observer.name} ${obsPos} -> ${target.name} ${tarPos}`;

    if (r.autoSpot) {
        updateSpottingMemory(observer, target, 2);
        addToLog(`[SPOTTING] ${observer.name} ${obsPos} -> ${target.name} ${tarPos} ${r.log}. Auto-Spotted!`, "log-info");
        redrawAllUnits();
        nextCallback();
        return;
    }

    const title = isReactive ? "REACTIVE SPOTTING" : "ACTIVE SPOTTING";
    rollD10(title, (roll) => {
        let hit = (roll !== 10 && roll <= r.targetRoll);
        let rollVal = (roll === 10) ? 0 : roll;
        if (hit) {
            updateSpottingMemory(observer, target, 2);
            addToLog(`[SPOTTING] ${observer.name} ${obsPos} -> ${target.name} ${tarPos} ${r.log}. Roll: ${rollVal}. Success!`, "log-info");
            redrawAllUnits();
        } else {
            addToLog(`[SPOTTING] ${observer.name} ${obsPos} -> ${target.name} ${tarPos} ${r.log}. Roll: ${rollVal}. Failed.`, "log-info");
        }
        nextCallback();
    }, r.html, subHeader, (res) => (res !== 10 && res <= r.targetRoll));
}

function runActiveSpotting(observer) {
    units.filter(u => u.side !== observer.side && u.hp > 0).forEach(target => {
        if (observer.memory && observer.memory[target.id] && observer.memory[target.id].level === 2) return;
        queueSpottingCheck(observer, target, false);
    });
}

function runReactiveSpotting(movingUnit) {
    units.filter(u => u.side !== movingUnit.side && u.hp > 0 && !u.hasActed).forEach(enemy => {
        if (enemy.memory && enemy.memory[movingUnit.id] && enemy.memory[movingUnit.id].level === 2) return;
        queueSpottingCheck(enemy, movingUnit, true);
    });
}

// --- LIST & TRAY SYSTEM ---
function updateDynamicList() {
    const container = document.getElementById('dynamic-list-area');
    container.innerHTML = '';
    let title = ""; let listData = [];
    
    if(currentPhase === 'SETUP' && currentListMode === 'tray') {
        title = "SETUP TRAY";
        listData = setupTrayUnits.filter(u => u.side === activeSide);
    } else if (currentListMode === 'reinforcements') {
        title = "REINFORCEMENTS";
        listData = reinforcementUnits.filter(u => u.side === activeSide); 
    } else if (currentListMode === 'strikes') {
        title = "OFF-BOARD STRIKES";
        listData = strikes.filter(u => u.side === activeSide);
    }

    container.innerHTML = `<div class="panel-header" style="font-size:14px; border-width:1px;">${title}</div>`;
    if(listData.length === 0) { container.innerHTML += '<div style="color:#666; font-style:italic; padding:10px;">Empty.</div>'; return; }

    listData.forEach(item => {
        const div = document.createElement('div');
        div.className = 'list-item';
        if(selectedTrayItem === item) div.classList.add('selected');
        
        // FORCING NORTH FOR SETUP TRAY
        if (item.facing === undefined || item.facing === 'X') item.facing = 0; 

        const uTurn = parseInt(item.turn) || 0;
        const isSetup = (currentPhase === 'SETUP');
        let isDeployable = (isSetup && currentListMode === 'tray') || (currentTurn === uTurn && currentListMode === 'reinforcements');
        
        const info = UNIT_DATA_REGISTRY[item.type];
        let imgUrl = info && info.image ? `${ASSETS_URL}counters/${info.image}` : `${ASSETS_URL}counters/${item.type}.png`;
        let displayName = item.name || (info ? info.name : item.type);

        div.innerHTML = `
        <img src="${imgUrl}" class="list-icon" onerror="this.style.display='none'">
        <div class="list-info">
            <div class="list-title">${displayName}</div>
            <div class="list-meta">Facing: ${FACING_DIRS[item.facing]}</div>
            <div class="reinf-rotate-box">
                <button class="btn-rotate-mini">Rotate</button>
            </div>
        </div>`;
        
        if (!isDeployable) div.style.opacity = "0.5";
        div.querySelector('.btn-rotate-mini').onclick = (e) => {
            e.stopPropagation();
            item.facing = (item.facing + 1) % 6;
            updateDynamicList();
        };

        div.onclick = () => {
            if (!isDeployable) return;
            selectedTrayItem = (selectedTrayItem === item) ? null : item;
            isDeploying = !!selectedTrayItem;
            displayMap(); updateDynamicList(); uiUpdate();
        };
        container.appendChild(div);
    });
}
// --- DEPLOYMENT & ACTION LOGIC ---
function deployTrayUnit(uData, hex) {
    if (currentPhase === 'SETUP' && !setupTrayUnits.includes(uData)) {
        addToLog("Cannot deploy Reinforcements during Setup!", "log-combat");
        return;
    }

    let valid = false;
    if(currentPhase === 'SETUP') {
        if (uData.side === 'blue' && hex.setupZone === 'blue') valid = true;
        if (uData.side === 'red' && hex.setupZone === 'red') valid = true;
    } else {
        if(uData.locType === 'hex') {
            const [tq, tr] = uData.locVal.split(',').map(Number);
            if(hex.q === tq && hex.r === tr) valid = true;
        } else if (uData.locType === 'edge') {
            const side = uData.locVal; 
            if (side === 'N' && hex.r === 0) valid = true;
            else if (side === 'S' && hex.r === mapData.rows - 1) valid = true;
            else if (side === 'W' && hex.q === 0) valid = true;
            else if (side === 'E' && hex.q === mapData.cols - 1) valid = true;
        } else {
            if (uData.side === 'blue' && hex.setupZone === 'blue') valid = true;
            if (uData.side === 'red' && hex.setupZone === 'red') valid = true;
        }
    }

    if (!valid) {
        addToLog(`Invalid Deployment Location.`, "log-combat"); return;
    }

    const regInfo = UNIT_DATA_REGISTRY[uData.type] || {};
    const stats = regInfo.stats || {};
    
    const maxMp = stats.Movement_Points !== undefined ? stats.Movement_Points : 6;
    const fp = stats.Firepower !== undefined ? stats.Firepower : 3;
    const rng = stats.Range_Hexes !== undefined ? stats.Range_Hexes : 6;

    const newUnit = {
        id: unitIdCounter++,
        side: uData.side,
        type: uData.type,
        category: uData.category || regInfo.category || 'squad',
        name: uData.name || regInfo.name,
        quality: uData.quality || 'regular',
        q: hex.q, r: hex.r,
        facing: uData.facing !== undefined ? uData.facing : 0, 
        status: 'clear', 
        stance: 'deployed', 
        hasActed: false,    
        hasMovedThisTurn: false,
        hasFiredThisTurn: false,
        memory: {},         
        mp: maxMp, maxMp: maxMp, hp: 5, fp: fp, range: rng, isFixed: false
    };

    units.push(newUnit);
    
    if(currentPhase === 'SETUP') setupTrayUnits = setupTrayUnits.filter(t => t !== uData);
    else reinforcementUnits = reinforcementUnits.filter(t => t !== uData);
    
    selectedTrayItem = null;
    isDeploying = false;
    selectUnitInStack(newUnit);
    displayMap(); 
    updateDynamicList(); 
    uiUpdate();
    addToLog(`${newUnit.name} deployed at [${newUnit.q},${newUnit.r}].`);
    checkControl(newUnit);
}

// --- TURN & PHASE CONTROL ---
function startGameMode(mode) {
    document.getElementById('mode-modal').style.display = 'none';
    currentPhase = 'SETUP';
    document.getElementById('phase-display').innerText = 'SETUP';
    document.getElementById('btn-phase').innerText = 'Finish Setup';
    currentListMode = 'tray';
    
    let initRule = 'blue';
    if (scenarioData && scenarioData.rules && scenarioData.rules.initiative) initRule = scenarioData.rules.initiative;
    resolveInitiative(initRule);
    
    isDeploying = true; 
    updateDynamicList();
    displayMap(); 
}

function nextPhase() {
    if (currentPhase === 'SETUP') {
        if (activeSide === initiativeWinner) {
            const otherSide = (initiativeWinner === 'blue') ? 'red' : 'blue';
            addToLog(`${activeSide.toUpperCase()} Setup Complete. Switching to ${otherSide.toUpperCase()}.`, "log-info");
            switchSideTo(otherSide);
            return; 
        } 
        else {
             currentPhase = 'Action Phase';
             document.getElementById('btn-phase').innerText = "End Turn";
             isDeploying = false; 
             checkInitialControl(); 
             units.forEach(u => runActiveSpotting(u));
             switchSideTo(initiativeWinner);
             displayMap();
             addToLog("=== MATCH START ===", "log-turn");
             toggleListMode('reinforcements');
        }
    } 
    else {
        const otherSide = (activeSide === 'blue') ? 'red' : 'blue';
        activeSide = otherSide;
        if (activeSide === initiativeWinner) currentTurn++;

        if(currentTurn > scenarioData.info.maxTurns) {
            let win = (scores.blue > scores.red) ? 'blue' : (scores.red > scores.blue ? 'red' : 'draw');
            endGame(win, "Turn Limit Reached"); return;
        }

        document.getElementById('turn-counter').innerText = currentTurn;
        
        units.filter(u => u.side === activeSide).forEach(u => {
            u.mp = u.maxMp;
            u.hasActed = false;
            u.hasFiredThisTurn = false;
            u.stance = 'deployed';
            u.hasMovedThisTurn = false; 
        });

        units.filter(u => u.side === activeSide).forEach(u => runActiveSpotting(u));
        switchSideTo(activeSide);
        addToLog(`Turn ${currentTurn}: ${activeSide.toUpperCase()} Active.`, "log-turn");
    }
    document.getElementById('phase-display').innerText = currentPhase;
    updateDynamicList(); 
    uiUpdate();
}

// --- UTILITY & MODAL FUNCTIONS ---
function toggleMapLoader() { 
    const el = document.getElementById('json-modal'); 
    el.style.display = (el.style.display === 'block') ? 'none' : 'block'; 
}

function loadScenario() {
    let txt = document.getElementById('json-input').value;
    txt = txt.replace(/[\n\r\t]+/g, ' ').replace(/\u00A0/g, ' ').trim();
    try {
        scenarioData = JSON.parse(txt);
        mapData = scenarioData.map; 
        units = []; setupTrayUnits = []; reinforcementUnits = []; strikes = [];
        
        if (scenarioData.units.locked) {
            scenarioData.units.locked.forEach(u => {
                u.isFixed = true; 
                const info = UNIT_DATA_REGISTRY[u.type] || {};
                const stats = info.stats || {};
                u.category = u.category || info.category;
                u.name = u.name || info.name;
                u.maxMp = stats.Movement_Points || 6;
                u.mp = u.maxMp;
                u.fp = stats.Firepower || 3;
                u.range = stats.Range_Hexes || 6;
                u.hp = 5;
                u.facing = u.facing !== undefined ? u.facing : 0;
                u.hasFiredThisTurn = false;
                units.push(u);
            });
        }
        if (scenarioData.units.tray) {
            scenarioData.units.tray.forEach(u => {
                if (u.turn && parseInt(u.turn) > 0) reinforcementUnits.push(u); 
                else setupTrayUnits.push(u);
            });
        }
        
        document.getElementById('max-turns').innerText = scenarioData.info.maxTurns;
        toggleMapLoader();
        document.getElementById('mode-modal').style.display = 'flex'; 
    } catch (e) { alert('Invalid JSON Structure'); }
}

// --- RENDER & SELECTION LOOP ---
function handleLeftClick(pointer) {
    if(isSpottingQueueRunning) return;
    const hex = getHexAtPoint(pointer.worldX, pointer.worldY);
    if (!hex) { selectedUnit = null; selectedHex = null; uiUpdate(); return; }
    if (losTool) { handleLOSToolClick(hex); return; }

    if (selectedTrayItem) { deployTrayUnit(selectedTrayItem, hex); return; }

    if (currentAction === 'HASTY' && selectedUnit) { continueHastyMove(hex); return; }

    const hexUnits = units.filter(u => u.q === hex.q && u.r === hex.r && u.hp > 0);
    const visibleUnits = hexUnits.filter(u => u.side === activeSide || getUnitVisibility(u) === 2);

    if (currentAction && selectedUnit) {
        if (currentAction === 'FIRE') {
            const target = visibleUnits.find(u => u.side !== selectedUnit.side);
            if(target) executeFire(selectedUnit, target);
        } else if (currentAction === 'FACING') { changeFacing(selectedUnit, hex); } 
        else if (currentAction === 'TACTICAL') { executeTacticalMove(selectedUnit, hex); }
        return;
    }

    if (visibleUnits.length > 0) {
        const own = visibleUnits.find(u => u.side === activeSide);
        selectUnitInStack(own || visibleUnits[visibleUnits.length - 1]);
    } else {
        selectedUnit = null; selectedHex = hex; uiUpdate();
    }
}

function uiUpdate() { 
    selectionGraphics.clear(); 
    unitGraphics.clear(); 
    badgeGraphics.clear(); 
    scene.children.list.filter(c => c.name === 'badgeText').forEach(c => c.destroy()); 
    
    if (selectedUnit) drawFrontalArc(selectedUnit);
    else arcGraphics.clear();

    redrawAllUnits(); 
    if (selectedUnit) showUnitPanel(selectedUnit); 
    else if (selectedHex) showTerrainPanel(selectedHex); 
    else clearContextPanel(); 
}

function moveUnitTo(unit, hex) {
    if(unit.facing !== 'X') calculateFacing(unit, hex);
    unit.q = hex.q; unit.r = hex.r;
    reevaluateVisibility(unit); // STICKY MEMORY CHECK
    selectUnitInStack(unit);
    checkControl(unit);
}

// (Remaining engine functions like redrawAllUnits, getHexPosition, etc. go here)
// Make sure to close your script and body tags!
</script>
</body>
</html>

