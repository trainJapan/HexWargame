<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Wargame Engine v0.4 - UI Overhaul</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        :root {
            --bg-dark: #1e1e1e;
            --bg-panel: #2a2a2a;
            --accent: #d4a017; /* Dark Gold/Orange */
            --text-main: #e0e0e0;
            --text-dim: #a0a0a0;
            --border: #444;
        }

        body { 
            margin: 0; padding: 0; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-dark);
            color: var(--text-main);
            height: 100vh;
            display: grid;
            grid-template-columns: 260px 1fr 320px; /* The 3-Column Layout */
            overflow: hidden;
        }

        /* --- LEFT COLUMN: CONTROLS --- */
        #left-panel {
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            z-index: 10;
        }

        .panel-header {
            color: var(--accent);
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
            border-bottom: 2px solid var(--accent);
            padding-bottom: 5px;
        }

        .scenario-box {
            background: #333;
            border: 1px solid var(--border);
            padding: 10px;
            border-radius: 4px;
            font-size: 13px;
            min-height: 80px;
        }

        .turn-display {
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            background: #222;
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 4px;
        }

        .btn {
            background: #444;
            color: var(--text-main);
            border: 1px solid #555;
            padding: 10px;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
            transition: background 0.2s;
            text-align: center;
        }
        .btn:hover { background: #555; border-color: #777; }
        .btn-primary { background: #d4a017; color: #111; border: none; }
        .btn-primary:hover { background: #b88a10; }
        .btn.active { background: var(--accent); color: #000; }
        
        /* --- CENTER: MAP --- */
        #game-container {
            position: relative;
            overflow: hidden;
            background: #111;
        }
        
        /* --- RIGHT COLUMN: CONTEXT --- */
        #right-panel {
            background: var(--bg-panel);
            border-left: 1px solid var(--border);
            display: grid;
            grid-template-rows: auto 1fr 200px; /* Unit Card, Stats, Log */
            overflow: hidden;
            z-index: 10;
        }

        /* Unit Card Section */
        #unit-card {
            padding: 15px;
            background: #333;
            border-bottom: 1px solid var(--border);
            text-align: center;
            display: none; /* Hidden until unit selected */
        }
        
        .unit-portrait {
            width: 80px; height: 80px;
            background: #111;
            margin: 0 auto 10px auto;
            border: 2px solid var(--border);
            display: flex; align-items: center; justify-content: center;
            color: #555; font-size: 10px;
        }

        .unit-title { font-size: 16px; font-weight: bold; color: white; }
        .unit-subtitle { font-size: 12px; color: var(--accent); margin-bottom: 5px; }
        
        .status-badges { display: flex; gap: 5px; justify-content: center; margin-top: 5px; }
        .badge { font-size: 10px; padding: 2px 6px; border-radius: 3px; font-weight: bold; }
        .badge-clear { background: #2e7d32; color: white; }
        .badge-shaken { background: #c62828; color: white; }

        /* Stats Grid */
        #unit-stats {
            padding: 15px;
            overflow-y: auto;
            display: none;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            border-bottom: 1px solid #3a3a3a;
            padding: 4px 0;
            font-size: 13px;
        }
        .stat-label { color: var(--text-dim); }
        .stat-value { font-weight: bold; color: white; }

        /* Battle Log */
        #log-container {
            background: #111;
            border-top: 1px solid var(--accent);
            padding: 10px;
            font-family: 'Consolas', monospace;
            font-size: 11px;
            overflow-y: auto;
            color: #ccc;
        }
        .log-entry { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }
        .log-turn { color: var(--accent); font-weight: bold; margin-top: 8px; }
        .log-combat { color: #ff5555; }
        .log-info { color: #88ccff; }

        /* Overlays */
        #json-modal {
            position: absolute; top: 50px; left: 50px; width: 300px;
            background: #222; border: 2px solid var(--accent); padding: 15px;
            z-index: 2000; display: none;
        }
        
        /* Stack Selector List */
        .stack-list-item {
            padding: 8px;
            background: #444;
            margin-bottom: 2px;
            cursor: pointer;
            border: 1px solid transparent;
        }
        .stack-list-item:hover { border-color: var(--accent); }
    </style>
</head>
<body>

<div id="left-panel">
    <div class="panel-header">OPERATIONS</div>
    
    <div class="scenario-box">
        <strong style="color:white">Battle of the Ridge</strong><br>
        <span style="color:#aaa">Scenario: Default</span><br>
        <p style="margin:5px 0 0 0; color:#888; font-style:italic">Load map to initialize...</p>
    </div>

    <div class="turn-display">
        TURN: <span id="turn-counter">1</span> / 12<br>
        <span style="color: var(--accent); font-size:12px;">PHASE: ACTION</span>
    </div>

    <button class="btn btn-primary" onclick="nextPhase()">Next Phase >></button>
    
    <div class="panel-header" style="margin-top:10px">TOOLS</div>
    <button class="btn" id="btn-los" onclick="toggleLOSTool()">Line of Sight Tool</button>
    <button class="btn" onclick="toggleMapLoader()">Load Map JSON</button>
    
    <div class="panel-header" style="margin-top:10px">DEBUG UNITS</div>
    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px;">
        <button class="btn" style="font-size:10px" onclick="addUnit('blue', 'infantry')">+ UK Inf</button>
        <button class="btn" style="font-size:10px" onclick="addUnit('blue', 'vehicle')">+ UK Veh</button>
        <button class="btn" style="font-size:10px" onclick="addUnit('red', 'infantry')">+ DE Inf</button>
        <button class="btn" style="font-size:10px" onclick="addUnit('red', 'vehicle')">+ DE Veh</button>
    </div>
</div>

<div id="game-container">
    <div id="json-modal">
        <textarea id="json-input" rows="6" style="width:100%; background:#111; color:#fff; border:1px solid #444;" placeholder="Paste Map JSON..."></textarea>
        <button class="btn btn-primary" style="width:100%; margin-top:5px;" onclick="loadMap()">Load</button>
        <button class="btn" style="width:100%; margin-top:5px;" onclick="toggleMapLoader()">Close</button>
    </div>
</div>

<div id="right-panel">
    
    <div id="unit-card">
        <div class="unit-portrait" id="ctx-portrait">IMG</div>
        <div class="unit-title" id="ctx-name">No Selection</div>
        <div class="unit-subtitle" id="ctx-type">-</div>
        <div class="status-badges" id="ctx-badges">
            </div>
        
        <div id="unit-actions" style="margin-top:10px; display:grid; gap:5px;">
            <button class="btn" onclick="selectAction('TACTICAL')">Move (Tactical)</button>
            <button class="btn" onclick="selectAction('FAST')">Move (Fast)</button>
            <button class="btn" onclick="selectAction('FACING')">Change Facing</button>
            <button class="btn" style="border-color:#ff5555; color:#ff5555" onclick="selectAction('FIRE')">FIRE</button>
        </div>
    </div>

    <div id="unit-stats">
        <div class="panel-header" style="font-size:14px; border-width:1px;">UNIT STATISTICS</div>
        <div class="stat-row"><span class="stat-label">Quality:</span> <span class="stat-value" id="stat-qual">Regular</span></div>
        <div class="stat-row"><span class="stat-label">Morale:</span> <span class="stat-value" id="stat-mor">Steady</span></div>
        <div class="stat-row"><span class="stat-label">Command:</span> <span class="stat-value" id="stat-cmd">In Command</span></div>
        <div class="stat-row"><span class="stat-label">Action Points:</span> <span class="stat-value" id="stat-ap">Ready</span></div>
        <hr style="border:0; border-bottom:1px solid #333; margin: 5px 0;">
        <div class="stat-row"><span class="stat-label">Firepower:</span> <span class="stat-value" id="stat-fp">-</span></div>
        <div class="stat-row"><span class="stat-label">Range:</span> <span class="stat-value" id="stat-rng">-</span></div>
        <div class="stat-row"><span class="stat-label">Movement:</span> <span class="stat-value" id="stat-mp">-</span></div>
        <div class="stat-row"><span class="stat-label">Facing:</span> <span class="stat-value" id="stat-face">-</span></div>
        <div class="stat-row"><span class="stat-label">Hit Points:</span> <span class="stat-value" id="stat-hp">-</span></div>
    </div>
    
    <div id="stack-selector" style="display:none; padding:15px;">
        <div class="panel-header">SELECT UNIT</div>
        <div id="stack-list"></div>
    </div>

    <div id="log-container">
        <div class="log-entry">System initialized.</div>
        <div class="log-entry">Waiting for map data...</div>
    </div>
</div>

<script>
// --- Configuration & Constants ---
const TERRAIN_TYPES = {
    'clear':      { color: 0x98FB98, los: 'clear',     cost: 1,   terrainHeight: 0, infantryUsable: 0, vehicleUsable: 0 },
    'fields':     { color: 0xCCAA00, los: 'degrading', cost: 1,   terrainHeight: 1, infantryUsable: 0, vehicleUsable: 0 },
    'beach':      { color: 0xFFFF99, los: 'clear',     cost: 1,   terrainHeight: 0, infantryUsable: 0, vehicleUsable: 0 },
    'broken':     { color: 0x8B4513, los: 'degrading', cost: 2,   terrainHeight: 1, infantryUsable: 0, vehicleUsable: 0 },
    'orchard':    { color: 0x00FF00, los: 'degrading', cost: 2,   terrainHeight: 1, infantryUsable: 0, vehicleUsable: 0 },
    'rural':      { color: 0xFF9999, los: 'degrading', cost: 2,   terrainHeight: 1, infantryUsable: 0, vehicleUsable: 0 },
    'forest':     { color: 0x228B22, los: 'blocking',  cost: 3,   terrainHeight: 2, infantryUsable: 0, vehicleUsable: 0 },
    'urban':      { color: 0xCC0000, los: 'blocking',  cost: 3,   terrainHeight: 2, infantryUsable: 2, vehicleUsable: 0 },
    'industrial': { color: 0x808080, los: 'blocking',  cost: 3,   terrainHeight: 2, infantryUsable: 2, vehicleUsable: 0 },
    'water':      { color: 0x4169E1, los: 'clear',     cost: 999, terrainHeight: 0, infantryUsable: 0, vehicleUsable: 0 },
    'hill':       { color: 0x8B7355, los: 'degrading', cost: 2,   terrainHeight: 2, infantryUsable: 2, vehicleUsable: 2 }
};

const HEX_RADIUS = 40;

// Game State
let mapData = null;
let losTool = false;
let losStartHex = null;
let losUnitType = 'infantry';
let units = [];
let unitIdCounter = 0;
let currentTurn = 1;
let currentPhase = 'Action Phase';

// Interaction State
let selectedUnit = null; 
let currentAction = null; 

// Phaser Objects
let scene, hexGroup, roadGraphics, losGraphics, unitGraphics, unitTextGroup, hexMap = {};
let unitSprites = {};

// --- Phaser Config ---
const config = {
    type: Phaser.AUTO,
    parent: 'game-container',
    width: window.innerWidth - 580, // Adjust for left and right panels
    height: window.innerHeight,
    backgroundColor: '#1a1a1a',
    scene: { preload: preloadScene, create: createScene, update: updateScene }
};

const game = new Phaser.Game(config);

function preloadScene() {
    const baseURL = 'https://raw.githubusercontent.com/trainJapan/HexWargame/main/artwork/map/';
    for (const [key, value] of Object.entries(TERRAIN_TYPES)) {
        for (let i = 1; i <= 3; i++) { this.load.image(`${key}${i}`, `${baseURL}${key}${i}.png`); }
    }
    const counterURL = 'https://raw.githubusercontent.com/trainJapan/HexWargame/main/artwork/counters/';
    this.load.image('UK_Inf', `${counterURL}UK_Inf.png`);
    this.load.image('GER_Inf', `${counterURL}GER_Inf.png`);
    this.load.image('UK_Veh', `${counterURL}UK_Veh.png`);
    this.load.image('GER_Veh', `${counterURL}GER_Veh.png`);
    
    this.make.graphics({x:0,y:0,add:false}).fillStyle(0xffffff).fillRect(0,0,1,1).generateTexture('fallback', 1, 1);
}

function createScene() {
    scene = this;
    hexGroup = this.add.group();
    roadGraphics = this.add.graphics().setDepth(100);
    losGraphics = this.add.graphics().setDepth(500);
    unitGraphics = this.add.graphics().setDepth(600);
    unitTextGroup = this.add.group(); // For numbers/text on counters
    
    this.cameras.main.setBounds(-1000, -1000, 6000, 6000);
    this.input.mouse.disableContextMenu();
    
    this.input.on('wheel', (pointer, gameObjects, deltaX, deltaY) => {
        const zoom = scene.cameras.main.zoom - (deltaY * 0.001);
        scene.cameras.main.setZoom(Phaser.Math.Clamp(zoom, 0.3, 2));
    });
    
    this.input.on('pointerdown', (pointer) => {
        if (pointer.leftButtonDown()) handleLeftClick(pointer);
        if (pointer.rightButtonDown()) {
            if (currentAction) {
                currentAction = null;
                selectedUnit = null;
                unitGraphics.clear();
                redrawAllUnits();
                updateContextPanel(null);
                addToLog("Action cancelled.", "log-info");
            }
        }
    });
}

function updateScene() {
    if (this.input.activePointer.rightButtonDown()) {
        const pointer = this.input.activePointer;
        this.cameras.main.scrollX -= (pointer.x - pointer.prevPosition.x) / this.cameras.main.zoom;
        this.cameras.main.scrollY -= (pointer.y - pointer.prevPosition.y) / this.cameras.main.zoom;
    }
}

// --- UI & Logging System ---

function addToLog(msg, cssClass = "") {
    const container = document.getElementById('log-container');
    const entry = document.createElement('div');
    entry.className = `log-entry ${cssClass}`;
    entry.innerText = msg;
    container.appendChild(entry);
    container.scrollTop = container.scrollHeight;
}

function toggleMapLoader() {
    const el = document.getElementById('json-modal');
    el.style.display = (el.style.display === 'block') ? 'none' : 'block';
}

function nextPhase() {
    addToLog(`Ending ${currentPhase}...`, "log-turn");
    // Placeholder logic for phase switching
    currentPhase = (currentPhase === 'Action Phase') ? 'Fire Phase' : 'Action Phase';
    if(currentPhase === 'Action Phase') {
        currentTurn++;
        document.getElementById('turn-counter').innerText = currentTurn;
        addToLog(`Turn ${currentTurn} Started.`, "log-turn");
    }
}

function updateContextPanel(unit) {
    const card = document.getElementById('unit-card');
    const stats = document.getElementById('unit-stats');
    const stackSel = document.getElementById('stack-selector');
    
    // Hide Stack Selector when showing unit details
    stackSel.style.display = 'none';

    if (!unit) {
        card.style.display = 'none';
        stats.style.display = 'none';
        return;
    }

    card.style.display = 'block';
    stats.style.display = 'block';

    // Update Header
    const side = unit.side === 'blue' ? 'UK' : 'German';
    document.getElementById('ctx-name').innerText = `${side} ${unit.unitType}`;
    document.getElementById('ctx-type').innerText = `${unit.unitType.toUpperCase()} PLATOON`;
    
    // Update Badges
    const badgeContainer = document.getElementById('ctx-badges');
    badgeContainer.innerHTML = '';
    
    // 1. Status Badge
    const statusBadge = document.createElement('span');
    statusBadge.className = unit.status === 'shaken' ? 'badge badge-shaken' : 'badge badge-clear';
    statusBadge.innerText = unit.status === 'shaken' ? 'SHAKEN' : 'CLEAR';
    badgeContainer.appendChild(statusBadge);

    // 2. Damage Badge if hurt
    if (unit.hp < 5) {
        const dmgBadge = document.createElement('span');
        dmgBadge.className = 'badge badge-shaken';
        dmgBadge.innerText = `DMG -${5 - unit.hp}`;
        badgeContainer.appendChild(dmgBadge);
    }

    // Update Stats (Placeholders)
    document.getElementById('stat-mp').innerText = `${unit.mp}/${unit.maxMp}`;
    document.getElementById('stat-hp').innerText = `${unit.hp}/5`;
    document.getElementById('stat-fp').innerText = unit.fp;
    document.getElementById('stat-rng').innerText = unit.range;
    
    // Convert facing index to direction name
    const facingNames = ["N", "NE", "SE", "S", "SW", "NW"];
    document.getElementById('stat-face').innerText = facingNames[unit.facing];
}

function showStackSelector(hexUnits) {
    const card = document.getElementById('unit-card');
    const stats = document.getElementById('unit-stats');
    const stackSel = document.getElementById('stack-selector');
    
    card.style.display = 'none';
    stats.style.display = 'none';
    stackSel.style.display = 'block';
    
    const list = document.getElementById('stack-list');
    list.innerHTML = '';
    
    hexUnits.forEach(u => {
        const div = document.createElement('div');
        div.className = 'stack-list-item';
        div.innerText = `${u.side.toUpperCase()} ${u.unitType} (HP:${u.hp})`;
        div.onclick = () => {
            selectedUnit = u;
            redrawAllUnits();
            updateContextPanel(u);
        };
        list.appendChild(div);
    });
}

// --- Interaction Logic (Updated for Stacking) ---

function handleLeftClick(pointer) {
    const hex = getHexAtPoint(pointer.worldX, pointer.worldY);
    if (!hex) return;

    if (losTool) {
        handleLOSToolClick(hex);
        return;
    }

    // Identify units in this hex
    const hexUnits = units.filter(u => u.q === hex.q && u.r === hex.r && u.hp > 0);

    // Case 1: performing an action (Moving/Firing)
    if (currentAction && selectedUnit) {
        if (currentAction === 'FIRE') {
            const target = hexUnits.find(u => u.side !== selectedUnit.side);
            // If stacking: technically we should let user pick target, but for now auto-pick first enemy
            executeFire(selectedUnit, target);
        } else if (currentAction === 'FACING') {
            changeFacing(selectedUnit, hex);
        } else {
            executeMove(selectedUnit, hex);
        }
        return;
    }

    // Case 2: Selecting a unit
    if (hexUnits.length > 1) {
        // Stack detected! Show selector in right panel
        showStackSelector(hexUnits);
    } else if (hexUnits.length === 1) {
        // Single unit, select immediately
        selectedUnit = hexUnits[0];
        redrawAllUnits();
        updateContextPanel(selectedUnit);
    } else {
        // Empty hex
        selectedUnit = null;
        redrawAllUnits();
        updateContextPanel(null);
    }
}

// --- Rendering (Updated for Stacking & Status) ---

function redrawAllUnits() {
    unitGraphics.clear();
    unitTextGroup.clear(true, true);
    
    // Destroy sprites
    Object.values(unitSprites).forEach(sprite => sprite.destroy());
    unitSprites = {};
    
    // Logic: Group by hex
    const stacks = {};
    units.forEach(u => {
        if(u.hp <= 0) return;
        const key = `${u.q},${u.r}`;
        if(!stacks[key]) stacks[key] = [];
        stacks[key].push(u);
    });

    for (const key in stacks) {
        const stack = stacks[key];
        // Draw the top unit (last one added)
        const topUnit = stack[stack.length - 1]; 
        const pos = getHexPosition(topUnit.q, topUnit.r);

        // 1. Draw Sprite
        let counterKey = '';
        if (topUnit.side === 'blue' && topUnit.unitType === 'infantry') counterKey = 'UK_Inf';
        else if (topUnit.side === 'blue' && topUnit.unitType === 'vehicle') counterKey = 'UK_Veh';
        else if (topUnit.side === 'red' && topUnit.unitType === 'infantry') counterKey = 'GER_Inf';
        else if (topUnit.side === 'red' && topUnit.unitType === 'vehicle') counterKey = 'GER_Veh';
        
        if (scene.textures.exists(counterKey)) {
            const sprite = scene.add.image(pos.x, pos.y, counterKey);
            sprite.setDisplaySize(HEX_RADIUS * 1.25, HEX_RADIUS * 1.25);
            sprite.setDepth(600);
            unitSprites[topUnit.id] = sprite;
        }

        // 2. Selection Ring (if ANY unit in stack is selected)
        const isSelected = stack.includes(selectedUnit);
        if (isSelected) {
            unitGraphics.lineStyle(3, 0xffcc00, 1);
            unitGraphics.strokeCircle(pos.x, pos.y, HEX_RADIUS * 0.7);
        }

        // 3. Facing Triangle (Only for Top Unit)
        drawFacingIndicator(topUnit, pos);

        // 4. Stacking Badge
        if (stack.length > 1) {
            const badgeX = pos.x - 15;
            const badgeY = pos.y - 15;
            unitGraphics.fillStyle(0xffffff, 1);
            unitGraphics.fillRect(badgeX, badgeY, 14, 14);
            unitGraphics.lineStyle(1, 0x000000, 1);
            unitGraphics.strokeRect(badgeX, badgeY, 14, 14);
            
            const text = scene.add.text(badgeX + 7, badgeY + 7, `+${stack.length-1}`, { 
                font: '10px Arial', fill: '#000', fontStyle:'bold'
            }).setOrigin(0.5).setDepth(610);
            unitTextGroup.add(text);
        }

        // 5. Status / Damage Markers (on Top Unit)
        drawStatusMarkers(topUnit, pos);
    }
}

function drawFacingIndicator(unit, pos) {
    const facingAngles = [-90, -30, 30, 90, 150, -150];
    const angleRad = Phaser.Math.DegToRad(facingAngles[unit.facing]);
    const indicatorDist = HEX_RADIUS * 0.75; 
    const triX = pos.x + Math.cos(angleRad) * indicatorDist;
    const triY = pos.y + Math.sin(angleRad) * indicatorDist;

    unitGraphics.fillStyle(0x8B0000, 1);
    const size = 8;
    unitGraphics.beginPath();
    unitGraphics.moveTo(triX + Math.cos(angleRad)*size, triY + Math.sin(angleRad)*size);
    unitGraphics.lineTo(triX + Math.cos(angleRad+2.5)*size, triY + Math.sin(angleRad+2.5)*size);
    unitGraphics.lineTo(triX + Math.cos(angleRad-2.5)*size, triY + Math.sin(angleRad-2.5)*size);
    unitGraphics.closePath();
    unitGraphics.fillPath();
}

function drawStatusMarkers(unit, pos) {
    // Damage Box (Red square bottom right)
    const damage = 5 - unit.hp;
    if (damage > 0) {
        const badgeX = pos.x + 15;
        const badgeY = pos.y + 15;
        unitGraphics.fillStyle(0xcc0000, 1);
        unitGraphics.fillRect(badgeX - 8, badgeY - 8, 16, 16);
        unitGraphics.lineStyle(1, 0xffffff, 1);
        unitGraphics.strokeRect(badgeX - 8, badgeY - 8, 16, 16);
        
        const text = scene.add.text(badgeX, badgeY, damage.toString(), { 
            font: '11px Arial', fill: '#fff', fontStyle: 'bold'
        }).setOrigin(0.5).setDepth(610);
        unitTextGroup.add(text);
    }
    
    // Shaken Marker (Yellow box top right - Code Drawn)
    if (unit.status === 'shaken') {
        const markerX = pos.x + 15;
        const markerY = pos.y - 15;
        
        unitGraphics.fillStyle(0xffff00, 0.9);
        unitGraphics.fillRect(markerX - 10, markerY - 6, 20, 12);
        unitGraphics.lineStyle(1, 0x000000, 1);
        unitGraphics.strokeRect(markerX - 10, markerY - 6, 20, 12);

        const txt = scene.add.text(markerX, markerY, "SHKN", {
            font:'9px Arial', fill:'#000', fontStyle:'bold'
        }).setOrigin(0.5).setDepth(610);
        unitTextGroup.add(txt);
    }
}

// --- Action Logic ---

function selectAction(action) {
    currentAction = action;
    if (action === 'FIRE') {
        addToLog(`Select target for ${selectedUnit.unitType}...`, "log-info");
    } else if (action === 'FACING') { 
        addToLog(`Click adjacent hex to face...`, "log-info");
    } else {
        addToLog(`Select move destination...`, "log-info");
    }
}

function changeFacing(unit, targetHex) {
    if (unit.q === targetHex.q && unit.r === targetHex.r) return;
    const startPos = getHexPosition(unit.q, unit.r);
    const targetPos = getHexPosition(targetHex.q, targetHex.r);
    const angleRad = Phaser.Math.Angle.Between(startPos.x, startPos.y, targetPos.x, targetPos.y);
    let angleDeg = Phaser.Math.RadToDeg(angleRad);
    
    const idealAngles = [ -90, -30, 30, 90, 150, -150 ];
    let closestIndex = 0; let minDiff = 360;
    idealAngles.forEach((ideal, index) => {
        let diff = Math.abs(Phaser.Math.Angle.WrapDegrees(angleDeg - ideal));
        if (diff < minDiff) { minDiff = diff; closestIndex = index; }
    });

    unit.facing = closestIndex;
    redrawAllUnits();
    updateContextPanel(unit); 
    addToLog(`${unit.unitType} facing changed to ${["N","NE","SE","S","SW","NW"][closestIndex]}`);
    currentAction = null;
}

function executeMove(unit, targetHex) {
    const dist = getHexDistance({q: unit.q, r: unit.r}, targetHex);
    if (dist !== 1) { addToLog("Too far! Must be adjacent.", "log-combat"); return; }
    
    const terrainCost = TERRAIN_TYPES[targetHex.terrain].cost;
    
    if (currentAction === 'TACTICAL') {
        if (terrainCost >= 999) { addToLog("Impassable terrain.", "log-combat"); return; }
        unit.mp = 0;
        moveUnitTo(unit, targetHex);
    } else if (currentAction === 'FAST') {
        if (unit.mp < terrainCost) { addToLog("Not enough MP.", "log-combat"); return; }
        unit.mp -= terrainCost;
        moveUnitTo(unit, targetHex);
    }
    currentAction = null;
}

function moveUnitTo(unit, hex) {
    unit.q = hex.q;
    unit.r = hex.r;
    redrawAllUnits();
    addToLog(`${unit.unitType} moved to ${hex.q},${hex.r}`);
}

function executeFire(attacker, targetUnit) {
    if (!targetUnit || attacker.side === targetUnit.side) return;
    
    const startHex = hexMap[attacker.q][attacker.r];
    const targetHex = hexMap[targetUnit.q][targetUnit.r];
    const physicalRange = getPhysicalRange(startHex, targetHex);
    
    if (physicalRange > attacker.range) { 
        addToLog("Target out of range!", "log-combat"); 
        currentAction = null; 
        return; 
    }
    
    const los = calculateLOS(startHex, targetHex, attacker.unitType);
    if (los.status === 'blocked') { 
        addToLog("LOS Blocked.", "log-combat"); 
        drawVisualLOSLine(startHex, targetHex, 0xff0000);
        setTimeout(() => losGraphics.clear(), 1000);
        currentAction = null;
        return;
    }
    
    // Damage Calc
    let damage = attacker.fp;
    let color = 0x00ff00;
    
    // LOS Modifier
    if (los.status === 'degraded') {
        damage -= 1;
        addToLog("LOS Degraded (-1 Dmg)", "log-info");
        color = 0xffaa00;
    }
    
    // Facing Modifier
    const sector = getTargetSector(attacker, targetUnit);
    if (sector === 'REAR') {
        damage += 2;
        addToLog("Rear Shot! (+2 Dmg)", "log-combat");
        color = 0xff0000;
    } else {
        addToLog("Frontal Shot", "log-info");
    }

    damage = Math.max(0, damage);
    targetUnit.hp -= damage;
    
    drawVisualLOSLine(startHex, targetHex, color);
    addToLog(`${attacker.unitType} hits ${targetUnit.unitType} for ${damage} dmg.`, "log-combat");
    
    if (targetUnit.hp <= 0) {
        addToLog(`${targetUnit.unitType} Destroyed!`, "log-combat");
        if (unitSprites[targetUnit.id]) unitSprites[targetUnit.id].destroy();
        units = units.filter(u => u.id !== targetUnit.id);
        selectedUnit = null;
        updateContextPanel(null);
    } else {
        updateContextPanel(targetUnit);
    }
    
    setTimeout(() => losGraphics.clear(), 1000);
    redrawAllUnits();
    currentAction = null;
}

function getTargetSector(attacker, target) {
    const targetPos = getHexPosition(target.q, target.r);
    const attackerPos = getHexPosition(attacker.q, attacker.r);
    const angleRad = Phaser.Math.Angle.Between(targetPos.x, targetPos.y, attackerPos.x, attackerPos.y);
    const angleDeg = Phaser.Math.RadToDeg(angleRad);
    
    const idealAngles = [ -90, -30, 30, 90, 150, -150 ];
    let attackDirIndex = 0; let minDiff = 360;
    idealAngles.forEach((ideal, index) => {
        let diff = Math.abs(Phaser.Math.Angle.WrapDegrees(angleDeg - ideal));
        if (diff < minDiff) { minDiff = diff; attackDirIndex = index; }
    });

    let diff = Math.abs(target.facing - attackDirIndex);
    if (diff > 3) diff = 6 - diff;
    return diff <= 1 ? 'FRONT' : 'REAR';
}

function drawVisualLOSLine(start, end, color) {
    losGraphics.clear();
    losGraphics.lineStyle(4, color, 0.8);
    losGraphics.beginPath();
    losGraphics.moveTo(start.x, start.y);
    losGraphics.lineTo(end.x, end.y);
    losGraphics.strokePath();
}

// --- Coordinates & Geometry (Standard) ---
function getHexPosition(q, r) {
    const x = q * HEX_RADIUS * 1.5;
    const y = r * HEX_RADIUS * Math.sqrt(3) + (q % 2 === 1 ? HEX_RADIUS * Math.sqrt(3) / 2 : 0);
    return { x, y };
}
function offsetToCube(q, r) {
    const col = q; const row = r; const x = col; const z = row - (col - (col & 1)) / 2; const y = -x - z;
    return { x, y, z };
}
function getHexDistance(h1, h2) {
    const a = offsetToCube(h1.q, h1.r); const b = offsetToCube(h2.q, h2.r);
    return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y), Math.abs(a.z - b.z));
}
function getHexAtPoint(worldX, worldY) {
    if (!mapData) return null;
    let closestHex = null; let closestDist = Infinity;
    for (let q = 0; q < mapData.cols; q++) {
        for (let r = 0; r < mapData.rows; r++) {
            const hex = hexMap[q][r];
            const dist = Math.sqrt((hex.x - worldX) ** 2 + (hex.y - worldY) ** 2);
            if (dist < HEX_RADIUS && dist < closestDist) { closestDist = dist; closestHex = hex; }
        }
    }
    return closestHex;
}

// --- LOS Calculations (With Road Fix & Hill Fix) ---
function calculateLOS(startHex, targetHex, unitType = 'infantry') {
    // 1. STANDARD LOS Calculation
    const fromTerrain = TERRAIN_TYPES[startHex.terrain];
    const fromUsableHeight = unitType === 'vehicle' ? fromTerrain.vehicleUsable : fromTerrain.infantryUsable;
    
    const dx = targetHex.x - startHex.x;
    const dy = targetHex.y - startHex.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const steps = Math.ceil(distance / 2); 
    
    const hexesCrossed = new Set();
    const edgeSegments = [];
    let edgeRunLength = 0; let edgeHexPair = null;
    
    for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const x = startHex.x + dx * t;
        const y = startHex.y + dy * t;
        const currentHex = getHexAtPoint(x, y);
        if (!currentHex) continue;
        if ((currentHex.q === startHex.q && currentHex.r === startHex.r) || 
            (currentHex.q === targetHex.q && currentHex.r === targetHex.r)) continue;
        
        const perpDx = -dy / distance; const perpDy = dx / distance;
        const hex1 = getHexAtPoint(x + perpDx * 3, y + perpDy * 3);
        const hex2 = getHexAtPoint(x - perpDx * 3, y - perpDy * 3);
        
        if (hex1 && hex2 && (hex1.q !== hex2.q || hex1.r !== hex2.r)) {
            const pairKey = [`${hex1.q},${hex1.r}`, `${hex2.q},${hex2.r}`].sort().join('|');
            if (edgeHexPair === pairKey) edgeRunLength++;
            else { if (edgeRunLength > 5) edgeSegments.push(edgeHexPair); edgeHexPair = pairKey; edgeRunLength = 1; }
        } else {
            if (edgeRunLength > 5) edgeSegments.push(edgeHexPair);
            edgeRunLength = 0; edgeHexPair = null;
            hexesCrossed.add(`${currentHex.q},${currentHex.r}`);
        }
    }
    if (edgeRunLength > 5) edgeSegments.push(edgeHexPair);
    
    let degradingCount = 0; let hasBlocking = false;
    
    // Check Terrain Obstacles
    for (let key of hexesCrossed) {
        const [q, r] = key.split(',').map(Number);
        const terrain = TERRAIN_TYPES[hexMap[q][r].terrain];
        const terrainHeight = terrain.terrainHeight;
        let losEffect = terrain.los;
        
        if (terrainHeight < fromUsableHeight) {
            if (losEffect === 'blocking') losEffect = 'degrading';
            else if (losEffect === 'degrading') losEffect = 'clear';
        }
        if (losEffect === 'blocking') hasBlocking = true;
        else if (losEffect === 'degrading') degradingCount++;
    }
    
    // Check Edge Obstacles
    for (let edgePair of edgeSegments) {
        if (!edgePair) continue;
        const [k1, k2] = edgePair.split('|');
        const [q1, r1] = k1.split(',').map(Number);
        const [q2, r2] = k2.split(',').map(Number);
        
        const t1 = TERRAIN_TYPES[hexMap[q1][r1].terrain];
        const t2 = TERRAIN_TYPES[hexMap[q2][r2].terrain];
        let l1 = t1.los; let l2 = t2.los;
        
        if (t1.terrainHeight < fromUsableHeight) l1 = (l1==='blocking'?'degrading':(l1==='degrading'?'clear':l1));
        if (t2.terrainHeight < fromUsableHeight) l2 = (l2==='blocking'?'degrading':(l2==='degrading'?'clear':l2));
        
        if (l1 === 'blocking' && l2 === 'blocking') hasBlocking = true;
        else if (l1 === 'blocking' || l2 === 'blocking') degradingCount++;
        else if (l1 === 'degrading' && l2 === 'degrading') degradingCount++;
    }
    
    let standardStatus = 'clear';
    if (hasBlocking || degradingCount >= 2) standardStatus = 'blocked';
    else if (degradingCount === 1) standardStatus = 'degraded';

    // 2. ROAD LOS Calculation
    const hexesOnLine = getHexesAlongLine(startHex, targetHex);
    const roadLOSResult = checkRoadLOS(startHex, targetHex, hexesOnLine);
    
    if (roadLOSResult.isRoad) {
        const dist = getHexDistance(startHex, targetHex);
        let roadStatus = 'blocked';
        if (dist <= 5) roadStatus = 'clear';
        else if (dist <= 10) roadStatus = 'degraded';
        
        const rank = { 'clear': 3, 'degraded': 2, 'blocked': 1 };
        if (rank[roadStatus] > rank[standardStatus]) return { status: roadStatus, isRoad: true };
    }
    return { status: standardStatus, isRoad: false };
}
function getHexesAlongLine(startHex, targetHex) {
    const hexes = []; const dx = targetHex.x - startHex.x; const dy = targetHex.y - startHex.y;
    const dist = Math.sqrt(dx*dx + dy*dy); const steps = Math.ceil(dist / 10);
    for(let i=0; i<=steps; i++) {
        const t = i/steps; const h = getHexAtPoint(startHex.x + dx*t, startHex.y + dy*t);
        if(h && !hexes.includes(h)) hexes.push(h);
    }
    return hexes;
}
function checkRoadLOS(startHex, targetHex, hexesOnLine) {
    if (!mapData || !mapData.roads) return { isRoad: false };
    if (!startHex.hasRoad || !targetHex.hasRoad) return { isRoad: false };
    const roadPath = findRoadPath(startHex, targetHex);
    if (!roadPath || roadPath.length < 2) return { isRoad: false };
    
    const idealDx = targetHex.x - startHex.x; const idealDy = targetHex.y - startHex.y;
    const idealLen = Math.sqrt(idealDx*idealDx + idealDy*idealDy);
    
    for (let i = 0; i < roadPath.length - 1; i++) {
        const c = roadPath[i]; const n = roadPath[i+1];
        const sdx = n.x - c.x; const sdy = n.y - c.y; const slen = Math.sqrt(sdx*sdx + sdy*sdy);
        const dot = (idealDx/idealLen) * (sdx/slen) + (idealDy/idealLen) * (sdy/slen);
        if (dot < 0.96) return { isRoad: false }; 
    }
    for (let h of hexesOnLine) {
        if (!roadPath.find(rh => rh.q === h.q && rh.r === h.r)) return { isRoad: false };
    }
    return { isRoad: true };
}
function findRoadPath(start, target) {
    const visited = new Set(); const queue = [[start]];
    while(queue.length > 0) {
        const path = queue.shift(); const curr = path[path.length-1];
        if(curr.q === target.q && curr.r === target.r) return path;
        const key = `${curr.q},${curr.r}`;
        if(visited.has(key)) continue; visited.add(key);
        mapData.roads.forEach(r => {
            let next = null;
            if(r.from.q === curr.q && r.from.r === curr.r) next = hexMap[r.to.q][r.to.r];
            else if(r.to.q === curr.q && r.to.r === curr.r) next = hexMap[r.from.q][r.from.r];
            if(next) queue.push([...path, next]);
        });
    }
    return null;
}

// --- Tools ---

function handleLOSToolClick(hex) {
    if (!losStartHex) {
        losStartHex = hex;
        highlightHex(hex, 0xffffff);
        addToLog("Select target hex for LOS...", "log-info");
    } else {
        const result = calculateLOS(losStartHex, hex, losUnitType);
        let color = 0xff0000;
        let txt = "BLOCKED";
        if(result.status === 'clear') { color = 0x00ff00; txt = "CLEAR"; }
        if(result.status === 'degraded') { color = 0xffaa00; txt = "DEGRADED"; }
        
        drawVisualLOSLine(losStartHex, hex, color);
        addToLog(`LOS Result: ${txt} ${result.isRoad ? '(Road)' : ''}`);
        losStartHex = null;
    }
}

function toggleLOSTool() {
    losTool = !losTool;
    losStartHex = null;
    losGraphics.clear();
    document.getElementById('btn-los').classList.toggle('active', losTool);
    addToLog(losTool ? "LOS Tool Active." : "LOS Tool Deactivated.", "log-info");
}

function highlightHex(hex, color) {
    losGraphics.clear();
    losGraphics.lineStyle(4, color);
    losGraphics.strokeCircle(hex.x, hex.y, HEX_RADIUS - 5);
}

function loadMap() {
    const jsonText = document.getElementById('json-input').value;
    try {
        mapData = JSON.parse(jsonText);
        displayMap();
        toggleMapLoader();
        addToLog(`Map Loaded: ${mapData.cols}x${mapData.rows}`);
    } catch (e) { alert('Invalid JSON'); }
}

function displayMap() {
    if (!mapData) return;
    hexGroup.clear(true, true); roadGraphics.clear(); hexMap = {};
    for (let q = 0; q < mapData.cols; q++) {
        hexMap[q] = {};
        for (let r = 0; r < mapData.rows; r++) {
            const pos = getHexPosition(q, r);
            hexMap[q][r] = { terrain: 'clear', x: pos.x, y: pos.y, q: q, r: r, hasRoad: false, variant: null };
        }
    }
    if (mapData.terrain) mapData.terrain.forEach(t => { if (hexMap[t.q] && hexMap[t.q][t.r]) hexMap[t.q][t.r].terrain = t.type; });
    if (mapData.roads) mapData.roads.forEach(road => {
        if (hexMap[road.from.q]) hexMap[road.from.q][road.from.r].hasRoad = true;
        if (hexMap[road.to.q]) hexMap[road.to.q][road.to.r].hasRoad = true;
    });
    for (let q = 0; q < mapData.cols; q++) { for (let r = 0; r < mapData.rows; r++) { drawHex(hexMap[q][r]); } }
    drawRoads(); redrawAllUnits();
}

function drawHex(hex) {
    const terrainType = hex.terrain;
    const x = hex.x; const y = hex.y;
    if (!hex.variant) hex.variant = Phaser.Math.Between(1, 3);
    const textureKey = `${terrainType}${hex.variant}`;
    
    if (scene.textures.exists(textureKey)) {
        const img = scene.add.image(x, y, textureKey).setDisplaySize(HEX_RADIUS * 2, HEX_RADIUS * 2);
        const shape = scene.make.graphics().fillStyle(0xffffff).beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i;
            const hx = x + HEX_RADIUS * Math.cos(angle); const hy = y + HEX_RADIUS * Math.sin(angle);
            if (i === 0) shape.moveTo(hx, hy); else shape.lineTo(hx, hy);
        }
        shape.closePath().fillPath();
        img.setMask(shape.createGeometryMask());
        hexGroup.add(img);
        
        const outline = scene.add.graphics().lineStyle(2, 0x333333).beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i;
            const hx = x + HEX_RADIUS * Math.cos(angle); const hy = y + HEX_RADIUS * Math.sin(angle);
            if (i === 0) outline.moveTo(hx, hy); else outline.lineTo(hx, hy);
        }
        outline.closePath().strokePath();
        hexGroup.add(outline);
    } else {
        const g = scene.add.graphics().fillStyle(TERRAIN_TYPES[terrainType].color).lineStyle(2, 0x333333).beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i;
            const hx = x + HEX_RADIUS * Math.cos(angle); const hy = y + HEX_RADIUS * Math.sin(angle);
            if (i === 0) g.moveTo(hx, hy); else g.lineTo(hx, hy);
        }
        g.closePath().fillPath().strokePath();
        hexGroup.add(g);
    }
}

function drawRoads() {
    if (!mapData || !mapData.roads) return;
    roadGraphics.lineStyle(6, 0x555555, 0.8);
    mapData.roads.forEach(seg => {
        const h1 = hexMap[seg.from.q][seg.from.r]; const h2 = hexMap[seg.to.q][seg.to.r];
        if (h1 && h2) roadGraphics.beginPath().moveTo(h1.x, h1.y).lineTo(h2.x, h2.y).strokePath();
    });
    // (Simplified edge road drawing omitted for brevity, lines connect centers)
}

function addUnit(side, unitType) {
    if (!mapData) return;
    // Basic finding logic to place unit in center
    let q = Math.floor(mapData.cols / 2); let r = Math.floor(mapData.rows / 2);
    const unit = {
        id: unitIdCounter++, side: side, unitType: unitType,
        q: q, r: r, facing: 0, status: 'clear',
        mp: 6, maxMp: 6, hp: 5, fp: 3, range: 6
    };
    units.push(unit);
    redrawAllUnits();
}
</script>
</body>
</html>
