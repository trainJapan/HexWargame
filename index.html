<!DOCTYPE html>
<html lang="en">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <title>Wargame Engine v0.9.22 - UI Info Security & FOW Opacity</title>
Â  Â  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
Â  Â  <style>
Â  Â  Â  Â  :root {
Â  Â  Â  Â  Â  Â  --bg-dark: #1e1e1e;
Â  Â  Â  Â  Â  Â  --bg-panel: #2a2a2a;
Â  Â  Â  Â  Â  Â  --accent: #d4a017;
Â  Â  Â  Â  Â  Â  --text-main: #e0e0e0;
Â  Â  Â  Â  Â  Â  --text-dim: #a0a0a0;
Â  Â  Â  Â  Â  Â  --border: #444;
Â  Â  Â  Â  Â  Â  --blue-team: #4488ff;
Â  Â  Â  Â  Â  Â  --red-team: #ff4444;
Â  Â  Â  Â  }

Â  Â  Â  Â  body {Â 
Â  Â  Â  Â  Â  Â  margin: 0; padding: 0;Â 
Â  Â  Â  Â  Â  Â  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
Â  Â  Â  Â  Â  Â  background: var(--bg-dark);
Â  Â  Â  Â  Â  Â  color: var(--text-main);
Â  Â  Â  Â  Â  Â  height: 100vh;
Â  Â  Â  Â  Â  Â  display: grid;
Â  Â  Â  Â  Â  Â  grid-template-columns: 260px 1fr 320px;
Â  Â  Â  Â  Â  Â  overflow: hidden;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* --- LEFT PANEL --- */
Â  Â  Â  Â  #left-panel {
Â  Â  Â  Â  Â  Â  background: var(--bg-panel);
Â  Â  Â  Â  Â  Â  border-right: 1px solid var(--border);
Â  Â  Â  Â  Â  Â  padding: 15px;
Â  Â  Â  Â  Â  Â  display: flex; flex-direction: column; gap: 10px;
Â  Â  Â  Â  Â  Â  overflow-y: auto; z-index: 10;
Â  Â  Â  Â  }

Â  Â  Â  Â  .command-header {
Â  Â  Â  Â  Â  Â  padding: 10px; text-align: center; font-weight: bold; font-size: 16px;
Â  Â  Â  Â  Â  Â  border-radius: 4px; border: 2px solid transparent; cursor: default;
Â  Â  Â  Â  Â  Â  text-transform: uppercase; box-shadow: 0 4px 6px rgba(0,0,0,0.3);
Â  Â  Â  Â  Â  Â  transition: all 0.2s;
Â  Â  Â  Â  }
Â  Â  Â  Â  .cmd-blue { background: #223355; color: var(--blue-team); border-color: var(--blue-team); }
Â  Â  Â  Â  .cmd-red { background: #552222; color: var(--red-team); border-color: var(--red-team); }

Â  Â  Â  Â  .panel-header {
Â  Â  Â  Â  Â  Â  color: var(--accent); font-size: 18px; font-weight: bold;
Â  Â  Â  Â  Â  Â  margin-bottom: 5px; border-bottom: 2px solid var(--accent); padding-bottom: 5px;
Â  Â  Â  Â  }
Â  Â  Â  Â  .scenario-box {
Â  Â  Â  Â  Â  Â  background: #333; border: 1px solid var(--border); padding: 10px;
Â  Â  Â  Â  Â  Â  border-radius: 4px; font-size: 13px; min-height: 60px;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  .score-box {
Â  Â  Â  Â  Â  Â  display: grid; grid-template-columns: 1fr 1fr; gap: 5px;
Â  Â  Â  Â  Â  Â  background: #222; padding: 8px; border-radius: 4px; border: 1px solid #444; margin-bottom: 5px;
Â  Â  Â  Â  }
Â  Â  Â  Â  .score-team { text-align: center; font-weight: bold; font-size: 14px; }
Â  Â  Â  Â  .score-val { font-size: 18px; font-family: monospace; text-align: center; }
Â  Â  Â  Â  .bar-container { grid-column: span 2; height: 6px; background: #444; margin-top: 5px; position: relative; border-radius:3px; overflow:hidden; }
Â  Â  Â  Â  .bar-fill { height: 100%; background: var(--blue-team); width: 50%; transition: width 0.5s; }

Â  Â  Â  Â  .turn-display {
Â  Â  Â  Â  Â  Â  text-align: center; font-size: 14px; font-weight: bold;
Â  Â  Â  Â  Â  Â  background: #222; padding: 8px;
Â  Â  Â  Â  Â  Â  border: 1px solid var(--border); border-radius: 4px;
Â  Â  Â  Â  }

Â  Â  Â  Â  .menu-btn-group { display: flex; flex-direction: column; gap: 5px; }
Â  Â  Â  Â Â 
Â  Â  Â  Â  .btn {
Â  Â  Â  Â  Â  Â  background: #444; color: var(--text-main); border: 1px solid #555;
Â  Â  Â  Â  Â  Â  padding: 10px; cursor: pointer; border-radius: 4px;
Â  Â  Â  Â  Â  Â  font-weight: bold; transition: background 0.2s; text-align: center;
Â  Â  Â  Â  }
Â  Â  Â  Â  .btn:hover { background: #555; border-color: #777; }
Â  Â  Â  Â  .btn-primary { background: #d4a017; color: #111; border: none; }
Â  Â  Â  Â  .btn-primary:hover { background: #b88a10; }
Â  Â  Â  Â  .btn.active { background: var(--accent); color: #000; border-color: var(--accent); }
Â  Â  Â  Â  .btn:disabled { opacity: 0.5; cursor: not-allowed; }

Â  Â  Â  Â  .list-item {
Â  Â  Â  Â  Â  Â  display: flex; align-items: center; gap: 10px;
Â  Â  Â  Â  Â  Â  background: #222; border: 1px solid #444;
Â  Â  Â  Â  Â  Â  padding: 5px; margin-bottom: 5px; cursor: pointer;
Â  Â  Â  Â  Â  Â  border-left: 3px solid transparent;
Â  Â  Â  Â  Â  Â  position: relative;
Â  Â  Â  Â  }
Â  Â  Â  Â  .list-item:hover { background: #333; border-color: #666; }
Â  Â  Â  Â  .list-item.selected { border-color: var(--accent); background: #332200; }
Â  Â  Â  Â  .list-item.arrival { border-left-color: #00ff00; }
Â  Â  Â  Â  .list-icon { width: 32px; height: 32px; object-fit: contain; }
Â  Â  Â  Â  .list-info { flex-grow: 1; }
Â  Â  Â  Â  .list-title { font-weight:bold; font-size:12px; color:#fff; }
Â  Â  Â  Â  .list-meta { font-size:10px; color:#aaa; }
Â  Â  Â  Â  .list-stars { color: #ffd700; font-size: 10px; margin-left: 5px; }
Â  Â  Â  Â Â 
Â  Â  Â  Â  .reinf-rotate-box { display: flex; align-items: center; gap: 6px; margin-top: 4px; }
Â  Â  Â  Â  .btn-rotate-mini { padding: 2px 6px; font-size: 10px; background: #555; border: 1px solid #777; color: #fff; cursor: pointer; border-radius: 3px; }
Â  Â  Â  Â  .btn-rotate-mini:hover { background: #777; }
Â  Â  Â  Â  .facing-label-mini { font-size: 10px; color: var(--accent); font-weight: bold; }

Â  Â  Â  Â  #dice-overlay {
Â  Â  Â  Â  Â  Â  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
Â  Â  Â  Â  Â  Â  background: rgba(0,0,0,0.6);Â 
Â  Â  Â  Â  Â  Â  display: none; flex-direction: column; align-items: center; justify-content: center; gap: 20px;
Â  Â  Â  Â  Â  Â  z-index: 2000;
Â  Â  Â  Â  }
Â  Â  Â  Â  .d10-container { width: 180px; height: 180px; position: relative; filter: drop-shadow(0 15px 15px rgba(0,0,0,0.6)); }
Â  Â  Â  Â  .dice-shaking { animation: shake 0.1s infinite; }
Â  Â  Â  Â  .d10-val {
Â  Â  Â  Â  Â  Â  position: absolute; top: 38%; left: 50%; transform: translate(-50%, -50%);
Â  Â  Â  Â  Â  Â  font-size: 56px; font-weight: bold; color: white;
Â  Â  Â  Â  Â  Â  text-shadow: 2px 2px 4px black; font-family: 'Arial', sans-serif; pointer-events: none;
Â  Â  Â  Â  }
Â  Â  Â  Â  .dice-label {
Â  Â  Â  Â  Â  Â  background: #111; color: var(--accent); padding: 10px 30px;
Â  Â  Â  Â  Â  Â  border-radius: 4px; font-weight: bold; font-size: 18px;
Â  Â  Â  Â  Â  Â  text-transform: uppercase; border: 1px solid var(--accent);
Â  Â  Â  Â  Â  Â  box-shadow: 0 0 15px rgba(0,0,0,0.8);
Â  Â  Â  Â  }
Â  Â  Â  Â  #dice-expl {
Â  Â  Â  Â  Â  Â  color: #ccc; font-style: italic; font-size: 14px;
Â  Â  Â  Â  Â  Â  max-width: 300px; text-align: center;
Â  Â  Â  Â  Â  Â  background: rgba(0,0,0,0.8); padding: 8px; border-radius: 4px; border: 1px solid #555;
Â  Â  Â  Â  Â  Â  margin-top: -10px; margin-bottom: 10px;
Â  Â  Â  Â  }
Â  Â  Â  Â  .dice-btn {
Â  Â  Â  Â  Â  Â  background: var(--blue-team); color: white; border: none;
Â  Â  Â  Â  Â  Â  padding: 10px 40px; font-size: 16px; font-weight: bold;
Â  Â  Â  Â  Â  Â  border-radius: 4px; cursor: pointer; display: none;
Â  Â  Â  Â  Â  Â  box-shadow: 0 0 10px rgba(68, 136, 255, 0.5);
Â  Â  Â  Â  }
Â  Â  Â  Â  @keyframes shake { 0% { transform: rotate(0deg); } 25% { transform: rotate(5deg); } 50% { transform: rotate(-5deg); } 75% { transform: rotate(5deg); } 100% { transform: rotate(0deg); } }

Â  Â  Â  Â  .modal-overlay {
Â  Â  Â  Â  Â  Â  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
Â  Â  Â  Â  Â  Â  background: rgba(0,0,0,0.85); z-index: 3000; display: none;
Â  Â  Â  Â  Â  Â  flex-direction: column; align-items: center; justify-content: center;
Â  Â  Â  Â  }
Â  Â  Â  Â  .modal-card {
Â  Â  Â  Â  Â  Â  background: #222; border: 2px solid var(--accent); padding: 30px;
Â  Â  Â  Â  Â  Â  text-align: center; max-width: 400px; width: 80%;
Â  Â  Â  Â  Â  Â  box-shadow: 0 0 50px rgba(0,0,0,0.8);
Â  Â  Â  Â  }
Â  Â  Â  Â  .mode-btn { width: 100%; margin-top: 10px; padding: 15px; font-size: 16px; }

Â  Â  Â  Â  .tool-sub-options { display: flex; gap: 5px; margin-top: 5px; }
Â  Â  Â  Â  .btn-small { padding: 5px; font-size: 11px; flex: 1; }

Â  Â  Â  Â  #game-container { position: relative; overflow: hidden; background: #111; }

Â  Â  Â  Â  #right-panel {
Â  Â  Â  Â  Â  Â  background: var(--bg-panel); border-left: 1px solid var(--border);
Â  Â  Â  Â  Â  Â  display: grid; grid-template-rows: auto 1fr 200px; overflow: hidden; z-index: 10;
Â  Â  Â  Â  }
Â  Â  Â  Â  #context-card { padding: 15px; background: #333; border-bottom: 1px solid var(--border); text-align: center; min-height: 140px; }
Â  Â  Â  Â  .ctx-header-row { display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 5px; }
Â  Â  Â  Â  .ctx-portrait { width: 80px; height: 80px; display: flex; align-items: center; justify-content: center; background: #222; border-radius: 4px; border: 1px solid #444; }
Â  Â  Â  Â  .ctx-portrait img { width: 100%; height: 100%; object-fit: contain; }
Â  Â  Â  Â  .ctx-side-info { width: 60px; font-size: 10px; font-weight: bold; text-align: center; padding: 4px; border-radius: 4px; background: #222; display: flex; align-items: center; justify-content: center; min-height: 24px; border: 1px solid #444; }
Â  Â  Â  Â  .ctx-title { font-size: 16px; font-weight: bold; color: white; }
Â  Â  Â  Â  .ctx-subtitle { font-size: 12px; color: var(--accent); margin-bottom: 5px; }
Â  Â  Â  Â  .status-badges { display: flex; gap: 5px; justify-content: center; margin-top: 5px; flex-wrap: wrap; }
Â  Â  Â  Â  .badge { font-size: 10px; padding: 3px 8px; border-radius: 3px; font-weight: bold; cursor: default; }
Â  Â  Â  Â  .badge-terrain { cursor: pointer; border: 1px solid rgba(255,255,255,0.2); }
Â  Â  Â  Â  .badge-vp { background: #000; color: #FFD700; border: 1px solid #FFD700; }
Â  Â  Â  Â  #context-stats { padding: 15px; overflow-y: auto; }
Â  Â  Â  Â  .stat-row { display: flex; justify-content: space-between; border-bottom: 1px solid #3a3a3a; padding: 4px 0; font-size: 13px; }
Â  Â  Â  Â  .stat-label { color: var(--text-dim); }
Â  Â  Â  Â  .stat-value { font-weight: bold; color: white; }

Â  Â  Â  Â  #stack-list { display: flex; flex-direction: column; gap: 5px; margin-top: 10px; }
Â  Â  Â  Â  .stack-item { cursor: pointer; border: 1px solid #444; border-radius: 4px; background: #222; padding: 5px; display: flex; align-items: center; gap: 10px; }
Â  Â  Â  Â  .stack-item:hover { border-color: var(--accent); background: #333; }
Â  Â  Â  Â  .stack-img { width: 40px; height: 40px; object-fit: contain; }
Â  Â  Â  Â  .stack-info { flex-grow: 1; font-size: 11px; text-align: left; }
Â  Â  Â  Â  .stack-name { font-weight:bold; color:white; }

Â  Â  Â  Â  /* SPENT UNIT TEXT COLOR - UI UPDATE */
Â  Â  Â  Â  .stack-item.spent .stack-name {
Â  Â  Â  Â  Â  Â  color: #ff4444 !important;
Â  Â  Â  Â  }

Â  Â  Â  Â  #log-container { background: #111; border-top: 1px solid var(--accent); padding: 10px; font-family: 'Consolas', monospace; font-size: 11px; overflow-y: auto; color: #ccc; }
Â  Â  Â  Â  .log-entry { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }
Â  Â  Â  Â  .log-turn { color: var(--accent); font-weight: bold; margin-top: 8px; }
Â  Â  Â  Â  .log-combat { color: #ff5555; }
Â  Â  Â  Â  .log-info { color: #88ccff; }
Â  Â  Â  Â  .log-capture { color: #ffff00; }

Â  Â  Â  Â  #json-modal { position: absolute; top: 50px; left: 50px; width: 300px; background: #222; border: 2px solid var(--accent); padding: 15px; z-index: 2000; display: none; }
Â  Â  </style>
</head>
<body>

<div id="left-panel">
Â  Â  <div id="command-header" class="command-header cmd-blue">
Â  Â  Â  Â  UK COMMAND (BLUE)
Â  Â  </div>

Â  Â  <div class="panel-header">SCENARIO</div>
Â  Â  <div class="scenario-box" id="scenario-info-box">
Â  Â  Â  Â  <strong style="color:white">Wargame Engine</strong><br>
Â  Â  Â  Â  <span style="color:#aaa">No Scenario Loaded</span><br>
Â  Â  Â  Â  <p style="margin:5px 0 0 0; color:#888; font-style:italic">Load JSON to start...</p>
Â  Â  </div>

Â  Â  <div class="score-box">
Â  Â  Â  Â  <div class="score-team" style="color:var(--blue-team)">UK</div>
Â  Â  Â  Â  <div class="score-team" style="color:var(--red-team)">GER</div>
Â  Â  Â  Â  <div class="score-val" style="color:var(--blue-team)" id="score-blue">0</div>
Â  Â  Â  Â  <div class="score-val" style="color:var(--red-team)" id="score-red">0</div>
Â  Â  Â  Â  <div class="bar-container">
Â  Â  Â  Â  Â  Â  <div class="bar-fill" id="score-bar"></div>
Â  Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <div class="turn-display">
Â  Â  Â  Â  TURN: <span id="turn-counter">1</span> / <span id="max-turns">-</span><br>
Â  Â  Â  Â  <span style="color: var(--accent); font-size:12px;" id="phase-display">SETUP</span>
Â  Â  </div>

Â  Â  <div class="menu-btn-group">
Â  Â  Â  Â  <button class="btn" onclick="toggleListMode('reinforcements')" id="btn-reinf">REINFORCEMENTS</button>
Â  Â  Â  Â  <button class="btn" onclick="toggleListMode('strikes')" id="btn-strikes">OFF-BOARD STRIKES</button>
Â  Â  Â  Â  <button class="btn btn-primary" id="btn-phase" onclick="nextPhase()">Finish Setup</button>
Â  Â  </div>
Â  Â Â 
Â  Â  <div id="dynamic-list-area" style="flex-grow:1; overflow-y:auto; margin-top:10px;"></div>
Â  Â Â 
Â  Â  <div class="panel-header" style="margin-top:10px">TOOLS</div>
Â  Â  <div>
Â  Â  Â  Â  <button class="btn" id="btn-los" style="width:100%" onclick="toggleLOSTool()">Line of Sight Tool</button>
Â  Â  Â  Â  <div id="los-options" class="tool-sub-options" style="display:none;">
Â  Â  Â  Â  Â  Â  <button id="los-inf" class="btn btn-small active" onclick="setLOSType('infantry')">Infantry Height</button>
Â  Â  Â  Â  Â  Â  <button id="los-veh" class="btn btn-small" onclick="setLOSType('vehicle')">Vehicle Height</button>
Â  Â  Â  Â  </div>
Â  Â  </div>
Â  Â  <button class="btn" onclick="toggleMapLoader()">Load Scenario JSON</button>
</div>

<div id="game-container">
Â  Â  <div id="json-modal">
Â  Â  Â  Â  <textarea id="json-input" rows="6" style="width:100%; background:#111; color:#fff; border:1px solid #444;" placeholder="Paste Scenario JSON..."></textarea>
Â  Â  Â  Â  <button class="btn btn-primary" style="width:100%; margin-top:5px;" onclick="loadScenario()">Load</button>
Â  Â  Â  Â  <button class="btn" style="width:100%; margin-top:5px;" onclick="toggleMapLoader()">Close</button>
Â  Â  </div>

Â  Â  <div id="mode-modal" class="modal-overlay">
Â  Â  Â  Â  <div class="modal-card">
Â  Â  Â  Â  Â  Â  <h2 style="color:var(--accent); margin-top:0">SELECT GAME MODE</h2>
Â  Â  Â  Â  Â  Â  <button class="mode-btn btn btn-primary" onclick="startGameMode('hotseat')">HOTSEAT (2 Player)</button>
Â  Â  Â  Â  Â  Â  <button class="mode-btn btn" disabled style="opacity:0.5; cursor:not-allowed">PLAYER VS AI (Coming Soon)</button>
Â  Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <div id="dice-overlay">
Â  Â  Â  Â  <div class="dice-label" id="dice-label">Rolling...</div>
Â  Â  Â  Â  <div class="d10-container" id="dice-anim">
Â  Â  Â  Â  Â  Â  <svg width="180" height="180" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
Â  Â  Â  Â  Â  Â  Â  Â  <defs>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <linearGradient id="diceGrad" x1="0%" y1="0%" x2="100%" y2="100%">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <stop offset="0%" style="stop-color:#ffaa00;stop-opacity:1" />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <stop offset="100%" style="stop-color:#cc4400;stop-opacity:1" />
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </linearGradient>
Â  Â  Â  Â  Â  Â  Â  Â  </defs>
Â  Â  Â  Â  Â  Â  Â  Â  <path d="M50 2 L95 38 L78 88 L22 88 L5 38 Z" fill="url(#diceGrad)" stroke="#fff" stroke-width="2" stroke-linejoin="round"/>
Â  Â  Â  Â  Â  Â  Â  Â  <path d="M50 2 L80 38 L50 65 L20 38 Z" fill="none" stroke="#fff" stroke-width="2" stroke-linejoin="round"/>
Â  Â  Â  Â  Â  Â  Â  Â  <path d="M5 38 L20 38" stroke="#fff" stroke-width="2"/> <path d="M95 38 L80 38" stroke="#fff" stroke-width="2"/> <path d="M22 88 L50 65" stroke="#fff" stroke-width="2"/>
Â  Â  Â  Â  Â  Â  Â  Â  <path d="M78 88 L50 65" stroke="#fff" stroke-width="2"/>
Â  Â  Â  Â  Â  Â  </svg>
Â  Â  Â  Â  Â  Â  <div class="d10-val" id="dice-val">0</div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div id="dice-expl"></div>
Â  Â  Â  Â  <button class="dice-btn" id="dice-ok-btn">CONTINUE</button>
Â  Â  </div>

Â  Â  <div id="game-over-modal" class="modal-overlay">
Â  Â  Â  Â  <div class="modal-card">
Â  Â  Â  Â  Â  Â  <div style="font-size:32px; font-weight:bold; margin-bottom:10px;" id="end-title">VICTORY</div>
Â  Â  Â  Â  Â  Â  <div style="color:#aaa; margin-bottom:20px; font-style:italic;" id="end-reason">Turns Limit Reached</div>
Â  Â  Â  Â  Â  Â  <div style="margin-bottom:20px; font-size:18px;">
Â  Â  Â  Â  Â  Â  Â  Â  <span style="color:var(--blue-team)">UK: <span id="end-blue">0</span></span> &nbsp;|&nbsp;Â 
Â  Â  Â  Â  Â  Â  Â  Â  <span style="color:var(--red-team)">GER: <span id="end-red">0</span></span>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  <button class="btn btn-primary" onclick="location.reload()">Return to Menu</button>
Â  Â  Â  Â  </div>
Â  Â  </div>
</div>

<div id="right-panel">
Â  Â  <div id="context-card">
Â  Â  Â  Â  <div class="ctx-header-row">
Â  Â  Â  Â  Â  Â  <div id="ctx-status-left" class="ctx-side-info" style="color:#aaa;">-</div>
Â  Â  Â  Â  Â  Â  <div class="ctx-portrait" id="ctx-img"></div>
Â  Â  Â  Â  Â  Â  <div id="ctx-stance-right" class="ctx-side-info" style="color:#aaa;">-</div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div id="ctx-quality" style="color:#ffd700; font-size:16px; margin-bottom:5px; line-height:1;"></div>
Â  Â  Â  Â  <div class="ctx-title" id="ctx-title">No Selection</div>
Â  Â  Â  Â  <div class="ctx-subtitle" id="ctx-subtitle">-</div>
Â  Â  Â  Â  <div class="status-badges" id="ctx-badges"></div>
Â  Â  Â  Â  <div id="unit-actions" style="margin-top:10px; display:none; gap:5px; grid-template-columns: 1fr 1fr;">
Â  Â  Â  Â  Â  Â  <button class="btn btn-game" style="padding:5px" onclick="selectAction('TACTICAL')">Tactical</button>
Â  Â  Â  Â  Â  Â  <button class="btn btn-game" style="padding:5px" onclick="startHastyMove()">Hasty</button>
Â  Â  Â  Â  Â  Â  <button class="btn btn-game" style="padding:5px" onclick="selectAction('FACING')">Face</button>
Â  Â  Â  Â  Â  Â  <button class="btn btn-game" style="padding:5px; border-color:#ff5555; color:#ff5555" onclick="selectAction('FIRE')">FIRE</button>
Â  Â  Â  Â  Â  Â  <button class="btn btn-setup" style="padding:5px; display:none" onclick="selectAction('FACING')">Rotate</button>
Â  Â  Â  Â  Â  Â  <button class="btn btn-setup" style="padding:5px; border-color:#ffaa00; color:#ffaa00; display:none" onclick="redeployUnit()">Redeploy</button>
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  <button class="btn btn-game" id="btn-finish-move" style="padding:5px; border-color:#d4a017; color:#d4a017; grid-column:span 2; display:none;" onclick="finishHastyMove()">FINISH MOVE</button>
Â  Â  Â  Â  </div>
Â  Â  </div>
Â  Â  <div id="context-stats">
Â  Â  Â  Â  <div class="panel-header" style="font-size:14px; border-width:1px;" id="stats-header">STATISTICS</div>
Â  Â  Â  Â  <div id="stats-content"></div>
Â  Â  Â  Â  <div id="stack-container" style="display:none; margin-top:15px;">
Â  Â  Â  Â  Â  Â  <div class="panel-header" style="font-size:14px; border-width:1px;">STACK (Top First)</div>
Â  Â  Â  Â  Â  Â  <div id="stack-list"></div>
Â  Â  Â  Â  </div>
Â  Â  </div>
Â  Â  <div id="log-container">
Â  Â  Â  Â  <div class="log-entry">System initialized.</div>
Â  Â  </div>
</div>

<script>
// --- Configuration ---
const ASSETS_URL = 'https://raw.githubusercontent.com/trainJapan/HexWargame/main/artwork/';
const FACING_DIRS = ["N","NE","SE","S","SW","NW"];

// --- DYNAMIC REGISTRIES ---
let UNIT_DATA_REGISTRY = {};
let TERRAIN_TYPES = {};

const HEX_RADIUS = 40;

// Game State
let scenarioData = null;Â 
let mapData = null;Â 
let losTool = false;
let losStartHex = null;
let losUnitType = 'infantry';
let units = [];
let activeSide = 'blue';Â 
let initiativeWinner = 'blue';

// Separate Data Lists
let setupTrayUnits = [];Â 
let reinforcementUnits = [];Â 
let strikes = [];Â  Â Â 

let unitIdCounter = 2000;
let currentTurn = 1;
let currentPhase = 'SETUP';Â 
let scores = { blue: 0, red: 0 };
let captureOwners = {};Â 
let currentListMode = 'tray';Â 

// Selection State
let selectedUnit = null;Â 
let selectedHex = null;Â 
let selectedTrayItem = null;Â 
let currentAction = null;Â 
let isDeploying = false;Â 

// Phaser Objects
let scene, hexGroup, zoneGraphics, objGraphics, roadGraphics, losGraphics, unitGraphics, selectionGraphics, badgeGraphics, hexMap = {};
let unitSprites = {};
let objectiveSprites = [];Â 
let diceCallback = null;Â 
let cursors;Â 

const config = {
Â  Â  type: Phaser.AUTO, parent: 'game-container',
Â  Â  width: window.innerWidth - 580, height: window.innerHeight,
Â  Â  backgroundColor: '#1a1a1a',
Â  Â  fps: {
Â  Â  Â  Â  target: 30,
Â  Â  Â  Â  forceSetTimeOut: true
Â  Â  },
Â  Â  scene: { preload: preloadScene, create: createScene, update: updateScene }
};

const game = new Phaser.Game(config);

function preloadScene() {
Â  Â  this.load.json('units_uk', 'units_UK.json');
Â  Â  this.load.json('units_ger', 'units_GER.json');
Â  Â  this.load.json('terrain_data', 'terrain.json');
Â  Â  this.make.graphics({x:0,y:0,add:false}).fillStyle(0xffffff).fillRect(0,0,1,1).generateTexture('fallback', 1, 1);
Â  Â Â 
Â  Â  // FOW Assets (Try to load, but we have procedural backup)
Â  Â  this.load.image('UK_FOW_Infantry', ASSETS_URL + 'counters/UK_FOW_Infantry.png');
Â  Â  this.load.image('GER_FOW_Infantry', ASSETS_URL + 'counters/GER_FOW_Infantry.png');
Â  Â  this.load.image('UK_FOW_Vehicle', ASSETS_URL + 'counters/UK_FOW_Vehicle.png');
Â  Â  this.load.image('GER_FOW_Vehicle', ASSETS_URL + 'counters/GER_FOW_Vehicle.png');
}

function createScene() {
Â  Â  scene = this;
Â  Â  cursors = this.input.keyboard.createCursorKeys();Â 
Â  Â Â 
Â  Â  // Procedural Fallback Textures for FOW (Safety Net)
Â  Â  createFOWTextures();

Â  Â  try {
Â  Â  Â  Â  const ukData = this.cache.json.get('units_uk') || {};
Â  Â  Â  Â  const gerData = this.cache.json.get('units_ger') || {};
Â  Â  Â  Â  const tData = this.cache.json.get('terrain_data') || {};
Â  Â  Â  Â  Object.entries(ukData).forEach(([key, data]) => { data.key = key; data.side = 'blue'; UNIT_DATA_REGISTRY[key] = data; });
Â  Â  Â  Â  Object.entries(gerData).forEach(([key, data]) => { data.key = key; data.side = 'red'; UNIT_DATA_REGISTRY[key] = data; });
Â  Â  Â  Â  Object.entries(tData).forEach(([key, data]) => {
Â  Â  Â  Â  Â  Â  TERRAIN_TYPES[key] = {
Â  Â  Â  Â  Â  Â  Â  Â  images: data.images || [],
Â  Â  Â  Â  Â  Â  Â  Â  color: 0x555555, los: (data.los_effect || 'clear').toLowerCase(), cost: data.movement_cost || 1,
Â  Â  Â  Â  Â  Â  Â  Â  terrainHeight: data.terrain_height || 0, infantryUsable: data.unit_height_infantry || 0, vehicleUsable: data.unit_height_vehicle || 0,
Â  Â  Â  Â  Â  Â  Â  Â  cover: data.cover_bonus || 0 // New property for Spotting
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  });
Â  Â  Â  Â  let loadCount = 0;
Â  Â  Â  Â  Object.values(UNIT_DATA_REGISTRY).forEach(u => { if(u.image) { this.load.image(u.key, ASSETS_URL + 'counters/' + u.image); loadCount++; } });
Â  Â  Â  Â  Object.values(TERRAIN_TYPES).forEach(t => { if(t.images) { t.images.forEach(img => { const k = img.replace(/\.[^/.]+$/, ""); this.load.image(k, ASSETS_URL + 'map/' + img); }); loadCount++; } });
Â  Â  Â  Â  if(loadCount > 0) { this.load.once('complete', () => { initEngine(); }); this.load.start(); } else { initEngine(); }
Â  Â  } catch(e) { console.error("Error parsing JSON:", e); alert("Failed to load JSONs."); }
}

function createFOWTextures() {
Â  Â  const types = ['UK_FOW_Infantry', 'GER_FOW_Infantry', 'UK_FOW_Vehicle', 'GER_FOW_Vehicle'];
Â  Â  types.forEach(key => {
Â  Â  Â  Â  // Only generate if texture missing (fallback) or force generic
Â  Â  Â  Â  if (!scene.textures.exists(key)) {
Â  Â  Â  Â  Â  Â  const g = scene.make.graphics({x:0,y:0,add:false});
Â  Â  Â  Â  Â  Â  g.fillStyle(0x444444);
Â  Â  Â  Â  Â  Â  g.fillRect(0,0,40,40);
Â  Â  Â  Â  Â  Â  g.lineStyle(2, 0xaaaaaa);
Â  Â  Â  Â  Â  Â  g.strokeRect(0,0,40,40);
Â  Â  Â  Â  Â  Â  g.generateTexture(key, 40, 40);
Â  Â  Â  Â  }
Â  Â  });
Â  Â  // Generic fallback
Â  Â  const g = scene.make.graphics({x:0,y:0,add:false});
Â  Â  g.fillStyle(0x333333); g.fillRect(0,0,40,40);
Â  Â  g.generateTexture('fow_generic', 40, 40);
}

function initEngine() {
Â  Â  hexGroup = scene.add.group();Â 
Â  Â  zoneGraphics = scene.add.graphics().setDepth(20);Â 
Â  Â  roadGraphics = scene.add.graphics().setDepth(100);
Â  Â  objGraphics = scene.add.graphics().setDepth(150);Â 
Â  Â  selectionGraphics = scene.add.graphics().setDepth(500);Â 
Â  Â  losGraphics = scene.add.graphics().setDepth(550);Â  Â  Â  Â Â 
Â  Â  unitGraphics = scene.add.graphics().setDepth(700);Â  Â  Â  Â 
Â  Â  badgeGraphics = scene.add.graphics().setDepth(800);Â  Â  Â 
Â  Â  scene.cameras.main.setBounds(-2000, -2000, 8000, 8000);Â 
Â  Â  scene.input.mouse.disableContextMenu();
Â  Â  scene.input.on('wheel', (pointer, gameObjects, deltaX, deltaY) => {
Â  Â  Â  Â  const zoom = scene.cameras.main.zoom - (deltaY * 0.001);
Â  Â  Â  Â  scene.cameras.main.setZoom(Phaser.Math.Clamp(zoom, 0.3, 2));
Â  Â  });
Â  Â  scene.input.on('pointerdown', (pointer) => {
Â  Â  Â  Â  if (pointer.leftButtonDown()) handleLeftClick(pointer);
Â  Â  Â  Â  if (pointer.rightButtonDown()) {
Â  Â  Â  Â  Â  Â  if (currentAction) { currentAction = null; uiUpdate(); addToLog("Action cancelled.", "log-info"); }
Â  Â  Â  Â  Â  Â  if (selectedTrayItem) {Â 
Â  Â  Â  Â  Â  Â  Â  Â  selectedTrayItem = null;Â 
Â  Â  Â  Â  Â  Â  Â  Â  isDeploying = false;Â 
Â  Â  Â  Â  Â  Â  Â  Â  displayMap();Â 
Â  Â  Â  Â  Â  Â  Â  Â  updateDynamicList();Â 
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  });
Â  Â Â 
Â  Â  document.getElementById('dice-ok-btn').addEventListener('click', closeDiceOverlay);
Â  Â  addToLog("System initialized (v0.9.22).");
}

function updateScene() {
Â  Â  if (this.input.activePointer.rightButtonDown()) {
Â  Â  Â  Â  const pointer = this.input.activePointer;
Â  Â  Â  Â  this.cameras.main.scrollX -= (pointer.x - pointer.prevPosition.x) / this.cameras.main.zoom;
Â  Â  Â  Â  this.cameras.main.scrollY -= (pointer.y - pointer.prevPosition.y) / this.cameras.main.zoom;
Â  Â  }
Â  Â  if (cursors) {
Â  Â  Â  Â  const cam = this.cameras.main;
Â  Â  Â  Â  const speed = 15 / cam.zoom;
Â  Â  Â  Â  if (cursors.left.isDown) cam.scrollX -= speed;
Â  Â  Â  Â  if (cursors.right.isDown) cam.scrollX += speed;
Â  Â  Â  Â  if (cursors.up.isDown) cam.scrollY -= speed;
Â  Â  Â  Â  if (cursors.down.isDown) cam.scrollY += speed;
Â  Â  }
}

// --- COMMAND VIEW LOGIC ---
function switchSideTo(side) {
Â  Â  activeSide = side;
Â  Â  const header = document.getElementById('command-header');
Â  Â Â 
Â  Â  // Clear selections
Â  Â  selectedUnit = null;
Â  Â  selectedHex = null;
Â  Â  selectedTrayItem = null;
Â  Â  isDeploying = false;
Â  Â  currentAction = null;

Â  Â  if (activeSide === 'blue') {
Â  Â  Â  Â  header.className = 'command-header cmd-blue';
Â  Â  Â  Â  header.innerText = 'UK COMMAND (BLUE)';
Â  Â  } else {
Â  Â  Â  Â  header.className = 'command-header cmd-red';
Â  Â  Â  Â  header.innerText = 'GER COMMAND (RED)';
Â  Â  }
Â  Â Â 
Â  Â  updateScenarioInfo();
Â  Â  updateDynamicList();
Â  Â  displayMap(); // Updates Fog of War
Â  Â  uiUpdate();
Â  Â  addToLog(`View switched to ${activeSide.toUpperCase()} Command.`);
}

function updateScenarioInfo() {
Â  Â  if(!scenarioData) return;
Â  Â  let briefing = "";
Â  Â  if (scenarioData.info.briefing && typeof scenarioData.info.briefing === 'object') {
Â  Â  Â  Â  briefing = scenarioData.info.briefing[activeSide] || "No Briefing.";
Â  Â  } else {
Â  Â  Â  Â  briefing = scenarioData.info.description || "No Briefing.";
Â  Â  }

Â  Â  document.getElementById('scenario-info-box').innerHTML = `
Â  Â  Â  Â  <strong style="color:white">${scenarioData.info.title}</strong><br>
Â  Â  Â  Â  <span style="color:#aaa">${scenarioData.info.author}</span><br>
Â  Â  Â  Â  <div style="margin:5px 0 0 0; font-size:11px; color:#ddd; background:#222; padding:4px; border:1px solid #444;">
Â  Â  Â  Â  Â  Â  <strong style="color:${activeSide==='blue'?'#4488ff':'#ff4444'}">BRIEFING:</strong> ${briefing}
Â  Â  Â  Â  </div>`;
}

function resolveInitiative(rule) {
Â  Â  if (rule === 'dice') {
Â  Â  Â  Â  const explanation = "1-5: UK (Blue) Starts<br>6-10: GER (Red) Starts";
Â  Â  Â  Â  rollD10("INITIATIVE", (val) => {
Â  Â  Â  Â  Â  Â  const winner = val <= 5 ? 'blue' : 'red';
Â  Â  Â  Â  Â  Â  initiativeWinner = winner;
Â  Â  Â  Â  Â  Â  const sideName = winner === 'blue' ? 'UK (Blue)' : 'GERMAN (Red)';
Â  Â  Â  Â  Â  Â  addToLog(`Initiative Roll: ${val}. ${sideName} starts setup!`, "log-turn");
Â  Â  Â  Â  Â  Â  switchSideTo(initiativeWinner);
Â  Â  Â  Â  }, explanation);
Â  Â  } else {
Â  Â  Â  Â  initiativeWinner = (rule === 'red') ? 'red' : 'blue';
Â  Â  Â  Â  const sideName = initiativeWinner === 'blue' ? 'UK (Blue)' : 'GERMAN (Red)';
Â  Â  Â  Â  addToLog(`${sideName} starts setup (Fixed Rule).`, "log-turn");
Â  Â  Â  Â  switchSideTo(initiativeWinner);
Â  Â  }
}

// --- D10 DICE SYSTEM ---
function rollD10(label, callback, explanation="") {
Â  Â  const overlay = document.getElementById('dice-overlay');
Â  Â  const container = document.getElementById('dice-anim');
Â  Â  const valDisplay = document.getElementById('dice-val');
Â  Â  const lbl = document.getElementById('dice-label');
Â  Â  const explDiv = document.getElementById('dice-expl');
Â  Â  const btn = document.getElementById('dice-ok-btn');
Â  Â Â 
Â  Â  overlay.style.display = 'flex';
Â  Â  btn.style.display = 'none';Â 
Â  Â  lbl.innerText = label || "ROLLING...";
Â  Â  explDiv.innerHTML = explanation;
Â  Â Â 
Â  Â  container.classList.add('dice-shaking');
Â  Â  diceCallback = callback;
Â  Â Â 
Â  Â  let result = 1;
Â  Â  const interval = setInterval(() => {
Â  Â  Â  Â  result = Phaser.Math.Between(1, 10);
Â  Â  Â  Â  valDisplay.innerText = result === 10 ? "0" : result;
Â  Â  }, 50);

Â  Â  setTimeout(() => {
Â  Â  Â  Â  clearInterval(interval);
Â  Â  Â  Â  result = Phaser.Math.Between(1, 10);
Â  Â  Â  Â  valDisplay.innerText = result === 10 ? "0" : result;
Â  Â  Â  Â  container.classList.remove('dice-shaking');
Â  Â  Â  Â  lbl.innerText = `RESULT: ${result === 10 ? "0 (10)" : result}`;
Â  Â  Â  Â  btn.style.display = 'block';Â 
Â  Â  Â  Â  diceCallback = () => { if(callback) callback(result); };
Â  Â  }, 800);
}

function closeDiceOverlay() {
Â  Â  document.getElementById('dice-overlay').style.display = 'none';
Â  Â  if(diceCallback) diceCallback();
Â  Â  diceCallback = null;
}

// --- SPOTTING ENGINE (UPDATED) ---
// Levels: 0=Hidden, 1=Intel (FOW), 2=Spotted (Visible)
function updateSpottingMemory(observer, target, level) {
Â  Â  if(!observer.memory) observer.memory = {};
Â  Â  const currentData = observer.memory[target.id] || { level: 0, turn: 0 };
Â  Â  const currentLevel = currentData.level;
Â  Â  
Â  Â  if (level > currentLevel) {
Â  Â  Â  Â  observer.memory[target.id] = { level: level, turn: currentTurn };
Â  Â  Â  Â  // Phase 0: Share Level 2 with same hex immediately
Â  Â  Â  Â  if (level === 2) {
Â  Â  Â  Â  Â  Â  units.filter(u => u.side === observer.side && u.q === observer.q && u.r === observer.r && u !== observer && u.hp > 0)
Â  Â  Â  Â  Â  Â  Â  Â  Â .forEach(friend => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if(!friend.memory) friend.memory = {};
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â const fCurrent = friend.memory[target.id] ? friend.memory[target.id].level : 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if(fCurrent < 2) friend.memory[target.id] = { level: 2, turn: currentTurn };
Â  Â  Â  Â  Â  Â  Â  Â  Â });
Â  Â  Â  Â  }
Â  Â  }
}

function calculateSpottingChance(observer, target) {
Â  Â  let chance = 5; // Base 50%
Â  Â  if (target.stance === 'moving') chance += 2;
Â  Â  if (target.stance === 'cover') chance -= 2;
Â  Â Â 
Â  Â  // Distance
Â  Â  const dist = getHexDistance({q:observer.q, r:observer.r}, {q:target.q, r:target.r});
Â  Â  chance -= Math.floor(dist / 2); // -1 per 2 hexes
Â  Â Â 
Â  Â  // Terrain Cover of Target
Â  Â  const terrain = TERRAIN_TYPES[hexMap[target.q][target.r].terrain];
Â  Â  if (terrain.cover) chance -= terrain.cover; // Forest/Town etc

Â  Â  return Phaser.Math.Clamp(chance, 1, 9);
}

function runActiveSpotting(observer) {
Â  Â  // Check Active vs All Unspotted Enemies
Â  Â  units.filter(u => u.side !== observer.side && u.hp > 0).forEach(target => {
Â  Â  Â  Â  // If already spotted, skip logic (keep spotted)
Â  Â  Â  Â  if (observer.memory && observer.memory[target.id] && observer.memory[target.id].level === 2) return;
Â  Â  Â  Â Â 
Â  Â  Â  Â  // LOS Check
Â  Â  Â  Â  const cat = observer.category || 'squad';
Â  Â  Â  Â  const height = (cat === 'vehicle' || cat === 'hwt') ? 'vehicle' : 'infantry';
Â  Â  Â  Â  const los = calculateLOS(hexMap[observer.q][observer.r], hexMap[target.q][target.r], height);
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (los.status !== 'blocked') {
Â  Â  Â  Â  Â  Â  const chance = calculateSpottingChance(observer, target);
Â  Â  Â  Â  Â  Â  const roll = Phaser.Math.Between(1, 10);
Â  Â  Â  Â  Â  Â  if (roll <= chance) {
Â  Â  Â  Â  Â  Â  Â  Â  updateSpottingMemory(observer, target, 2);
Â  Â  Â  Â  Â  Â  Â  Â  addToLog(`${observer.name} spotted ${target.name}!`, "log-info");
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  });
}

function runReactiveSpotting(movingUnit) {
Â  Â  // All Unspent Enemies check vs Moving Unit
Â  Â  units.filter(u => u.side !== movingUnit.side && u.hp > 0 && !u.hasActed).forEach(enemy => {
Â  Â  Â  Â  // If enemy already sees moving unit, skip
Â  Â  Â  Â  if (enemy.memory && enemy.memory[movingUnit.id] && enemy.memory[movingUnit.id].level === 2) return;
Â  Â  Â  Â Â 
Â  Â  Â  Â  const cat = enemy.category || 'squad';
Â  Â  Â  Â  const height = (cat === 'vehicle' || cat === 'hwt') ? 'vehicle' : 'infantry';
Â  Â  Â  Â  const los = calculateLOS(hexMap[enemy.q][enemy.r], hexMap[movingUnit.q][movingUnit.r], height);
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (los.status !== 'blocked') {
Â  Â  Â  Â  Â  Â  const chance = calculateSpottingChance(enemy, movingUnit);
Â  Â  Â  Â  Â  Â  const roll = Phaser.Math.Between(1, 10);
Â  Â  Â  Â  Â  Â  if (roll <= chance) {
Â  Â  Â  Â  Â  Â  Â  Â  updateSpottingMemory(enemy, movingUnit, 2);
Â  Â  Â  Â  Â  Â  Â  Â  addToLog(`${enemy.name} spotted moving ${movingUnit.name}!`, "log-combat");
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  });
}

// --- VICTORY SYSTEM ---
function checkInitialControl() {
Â  Â  units.forEach(u => { checkControl(u); });
}

function checkControl(unit) {
Â  Â  if(!unit || unit.hp <= 0) return;
Â  Â  const key = `${unit.q},${unit.r}`;
Â  Â  const hex = hexMap[unit.q][unit.r];
Â  Â  if(hex && hex.victoryPoints && captureOwners[key] !== unit.side) {
Â  Â  Â  Â  captureOwners[key] = unit.side;
Â  Â  Â  Â  addToLog(`${unit.side.toUpperCase()} captured VL at ${unit.q},${unit.r}!`, "log-capture");
Â  Â  Â  Â  updateScore();
Â  Â  }
}

function updateScore() {
Â  Â  scores.blue = 0; scores.red = 0;
Â  Â  for(const key in captureOwners) {
Â  Â  Â  Â  const [q,r] = key.split(',').map(Number);
Â  Â  Â  Â  const hex = hexMap[q][r];
Â  Â  Â  Â  if(hex && hex.victoryPoints) { scores[captureOwners[key]] += hex.victoryPoints; }
Â  Â  }
Â  Â  document.getElementById('score-blue').innerText = scores.blue;
Â  Â  document.getElementById('score-red').innerText = scores.red;
Â  Â  const total = scores.blue + scores.red;
Â  Â  if(total > 0) {
Â  Â  Â  Â  const pct = (scores.blue / total) * 100;
Â  Â  Â  Â  document.getElementById('score-bar').style.width = `${pct}%`;
Â  Â  } else { document.getElementById('score-bar').style.width = `50%`; }
Â  Â  if(currentPhase !== 'SETUP') displayMap();Â 
Â  Â  checkSuddenDeath();
}

function checkSuddenDeath() {
Â  Â  if(!scenarioData || !scenarioData.victory || !scenarioData.victory.thresholds) return;
Â  Â  const th = scenarioData.victory.thresholds;
Â  Â  const blueTh = parseInt(th.blue) || 0;
Â  Â  const redTh = parseInt(th.red) || 0;
Â  Â  const totalPossible = scenarioData.victory.locations.reduce((sum, loc) => sum + loc.points, 0);
Â  Â  if(totalPossible === 0) return;

Â  Â  if (blueTh > 0 && (scores.blue / totalPossible) * 100 >= blueTh) endGame('blue', 'Sudden Death Threshold Met!');
Â  Â  if (redTh > 0 && (scores.red / totalPossible) * 100 >= redTh) endGame('red', 'Sudden Death Threshold Met!');
}

function endGame(winner, reason) {
Â  Â  document.getElementById('game-over-modal').style.display = 'flex';
Â  Â  const title = document.getElementById('end-title');
Â  Â  title.innerText = (winner === 'blue' ? "UK / BLUE" : "GER / RED") + " VICTORIOUS";
Â  Â  title.className = "end-title " + (winner==='blue' ? 'winner-blue' : 'winner-red');
Â  Â  document.getElementById('end-title').style.color = winner==='blue' ? '#4488ff' : '#ff4444';
Â  Â  document.getElementById('end-reason').innerText = reason;
Â  Â  document.getElementById('end-blue').innerText = scores.blue;
Â  Â  document.getElementById('end-red').innerText = scores.red;
}

// --- LIST & TRAY SYSTEM ---
function toggleListMode(targetMode) {
Â  Â  if (currentListMode === targetMode) {
Â  Â  Â  Â  currentListMode = 'tray';
Â  Â  } else {
Â  Â  Â  Â  currentListMode = targetMode;
Â  Â  }
Â  Â  document.getElementById('btn-reinf').classList.toggle('active', currentListMode === 'reinforcements');
Â  Â  document.getElementById('btn-strikes').classList.toggle('active', currentListMode === 'strikes');
Â  Â  updateDynamicList();
}

function updateDynamicList() {
Â  Â  const container = document.getElementById('dynamic-list-area');
Â  Â  container.innerHTML = '';
Â  Â  let title = "";
Â  Â  let listData = [];
Â  Â Â 
Â  Â  // STRICT FILTER: Only show items for activeSide
Â  Â  if(currentPhase === 'SETUP' && currentListMode === 'tray') {
Â  Â  Â  Â  title = "SETUP TRAY";
Â  Â  Â  Â  listData = setupTrayUnits.filter(u => u.side === activeSide);
Â  Â  } else if (currentListMode === 'tray') {
Â  Â  Â  Â  title = "ACTIVE TRAY";Â 
Â  Â  Â  Â  listData = [];Â 
Â  Â  } else if(currentListMode === 'reinforcements') {
Â  Â  Â  Â  title = "REINFORCEMENTS";
Â  Â  Â  Â  listData = reinforcementUnits.filter(u => u.side === activeSide);Â 
Â  Â  } else if (currentListMode === 'strikes') {
Â  Â  Â  Â  title = "OFF-BOARD STRIKES";
Â  Â  Â  Â  listData = strikes.filter(u => u.side === activeSide);
Â  Â  }

Â  Â  container.innerHTML = `<div class="panel-header" style="font-size:14px; border-width:1px;">${title}</div>`;

Â  Â  if(listData.length === 0) {
Â  Â  Â  Â  container.innerHTML += '<div style="color:#666; font-style:italic; padding:10px;">Empty (or Hidden).</div>';
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  listData.forEach(item => {
Â  Â  Â  Â  const div = document.createElement('div');
Â  Â  Â  Â  div.className = 'list-item';
Â  Â  Â  Â  if(selectedTrayItem === item) div.classList.add('selected');
Â  Â  Â  Â Â 
Â  Â  Â  Â  // --- VISIBILITY & STATUS LOGIC ---
Â  Â  Â  Â  const uTurn = parseInt(item.turn) || 0;
Â  Â  Â  Â  const isSetup = (currentPhase === 'SETUP');
Â  Â  Â  Â Â 
Â  Â  Â  Â  let isDeployable = false;
Â  Â  Â  Â  let statusText = "";
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (currentListMode === 'reinforcements') {
Â  Â  Â  Â  Â  Â  if (isSetup) {
Â  Â  Â  Â  Â  Â  Â  Â  isDeployable = false;
Â  Â  Â  Â  Â  Â  Â  Â  statusText = `<span style="color:#aaa">ARRIVES TURN ${uTurn}</span>`;
Â  Â  Â  Â  Â  Â  } else if (currentTurn < uTurn) {
Â  Â  Â  Â  Â  Â  Â  Â  isDeployable = false;
Â  Â  Â  Â  Â  Â  Â  Â  statusText = `<span style="color:#aaa">ARRIVES TURN ${uTurn}</span>`;
Â  Â  Â  Â  Â  Â  } else if (currentTurn === uTurn) {
Â  Â  Â  Â  Â  Â  Â  Â  isDeployable = true;
Â  Â  Â  Â  Â  Â  Â  Â  statusText = `<span style="color:#00ff00">READY TO DEPLOY</span>`;
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  isDeployable = false;
Â  Â  Â  Â  Â  Â  Â  Â  statusText = `<span style="color:#ff4444">MISSED ARRIVAL</span>`;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } else if (currentListMode === 'tray' && isSetup) {
Â  Â  Â  Â  Â  Â  Â isDeployable = true;
Â  Â  Â  Â  Â  Â  Â statusText = `<span style="color:#00ff00">SETUP</span>`;
Â  Â  Â  Â  }

Â  Â  Â  Â  if(item.isAsset) {
Â  Â  Â  Â  Â  Â  div.innerHTML = `<div style="font-size:24px;">ðŸš€</div><div class="list-info"><div class="list-title">${item.type.toUpperCase()}</div><div class="list-meta">Turn ${item.turn} (${item.chance}%)</div></div>`;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  let qStars = "â˜…â˜…";Â 
Â  Â  Â  Â  Â  Â  if(item.quality === 'low') qStars = "â˜…";
Â  Â  Â  Â  Â  Â  else if(item.quality === 'elite') qStars = "â˜…â˜…â˜…";
Â  Â  Â  Â  Â  Â  let imgUrl = "";
Â  Â  Â  Â  Â  Â  const info = UNIT_DATA_REGISTRY[item.type];
Â  Â  Â  Â  Â  Â  let displayName = item.name || (info ? info.name : item.type);
Â  Â  Â  Â  Â  Â  if(info && info.image) imgUrl = `${ASSETS_URL}counters/${info.image}`;
Â  Â  Â  Â  Â  Â  else imgUrl = `${ASSETS_URL}counters/${item.type}.png`;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Location Text
Â  Â  Â  Â  Â  Â  let locText = "";
Â  Â  Â  Â  Â  Â  if (item.locType === 'edge') {
Â  Â  Â  Â  Â  Â  Â  Â  locText = ` | ${item.locVal} Edge`;
Â  Â  Â  Â  Â  Â  } else if (item.locType === 'hex') {
Â  Â  Â  Â  Â  Â  Â  Â  locText = ` | Hex [${item.locVal}]`;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // Init facing
Â  Â  Â  Â  Â  Â  if (item.facing === undefined) item.facing = 0;

Â  Â  Â  Â  Â  Â  div.innerHTML = `
Â  Â  Â  Â  Â  Â  <img src="${imgUrl}" class="list-icon" onerror="this.style.display='none'">
Â  Â  Â  Â  Â  Â  <div class="list-info">
Â  Â  Â  Â  Â  Â  Â  Â  <div class="list-title">${displayName} <span class="list-stars">${qStars}</span></div>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="list-meta">${statusText}${locText}</div>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="reinf-rotate-box">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button class="btn-rotate-mini">Rotate</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span class="facing-label-mini">Facing: ${FACING_DIRS[item.facing]}</span>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  </div>`;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  if (!isDeployable) div.style.opacity = "0.5";

Â  Â  Â  Â  Â  Â  // ROTATION HANDLER
Â  Â  Â  Â  Â  Â  const rotBtn = div.querySelector('.btn-rotate-mini');
Â  Â  Â  Â  Â  Â  if(rotBtn) {
Â  Â  Â  Â  Â  Â  Â  Â  rotBtn.onclick = (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  e.stopPropagation();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  item.facing = (item.facing + 1) % 6;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateDynamicList();
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // SELECTION HANDLER
Â  Â  Â  Â  Â  Â  div.onclick = () => {
Â  Â  Â  Â  Â  Â  Â  Â  if (!isDeployable) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (isSetup) addToLog(`${displayName} arrives Turn ${uTurn} (View Only).`, "log-info");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else if (currentTurn < uTurn) addToLog(`${displayName} arrives Turn ${uTurn}.`, "log-info");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else if (currentTurn > uTurn) addToLog(`${displayName} missed arrival window (Turn ${uTurn}).`, "log-combat");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if(selectedTrayItem === item) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  selectedTrayItem = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isDeploying = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  displayMap();Â 
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  selectedTrayItem = item;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  selectedUnit = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isDeploying = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  displayMap();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  addToLog(`Selected ${displayName}. Deploy on valid area.`);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  updateDynamicList();
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  }
Â  Â  Â  Â  container.appendChild(div);
Â  Â  });
}

function deployTrayUnit(uData, hex) {
Â  Â  if (currentPhase === 'SETUP' && !setupTrayUnits.includes(uData)) {
Â  Â  Â  Â  addToLog("Cannot deploy Reinforcements during Setup!", "log-combat");
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  if(currentPhase !== 'SETUP' && parseInt(uData.turn) !== currentTurn) {
Â  Â  Â  Â  addToLog(`Unit can only be deployed on Turn ${uData.turn}.`, "log-combat"); return;
Â  Â  }
Â  Â Â 
Â  Â  let valid = false;
Â  Â  if(currentPhase === 'SETUP') {
Â  Â  Â  Â  if (uData.side === 'blue' && hex.setupZone === 'blue') valid = true;
Â  Â  Â  Â  if (uData.side === 'red' && hex.setupZone === 'red') valid = true;
Â  Â  } else {
Â  Â  Â  Â  if(uData.locType === 'hex') {
Â  Â  Â  Â  Â  Â  const [tq, tr] = uData.locVal.split(',').map(Number);
Â  Â  Â  Â  Â  Â  if(hex.q === tq && hex.r === tr) valid = true;
Â  Â  Â  Â  } else if (uData.locType === 'edge') {
Â  Â  Â  Â  Â  Â  const side = uData.locVal; // N, S, E, W
Â  Â  Â  Â  Â  Â  if (side === 'N' && hex.r === 0) valid = true;
Â  Â  Â  Â  Â  Â  else if (side === 'S' && hex.r === mapData.rows - 1) valid = true;
Â  Â  Â  Â  Â  Â  else if (side === 'W' && hex.q === 0) valid = true;
Â  Â  Â  Â  Â  Â  else if (side === 'E' && hex.q === mapData.cols - 1) valid = true;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  if (uData.side === 'blue' && hex.setupZone === 'blue') valid = true;
Â  Â  Â  Â  Â  Â  if (uData.side === 'red' && hex.setupZone === 'red') valid = true;
Â  Â  Â  Â  }
Â  Â  }

Â  Â  if (!valid) {
Â  Â  Â  Â  addToLog(`Invalid Deployment Location.`, "log-combat"); return;
Â  Â  }

Â  Â  const regInfo = UNIT_DATA_REGISTRY[uData.type] || {};
Â  Â  const stats = regInfo.stats || {};
Â  Â  const maxMp = stats.Movement_Points || 6;
Â  Â  const fp = stats.Firepower || 3;
Â  Â  const rng = stats.Range_Hexes || 6;

Â  Â  const newUnit = {
Â  Â  Â  Â  id: unitIdCounter++,
Â  Â  Â  Â  side: uData.side,
Â  Â  Â  Â  type: uData.type,
Â  Â  Â  Â  category: uData.category || regInfo.category || 'squad',
Â  Â  Â  Â  name: uData.name || regInfo.name,
Â  Â  Â  Â  quality: uData.quality || 'regular',
Â  Â  Â  Â  q: hex.q, r: hex.r,
Â  Â  Â  Â  facing: uData.facing || 0,
Â  Â  Â  Â  status: 'clear',Â 
Â  Â  Â  Â  stance: 'deployed', // Init as deployed
Â  Â  Â  Â  hasActed: false,Â  Â  // Init unspent
Â  Â  Â  Â  hasMovedThisTurn: false,
Â  Â  Â  Â  memory: {},Â  Â  Â  Â  Â // Init empty memory
Â  Â  Â  Â  mp: maxMp, maxMp: maxMp, hp: 5, fp: fp, range: rng, isFixed: false
Â  Â  };

Â  Â  units.push(newUnit);
Â  Â Â 
Â  Â  if(currentPhase === 'SETUP') setupTrayUnits = setupTrayUnits.filter(t => t !== uData);
Â  Â  else reinforcementUnits = reinforcementUnits.filter(t => t !== uData);
Â  Â Â 
Â  Â  selectedTrayItem = null;
Â  Â  isDeploying = false;
Â  Â  selectUnitInStack(newUnit);
Â  Â  displayMap();Â 
Â  Â  updateDynamicList();Â 
Â  Â  uiUpdate();
Â  Â  addToLog(`${newUnit.name} deployed.`);
Â  Â  checkControl(newUnit);
}

// --- TURN SYSTEM ---
function startGameMode(mode) {
Â  Â  document.getElementById('mode-modal').style.display = 'none';
Â  Â  currentPhase = 'SETUP';
Â  Â  document.getElementById('phase-display').innerText = 'SETUP';
Â  Â  document.getElementById('btn-phase').innerText = 'Finish Setup';
Â  Â  currentListMode = 'tray';
Â  Â Â 
Â  Â  let initRule = 'blue';
Â  Â  if (scenarioData && scenarioData.rules && scenarioData.rules.initiative) initRule = scenarioData.rules.initiative;
Â  Â  resolveInitiative(initRule);
Â  Â Â 
Â  Â  isDeploying = true;Â 
Â  Â  updateDynamicList();
Â  Â  displayMap();Â 
}

function nextPhase() {
Â  Â  // --- SETUP PHASE SEQUENCING ---
Â  Â  if (currentPhase === 'SETUP') {
Â  Â  Â  Â  if (setupTrayUnits.filter(u=>u.side===activeSide).length > 0) {Â 
Â  Â  Â  Â  Â  Â  Â if(!confirm("Undeployed units remain. Finish anyway?")) return;Â 
Â  Â  Â  Â  }

Â  Â  Â  Â  if (activeSide === initiativeWinner) {
Â  Â  Â  Â  Â  Â  const otherSide = (initiativeWinner === 'blue') ? 'red' : 'blue';
Â  Â  Â  Â  Â  Â  addToLog(`${activeSide.toUpperCase()} Setup Complete. Switching to ${otherSide.toUpperCase()}.`, "log-info");
Â  Â  Â  Â  Â  Â  switchSideTo(otherSide);
Â  Â  Â  Â  Â  Â  return;Â 
Â  Â  Â  Â  }Â 
Â  Â  Â  Â Â 
Â  Â  Â  Â  else {
Â  Â  Â  Â  Â  Â  Â currentPhase = 'Action Phase';
Â  Â  Â  Â  Â  Â  Â document.getElementById('btn-phase').innerText = "End Turn";
Â  Â  Â  Â  Â  Â  Â isDeploying = false;Â 
Â  Â  Â  Â  Â  Â  Â checkInitialControl();Â 
Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â // FORCE INITIAL SPOTTING FOR EVERYONE
Â  Â  Â  Â  Â  Â  Â units.forEach(u => runActiveSpotting(u));

Â  Â  Â  Â  Â  Â  Â switchSideTo(initiativeWinner);
Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â displayMap();
Â  Â  Â  Â  Â  Â  Â addToLog("=== MATCH START ===", "log-turn");
Â  Â  Â  Â  Â  Â  Â addToLog(`Turn ${currentTurn} Started.`, "log-turn");
Â  Â  Â  Â  Â  Â  Â toggleListMode('reinforcements');
Â  Â  Â  Â  }
Â  Â  }Â 
Â  Â  // --- NORMAL GAME LOOP ---
Â  Â  else {
Â  Â  Â  Â  // SWITCH SIDE
Â  Â  Â  Â  const otherSide = (activeSide === 'blue') ? 'red' : 'blue';
Â  Â  Â  Â  activeSide = otherSide;
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (activeSide === initiativeWinner) {
Â  Â  Â  Â  Â  Â  Â currentTurn++;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  if(currentTurn > scenarioData.info.maxTurns) {
Â  Â  Â  Â  Â  Â  let win = 'draw';
Â  Â  Â  Â  Â  Â  if(scores.blue > scores.red) win = 'blue';
Â  Â  Â  Â  Â  Â  if(scores.red > scores.blue) win = 'red';
Â  Â  Â  Â  Â  Â  endGame(win, "Turn Limit Reached");
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }

Â  Â  Â  Â  document.getElementById('turn-counter').innerText = currentTurn;
Â  Â  Â  Â Â 
Â  Â  Â  Â  // START TURN LOGIC for new Active Side
Â  Â  Â  Â  // 1. Reset MP and Acts
Â  Â  Â  Â  units.filter(u => u.side === activeSide).forEach(u => {
Â  Â  Â  Â  Â  Â  u.mp = u.maxMp;
Â  Â  Â  Â  Â  Â  u.hasActed = false;
Â  Â  Â  Â  Â  Â  // Cover Logic: If didn't move last turn -> Cover. Else Deployed.
Â  Â  Â  Â  Â  Â  if(!u.hasMovedThisTurn && (u.category==='squad'||u.category==='team')) u.stance = 'cover';
Â  Â  Â  Â  Â  Â  else u.stance = 'deployed';
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  u.hasMovedThisTurn = false; // Reset for new turn
Â  Â  Â  Â  });

Â  Â  Â  Â  // 2. Intel Propagation (Phase 1 & 2)
Â  Â  Â  Â  // Share intel between friends
Â  Â  Â  Â  const friendlyUnits = units.filter(u => u.side === activeSide);
Â  Â  Â  Â  friendlyUnits.forEach(spotter => {
Â  Â  Â  Â  Â  Â  if(!spotter.memory) return;
Â  Â  Â  Â  Â  Â  for(const [eid, memData] of Object.entries(spotter.memory)) {
Â  Â  Â  Â  Â  Â  Â  Â  if(memData.level === 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const turnsPassed = currentTurn - memData.turn;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (turnsPassed === 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Adjacent Sharing
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  friendlyUnits.forEach(friend => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const dist = getHexDistance({q: spotter.q, r: spotter.r}, {q: friend.q, r: friend.r});
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (dist <= 1 && friend.id !== spotter.id) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(!friend.memory) friend.memory = {};
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const fLevel = friend.memory[eid] ? friend.memory[eid].level : 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(fLevel < 1) friend.memory[eid] = { level: 1, turn: memData.turn };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (turnsPassed >= 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Global Sharing
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  friendlyUnits.forEach(friend => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (friend.id !== spotter.id) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(!friend.memory) friend.memory = {};
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const fLevel = friend.memory[eid] ? friend.memory[eid].level : 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(fLevel < 1) friend.memory[eid] = { level: 1, turn: memData.turn };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });

Â  Â  Â  Â  // 3. Global Spotting Check
Â  Â  Â  Â  units.filter(u => u.side === activeSide).forEach(u => runActiveSpotting(u));

Â  Â  Â  Â  switchSideTo(activeSide);
Â  Â  Â  Â  addToLog(`Turn ${currentTurn} Started. ${activeSide.toUpperCase()} Active.`, "log-turn");
Â  Â  }
Â  Â  document.getElementById('phase-display').innerText = currentPhase;
Â  Â  updateDynamicList();Â 
Â  Â  uiUpdate();
}

// --- STANDARD LOGIC ---
function handleLeftClick(pointer) {
Â  Â  const hex = getHexAtPoint(pointer.worldX, pointer.worldY);
Â  Â  if (!hex) { selectedUnit = null; selectedHex = null; uiUpdate(); return; }
Â  Â  if (losTool) { handleLOSToolClick(hex); return; }

Â  Â  if (selectedTrayItem && !selectedTrayItem.isAsset) {
Â  Â  Â  Â  deployTrayUnit(selectedTrayItem, hex);
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  // Hasty Move Handling
Â  Â  if (currentAction === 'HASTY' && selectedUnit) {
Â  Â  Â  Â  continueHastyMove(hex);
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  const hexUnits = units.filter(u => u.q === hex.q && u.r === hex.r && u.hp > 0);
Â  Â  // View Filter: Can only select own units or Visible enemies
Â  Â  const visibleUnits = hexUnits.filter(u => u.side === activeSide || getUnitVisibility(u) === 2);

Â  Â  if (currentAction && selectedUnit) {
Â  Â  Â  Â  if (currentAction === 'FIRE') {
Â  Â  Â  Â  Â  Â  const target = visibleUnits.find(u => u.side !== selectedUnit.side);
Â  Â  Â  Â  Â  Â  if(target) executeFire(selectedUnit, target);
Â  Â  Â  Â  Â  Â  else addToLog("No visible target.", "log-combat");
Â  Â  Â  Â  } else if (currentAction === 'FACING') { changeFacing(selectedUnit, hex); }Â 
Â  Â  Â  Â  else if (currentAction === 'TACTICAL') { executeTacticalMove(selectedUnit, hex); }
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  if (visibleUnits.length > 0) {
Â  Â  Â  Â  // Prefer own unit
Â  Â  Â  Â  const own = visibleUnits.find(u => u.side === activeSide);
Â  Â  Â  Â  selectUnitInStack(own || visibleUnits[visibleUnits.length - 1]);
Â  Â  } else {
Â  Â  Â  Â  selectedUnit = null; selectedHex = hex; uiUpdate();
Â  Â  }
}

// --- MOVEMENT ENGINE ---
function selectAction(action) {Â 
Â  Â  if(!selectedUnit || selectedUnit.hasActed) return;
Â  Â  currentAction = action;Â 
Â  Â  if (action === 'FIRE') addToLog(`Select target...`, "log-info");Â 
Â  Â  else if (action === 'FACING') addToLog(`Select direction...`, "log-info");Â 
Â  Â  else if (action === 'TACTICAL') addToLog(`Select adjacent hex (Ends Turn).`, "log-info");
}

function startHastyMove() {
Â  Â  if(!selectedUnit || selectedUnit.hasActed) return;
Â  Â  selectedUnit.stance = 'moving';
Â  Â  currentAction = 'HASTY';
Â  Â  document.getElementById('btn-finish-move').style.display = 'inline-block';
Â  Â  uiUpdate();
Â  Â  addToLog("Hasty Move Started. Click adjacent hexes.", "log-info");
}

function continueHastyMove(hex) {
Â  Â  const dist = getHexDistance({q:selectedUnit.q, r:selectedUnit.r}, hex);
Â  Â  if(dist !== 1) return;
Â  Â Â 
Â  Â  const cost = TERRAIN_TYPES[hex.terrain].cost;
Â  Â  if(selectedUnit.mp < cost) { addToLog("Not enough MP.", "log-combat"); return; }
Â  Â Â 
Â  Â  selectedUnit.mp -= cost;
Â  Â  moveUnitTo(selectedUnit, hex);
Â  Â  selectedUnit.hasMovedThisTurn = true;
Â  Â Â 
Â  Â  // Reactive Spotting: Enemies try to spot YOU
Â  Â  runReactiveSpotting(selectedUnit);
Â  Â Â 
Â  Â  uiUpdate();
Â  Â  if(selectedUnit.mp <= 0) finishHastyMove();
}

function finishHastyMove() {
Â  Â  if(!selectedUnit) return;
Â  Â  selectedUnit.stance = 'deployed';
Â  Â  selectedUnit.hasActed = true;
Â  Â  currentAction = null;
Â  Â  document.getElementById('btn-finish-move').style.display = 'none';
Â  Â Â 
Â  Â  // Active Spotting: YOU try to spot Enemies
Â  Â  runActiveSpotting(selectedUnit);
Â  Â Â 
Â  Â  addToLog(`${selectedUnit.name} finished move.`, "log-info");
Â  Â  selectedUnit = null;
Â  Â  uiUpdate();
Â  Â  displayMap();
}

function executeTacticalMove(unit, targetHex) {
Â  Â  const dist = getHexDistance({q: unit.q, r: unit.r}, targetHex);
Â  Â  if (dist !== 1) { addToLog("Too far! Must be adjacent.", "log-combat"); return; }
Â  Â  const terrainCost = TERRAIN_TYPES[targetHex.terrain].cost;
Â  Â  if (terrainCost >= 999) { addToLog("Impassable.", "log-combat"); return; }
Â  Â Â 
Â  Â  unit.mp = 0;Â 
Â  Â  unit.stance = 'deployed';
Â  Â  unit.hasMovedThisTurn = true;
Â  Â  moveUnitTo(unit, targetHex);
Â  Â  unit.hasActed = true;
Â  Â Â 
Â  Â  runActiveSpotting(unit);
Â  Â Â 
Â  Â  currentAction = null;
Â  Â  selectedUnit = null;
Â  Â  uiUpdate();
Â  Â  displayMap();
}

function moveUnitTo(unit, hex) {
Â  Â  // Auto-Face before moving
Â  Â  calculateFacing(unit, hex);
Â  Â Â 
Â  Â  unit.q = hex.q; unit.r = hex.r;
Â  Â  selectUnitInStack(unit); addToLog(`${unit.name} moved.`);
Â  Â  checkControl(unit);
}

function calculateFacing(unit, targetHex) {
Â  Â  if (unit.q === targetHex.q && unit.r === targetHex.r) return;
Â  Â  const startPos = getHexPosition(unit.q, unit.r);
Â  Â  const targetPos = getHexPosition(targetHex.q, targetHex.r);
Â  Â  const angleRad = Phaser.Math.Angle.Between(startPos.x, startPos.y, targetPos.x, targetPos.y);
Â  Â  const angleDeg = Phaser.Math.RadToDeg(angleRad);
Â  Â Â 
Â  Â  const idealAngles = [ -90, -30, 30, 90, 150, -150 ];
Â  Â  let closestIndex = 0;
Â  Â  let minDiff = 360;
Â  Â Â 
Â  Â  idealAngles.forEach((ideal, index) => {
Â  Â  Â  Â  let diff = Math.abs(Phaser.Math.Angle.WrapDegrees(angleDeg - ideal));
Â  Â  Â  Â  if (diff < minDiff) { minDiff = diff; closestIndex = index; }
Â  Â  });
Â  Â Â 
Â  Â  unit.facing = closestIndex;
}

function executeFire(attacker, targetUnit) {
Â  Â  if (!targetUnit || attacker.side === targetUnit.side) return;
Â  Â  const startHex = hexMap[attacker.q][attacker.r];
Â  Â  const targetHex = hexMap[targetUnit.q][targetUnit.r];
Â  Â Â 
Â  Â  let cat = attacker.category || 'squad';
Â  Â  let attHeight = (cat==='vehicle' || cat==='hwt') ? 'vehicle' : 'infantry';
Â  Â Â 
Â  Â  const physicalRange = getPhysicalRange(startHex, targetHex);
Â  Â  if (physicalRange > attacker.range) { addToLog("Out of range!", "log-combat"); currentAction = null; return; }
Â  Â Â 
Â  Â  const los = calculateLOS(startHex, targetHex, attHeight);
Â  Â  if (los.status === 'blocked') {Â 
Â  Â  Â  Â  addToLog("LOS Blocked.", "log-combat");Â 
Â  Â  Â  Â  drawVisualLOSLine(startHex, targetHex, 0xff0000);
Â  Â  Â  Â  setTimeout(() => losGraphics.clear(), 1000);
Â  Â  Â  Â  currentAction = null; return;
Â  Â  }
Â  Â Â 
Â  Â  rollD10("TO HIT (5+)", (roll) => {
Â  Â  Â  Â  let hit = roll >= 5;
Â  Â  Â  Â  let color = hit ? 0x00ff00 : 0xaaaaaa;
Â  Â  Â  Â  let damage = 0;
Â  Â  Â  Â  if (hit) {
Â  Â  Â  Â  Â  Â  damage = attacker.fp;Â 
Â  Â  Â  Â  Â  Â  if (los.status === 'degraded') { damage -= 1; addToLog("Degraded LOS (-1)", "log-info"); color = 0xffaa00; }
Â  Â  Â  Â  Â  Â  const sector = getTargetSector(attacker, targetUnit);
Â  Â  Â  Â  Â  Â  if (sector === 'REAR') { damage += 2; addToLog("Rear Shot (+2)", "log-combat"); color = 0xff0000; }
Â  Â  Â  Â  Â  Â  damage = Math.max(1, damage);
Â  Â  Â  Â  Â  Â  targetUnit.hp -= damage;
Â  Â  Â  Â  Â  Â  addToLog(`Hit! Roll ${roll}. Dmg: ${damage}`, "log-combat");
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  addToLog(`Miss. Roll ${roll}.`, "log-info");
Â  Â  Â  Â  }
Â  Â  Â  Â  drawVisualLOSLine(startHex, targetHex, color);
Â  Â  Â  Â  if (targetUnit.hp <= 0) {
Â  Â  Â  Â  Â  Â  addToLog("Target Destroyed!", "log-combat");
Â  Â  Â  Â  Â  Â  units = units.filter(u => u.id !== targetUnit.id);
Â  Â  Â  Â  Â  Â  selectedUnit = null; uiUpdate();
Â  Â  Â  Â  } else { uiUpdate(); }
Â  Â  Â  Â Â 
Â  Â  Â  Â  attacker.hasActed = true;
Â  Â  Â  Â  setTimeout(() => losGraphics.clear(), 1000);
Â  Â  Â  Â  currentAction = null;
Â  Â  });
}

function loadScenario() {
Â  Â  let txt = document.getElementById('json-input').value;
Â  Â  txt = txt.replace(/[\n\r\t]+/g, ' ').replace(/\u00A0/g, ' ').trim();
Â  Â  try {
Â  Â  Â  Â  scenarioData = JSON.parse(txt);
Â  Â  Â  Â  mapData = scenarioData.map;Â 
Â  Â  Â  Â  units = []; setupTrayUnits = []; reinforcementUnits = []; strikes = [];
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (scenarioData.units.locked) {
Â  Â  Â  Â  Â  Â  scenarioData.units.locked.forEach(u => {
Â  Â  Â  Â  Â  Â  Â  Â  u.isFixed = true;Â 
Â  Â  Â  Â  Â  Â  Â  Â  if(!u.category && UNIT_DATA_REGISTRY[u.type]) { const info = UNIT_DATA_REGISTRY[u.type]; u.category = info.category; if(!u.name) u.name = info.name; }
Â  Â  Â  Â  Â  Â  Â  Â  if(!u.stance) u.stance = 'deployed'; if(u.stance === 'cover' && u.category === 'hwt') u.stance = 'setup';
Â  Â  Â  Â  Â  Â  Â  Â  const stats = (UNIT_DATA_REGISTRY[u.type] || {}).stats || {};
Â  Â  Â  Â  Â  Â  Â  Â  u.maxMp = stats.Movement_Points || 6; if(u.mp === undefined) u.mp = u.maxMp; if(u.fp === undefined) u.fp = stats.Firepower || 3;
Â  Â  Â  Â  Â  Â  Â  Â  if(u.range === undefined) u.range = stats.Range_Hexes || 6; if(u.hp === undefined) u.hp = 5;
Â  Â  Â  Â  Â  Â  Â  Â  units.push(u);
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }
Â  Â  Â  Â  if (scenarioData.units.tray) {
Â  Â  Â  Â  Â  Â  scenarioData.units.tray.forEach(u => {
Â  Â  Â  Â  Â  Â  Â  Â  if(!u.category && UNIT_DATA_REGISTRY[u.type]) u.category = UNIT_DATA_REGISTRY[u.type].category;
Â  Â  Â  Â  Â  Â  Â  Â  if(!u.name && UNIT_DATA_REGISTRY[u.type]) u.name = UNIT_DATA_REGISTRY[u.type].name;
Â  Â  Â  Â  Â  Â  Â  Â  if (u.turn && parseInt(u.turn) > 0) reinforcementUnits.push(u); else setupTrayUnits.push(u);
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }
Â  Â  Â  Â  if (scenarioData.units.reinforcements) {
Â  Â  Â  Â  Â  Â  scenarioData.units.reinforcements.forEach(r => {
Â  Â  Â  Â  Â  Â  Â  Â  Â if(!r.category && UNIT_DATA_REGISTRY[r.type]) r.category = UNIT_DATA_REGISTRY[r.type].category;
Â  Â  Â  Â  Â  Â  Â  Â  Â if(!r.name && UNIT_DATA_REGISTRY[r.type]) r.name = UNIT_DATA_REGISTRY[r.type].name;
Â  Â  Â  Â  Â  Â  Â  Â  Â reinforcementUnits.push(r);
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }
Â  Â  Â  Â  if (scenarioData.support) { scenarioData.support.forEach(s => { s.isAsset = true; strikes.push(s); }); }
Â  Â  Â  Â Â 
Â  Â  Â  Â  document.getElementById('max-turns').innerText = scenarioData.info.maxTurns;
Â  Â  Â  Â  toggleMapLoader();
Â  Â  Â  Â  document.getElementById('mode-modal').style.display = 'flex';Â 
Â  Â  Â  Â Â 
Â  Â  } catch (e) { alert('Invalid JSON: ' + e.message); console.error(e); }
}

// ... PRESERVED FUNCTIONS ...
function getUnitKey(unit) { if (unit.type && scene.textures.exists(unit.type)) return unit.type; if (unit.unitType && scene.textures.exists(unit.unitType)) return unit.unitType; return 'fallback'; }
function getUnitImageURL(unit) { const key = getUnitKey(unit); const info = UNIT_DATA_REGISTRY[unit.type]; if(info && info.image) return `${ASSETS_URL}counters/${info.image}`; return `${ASSETS_URL}counters/${key}.png`; }
function uiUpdate() { selectionGraphics.clear(); unitGraphics.clear(); badgeGraphics.clear(); scene.children.list.filter(c => c.name === 'badgeText').forEach(c => c.destroy()); redrawAllUnits(); if (!selectedUnit && selectedHex) { selectionGraphics.lineStyle(3, 0xffffff, 1); selectionGraphics.strokeCircle(selectedHex.x, selectedHex.y, HEX_RADIUS - 5); } if (selectedUnit) showUnitPanel(selectedUnit); else if (selectedHex) showTerrainPanel(selectedHex); else clearContextPanel(); }
function showUnitPanel(unit) { document.getElementById('ctx-img').innerHTML = `<img src="${getUnitImageURL(unit)}">`; const side = unit.side === 'blue' ? 'UK' : 'German'; let titleText = unit.name; if (!titleText) { const info = UNIT_DATA_REGISTRY[unit.type]; if(info) titleText = info.name; else { let catName = unit.category ? unit.category.charAt(0).toUpperCase() + unit.category.slice(1) : "Unit"; titleText = `${side} ${catName}`; } } document.getElementById('ctx-title').innerText = titleText; let subText = "UNIT"; const cat = (unit.category || "").toLowerCase(); if (cat === 'squad') subText = "RIFLE SQUAD"; else if (cat === 'team') subText = "WEAPON TEAM"; else if (cat === 'hwt') subText = "HEAVY WEAPON TEAM"; else if (cat === 'vehicle') subText = "VEHICLE"; document.getElementById('ctx-subtitle').innerText = subText; let qStars = "â˜…â˜…"; let q = unit.quality || 'regular'; if(q === 'low') qStars = "â˜…"; else if(q === 'elite') qStars = "â˜…â˜…â˜…"; document.getElementById('ctx-quality').innerText = qStars; document.getElementById('unit-actions').style.display = 'grid'; const leftEl = document.getElementById('ctx-status-left'); let sColor = '#aaa'; let sText = "OPERATIONAL"; if(unit.status === 'clear') { sColor='#fff'; sText="OPERATIONAL"; } else if(unit.status === 'shaken') { sColor='#ff4444'; sText="SHAKEN"; } else if(unit.status === 'damaged') { sColor='#cc00cc'; sText="DAMAGED"; } else if(unit.status === 'immobilized') { sColor='#cc00cc'; sText="IMMOBILIZED"; } else if(unit.status.startsWith('suppressed')) { sColor='#ffff00'; sText="SUPPRESSED +" + unit.status.split('_')[1]; } leftEl.innerText = sText; leftEl.style.color = sColor; leftEl.style.border = `1px solid ${sColor}`; const rightEl = document.getElementById('ctx-stance-right'); let stTextVal = unit.stance || 'deployed'; if(unit.stance === 'cover') stTextVal = 'Cover'; if(unit.stance === 'setup') stTextVal = 'Set Up'; if(unit.stance === 'moving') stTextVal = 'Moving'; let stColor = '#fff'; if(unit.stance === 'moving') stColor = '#0055ff'; else if(unit.stance === 'deployed') stColor = '#ff0000'; else if(unit.stance === 'cover' || unit.stance === 'setup') stColor = '#ff8095'; rightEl.innerText = stTextVal.toUpperCase(); rightEl.style.color = stColor; rightEl.style.border = `1px solid ${stColor}`; if (currentPhase === 'SETUP') { document.querySelectorAll('.btn-game').forEach(b => b.style.display = 'none'); if (!unit.isFixed) { document.querySelectorAll('.btn-setup').forEach(b => b.style.display = 'block'); } else { document.querySelectorAll('.btn-setup').forEach(b => b.style.display = 'none'); } } else { document.querySelectorAll('.btn-game').forEach(b => b.style.display = 'block'); document.querySelectorAll('.btn-setup').forEach(b => b.style.display = 'none'); } const badgeContainer = document.getElementById('ctx-badges'); badgeContainer.innerHTML = ''; if (unit.isFixed && currentPhase === 'SETUP') { const b = document.createElement('span'); b.className = 'badge'; b.style.background = '#555'; b.innerText = 'FIXED'; badgeContainer.appendChild(b); } const hex = hexMap[unit.q][unit.r]; const terrain = hex.terrain; const tProps = TERRAIN_TYPES[terrain]; const tBadge = document.createElement('span'); tBadge.className = 'badge badge-terrain'; tBadge.innerText = terrain.toUpperCase(); if(tProps) { tBadge.style.backgroundColor = '#' + tProps.color.toString(16); tBadge.style.color = (tProps.color > 0x888888) ? '#000' : '#fff'; } tBadge.onclick = () => { selectedUnit = null; selectedHex = hexMap[unit.q][unit.r]; uiUpdate(); }; badgeContainer.appendChild(tBadge); if (hex.victoryPoints) { const vpBadge = document.createElement('span'); vpBadge.className = 'badge badge-vp'; vpBadge.innerText = `VP: ${hex.victoryPoints}`; badgeContainer.appendChild(vpBadge); } if (unit.hp < 5) { const b = document.createElement('span'); b.className = 'badge badge-damage'; b.innerText = `DMG -${5-unit.hp}`; badgeContainer.appendChild(b); } const regInfo = UNIT_DATA_REGISTRY[unit.type] || {}; const stats = regInfo.stats || {}; const maxMp = stats.Movement_Points || unit.maxMp || 6; const curMp = (unit.mp !== undefined) ? unit.mp : maxMp; const fp = stats.Firepower || unit.fp || 3; const rng = stats.Range_Hexes || unit.range || 6; const statsHtml = `<div class="stat-row"><span class="stat-label">Morale:</span> <span class="stat-value">Steady</span></div><div class="stat-row"><span class="stat-label">MP:</span> <span class="stat-value">${curMp}/${maxMp}</span></div><div class="stat-row"><span class="stat-label">Firepower:</span> <span class="stat-value">${fp}</span></div><div class="stat-row"><span class="stat-label">Range:</span> <span class="stat-value">${rng}</span></div><div class="stat-row"><span class="stat-label">Facing:</span> <span class="stat-value">${["N","NE","SE","S","SW","NW"][unit.facing]}</span></div>`; document.getElementById('stats-header').innerText = 'UNIT STATISTICS'; document.getElementById('stats-content').innerHTML = statsHtml; const stack = units.filter(u => u.q === unit.q && u.r === unit.r && u.hp > 0 && getUnitVisibility(u) > 0); const stackDiv = document.getElementById('stack-container'); const stackList = document.getElementById('stack-list'); if (stack.length > 1) { stackDiv.style.display = 'block'; stackList.innerHTML = ''; const renderStack = [...stack].reverse(); renderStack.forEach(u => { const item = document.createElement('div'); item.className = 'stack-item'; if (u === unit) item.style.borderColor = 'var(--accent)'; if (u.hasActed) item.classList.add('spent'); const facingDir = ["N","NE","SE","S","SW","NW"][u.facing]; let stText = "Deployed"; if(u.stance === 'moving') stText = "Moving"; else if(u.stance === 'cover') stText = "Cover"; else if(u.stance === 'setup') stText = "Set Up"; let statText = "Operational"; let statColor = "#fff"; if(u.status === 'shaken') { statText="Shaken"; statColor="#ff4444"; } else if(u.status === 'damaged') { statText="Damaged"; statColor="#cc00cc"; } else if(u.status === 'immobilized') { statText="Immobilized"; statColor="#cc00cc"; } else if(u.status.startsWith('suppressed')) { statText="Suppressed +" + u.status.split('_')[1]; statColor="#ffff00"; } let stackName = u.name; if(!stackName && UNIT_DATA_REGISTRY[u.type]) stackName = UNIT_DATA_REGISTRY[u.type].name; item.innerHTML = `<img class="stack-img" src="${getUnitImageURL(u)}"><div class="stack-info"><div class="stack-name">${stackName}</div><div>MP: ${u.mp} | Face: ${facingDir}</div><div>Stance: ${stText}</div><div style="color:${statColor}; font-weight:bold; font-size:10px;">Status: ${statText}</div></div>`; item.onclick = () => { selectUnitInStack(u); }; stackList.appendChild(item); }); } else { stackDiv.style.display = 'none'; } }
function showTerrainPanel(hex) { const terrain = hex.terrain; const props = TERRAIN_TYPES[terrain]; const variant = hex.variant || 1; let firstImg = `${terrain}${variant}.png`; if(props && props.images && props.images.length > 0) { firstImg = props.images[variant-1] || props.images[0]; } document.getElementById('ctx-img').innerHTML = `<img src="${ASSETS_URL}map/${firstImg}">`; document.getElementById('ctx-title').innerText = terrain.toUpperCase(); document.getElementById('ctx-subtitle').innerText = `COORD: ${hex.q}, ${hex.r}`; document.getElementById('unit-actions').style.display = 'none'; document.getElementById('ctx-status-left').innerText = ""; document.getElementById('ctx-status-left').style.border="none"; document.getElementById('ctx-stance-right').innerText = ""; document.getElementById('ctx-stance-right').style.border="none"; document.getElementById('ctx-quality').innerText = ""; const badgeContainer = document.getElementById('ctx-badges'); badgeContainer.innerHTML = ''; const tBadge = document.createElement('span'); tBadge.className = 'badge badge-terrain'; tBadge.innerText = terrain.toUpperCase(); if(props) { tBadge.style.backgroundColor = '#' + props.color.toString(16); tBadge.style.color = (props.color > 0x888888) ? '#000' : '#fff'; } badgeContainer.appendChild(tBadge); if (hex.victoryPoints) { const vpBadge = document.createElement('span'); vpBadge.className = 'badge badge-vp'; vpBadge.innerText = `VP: ${hex.victoryPoints}`; badgeContainer.appendChild(vpBadge); } const key = `${hex.q},${hex.r}`; if(captureOwners[key]) { const cBadge = document.createElement('span'); cBadge.className='badge'; cBadge.style.background = captureOwners[key]==='blue' ? 'var(--blue-team)':'var(--red-team)'; cBadge.innerText = "OWNED"; badgeContainer.appendChild(cBadge); } document.getElementById('stack-container').style.display = 'none'; if(props) { const statsHtml = `<div class="stat-row"><span class="stat-label">Move Cost:</span> <span class="stat-value">${props.cost}</span></div><div class="stat-row"><span class="stat-label">Height:</span> <span class="stat-value">${props.terrainHeight}</span></div><div class="stat-row"><span class="stat-label">LOS Effect:</span> <span class="stat-value">${props.los.toUpperCase()}</span></div><div class="stat-row"><span class="stat-label">Infantry Ht:</span> <span class="stat-value">${props.infantryUsable}</span></div><div class="stat-row"><span class="stat-label">Vehicle Ht:</span> <span class="stat-value">${props.vehicleUsable}</span></div>`; document.getElementById('stats-header').innerText = 'TERRAIN DATA'; document.getElementById('stats-content').innerHTML = statsHtml; } }
function clearContextPanel() { document.getElementById('ctx-img').innerHTML = ''; document.getElementById('ctx-title').innerText = 'No Selection'; document.getElementById('ctx-subtitle').innerText = '-'; document.getElementById('ctx-badges').innerHTML = ''; document.getElementById('ctx-quality').innerText = ''; document.getElementById('unit-actions').style.display = 'none'; document.getElementById('stats-content').innerHTML = ''; document.getElementById('stack-container').style.display = 'none'; document.getElementById('ctx-status-left').innerText = ""; document.getElementById('ctx-status-left').style.border="none"; document.getElementById('ctx-stance-right').innerText = ""; document.getElementById('ctx-stance-right').style.border="none"; }
function selectUnitInStack(unit) { selectedUnit = unit; selectedHex = null; units = units.filter(u => u !== unit); units.push(unit); uiUpdate(); }
function redeployUnit() { if (!selectedUnit || currentPhase !== 'SETUP' || selectedUnit.isFixed) return; const trayObj = { id: selectedUnit.id, side: selectedUnit.side, type: selectedUnit.type, category: selectedUnit.category, name: selectedUnit.name, quality: selectedUnit.quality }; setupTrayUnits.push(trayObj); units = units.filter(u => u !== selectedUnit); selectedUnit = null; displayMap(); updateDynamicList(); uiUpdate(); addToLog("Unit returned to Tray."); }

// --- UPDATED RENDERING HELPERS ---
function getUnitVisibility(target) {
Â  Â  // SETUP Phase: Only show own units
Â  Â  if(currentPhase === 'SETUP') {
Â  Â  Â  Â  return target.side === activeSide ? 2 : 0;
Â  Â  }
Â  Â Â 
Â  Â  // Normal Play: Always see own units
Â  Â  if (target.side === activeSide) return 2;
Â  Â Â 
Â  Â  // Check specific unit memory if selected
Â  Â  if (selectedUnit && selectedUnit.side === activeSide) {
Â  Â  Â  Â  if(selectedUnit.memory && selectedUnit.memory[target.id]) return selectedUnit.memory[target.id].level;
Â  Â  Â  Â  return 0;
Â  Â  }
Â  Â Â 
Â  Â  // Check global side memory
Â  Â  let maxLvl = 0;
Â  Â  units.filter(u => u.side === activeSide).forEach(u => {
Â  Â  Â  Â  if(u.memory && u.memory[target.id] && u.memory[target.id].level > maxLvl) maxLvl = u.memory[target.id].level;
Â  Â  });
Â  Â  return maxLvl;
}

function redrawAllUnits() {Â 
Â  Â  Object.values(unitSprites).forEach(sprite => sprite.destroy());Â 
Â  Â  unitSprites = {};Â 
Â  Â Â 
Â  Â  // Group by Stack first
Â  Â  const stacks = {};
Â  Â  units.forEach(u => {
Â  Â  Â  Â if(u.hp <= 0) return;
Â  Â  Â  Â const key = `${u.q},${u.r}`;
Â  Â  Â  Â if(!stacks[key]) stacks[key] = [];
Â  Â  Â  Â stacks[key].push(u);
Â  Â  });

Â  Â  Object.values(stacks).forEach(stack => {
Â  Â  Â  Â  // Filter visible ones
Â  Â  Â  Â  const visibleStack = stack.filter(u => getUnitVisibility(u) > 0);
Â  Â  Â  Â  if(visibleStack.length === 0) return;
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Count for Badge (Strict VisLevel 2 check for Enemies)
Â  Â  Â  Â  let badgeCount = 0;
Â  Â  Â  Â  visibleStack.forEach(u => {
Â  Â  Â  Â  Â  Â  if (u.side === activeSide) badgeCount++;
Â  Â  Â  Â  Â  Â  else if (getUnitVisibility(u) === 2) badgeCount++;
Â  Â  Â  Â  });

Â  Â  Â  Â  // "Top" unit is the last one in the array (drawn last)
Â  Â  Â  Â  const topUnit = visibleStack[visibleStack.length - 1];

Â  Â  Â  Â  visibleStack.forEach(unit => {
Â  Â  Â  Â  Â  Â  const pos = getHexPosition(unit.q, unit.r);
Â  Â  Â  Â  Â  Â  const visLevel = getUnitVisibility(unit);
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // 1. Draw Sprite
Â  Â  Â  Â  Â  Â  let texture = getUnitKey(unit);
Â  Â  Â  Â  Â  Â  let alpha = 1.0;Â 
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  if (visLevel === 1 && unit.side !== activeSide) {
Â  Â  Â  Â  Â  Â  Â  Â  let sidePrefix = unit.side === 'blue' ? 'UK' : 'GER';
Â  Â  Â  Â  Â  Â  Â  Â  let catSuffix = (unit.category === 'vehicle' || unit.category === 'hwt') ? 'Vehicle' : 'Infantry';
Â  Â  Â  Â  Â  Â  Â  Â  texture = `${sidePrefix}_FOW_${catSuffix}`;
Â  Â  Â  Â  Â  Â  Â  Â  if (!scene.textures.exists(texture)) texture = 'fow_generic';
Â  Â  Â  Â  Â  Â  Â  Â  // FIXED: Force full opacity for FOW tokens
Â  Â  Â  Â  Â  Â  Â  Â  alpha = 1.0;Â 
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â if (!scene.textures.exists(texture)) texture = 'fallback';
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  const sprite = scene.add.image(pos.x, pos.y, texture);
Â  Â  Â  Â  Â  Â  sprite.setDisplaySize(HEX_RADIUS * 1.25, HEX_RADIUS * 1.25);
Â  Â  Â  Â  Â  Â  sprite.setDepth(600);
Â  Â  Â  Â  Â  Â  sprite.setAlpha(alpha);
Â  Â  Â  Â  Â  Â  unitSprites[unit.id] = sprite;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // 2. Overlays (Strict Top Check)
Â  Â  Â  Â  Â  Â  const isTop = (unit === topUnit);

Â  Â  Â  Â  Â  Â  // Red Stripe (Spent) - Only on Top & Active Side
Â  Â  Â  Â  Â  Â  if (isTop && unit.side === activeSide && unit.hasActed && visLevel === 2) {
Â  Â  Â  Â  Â  Â  Â  Â  const barW = 32; const barH = 6;
Â  Â  Â  Â  Â  Â  Â  Â  unitGraphics.fillStyle(0xff0000, 1.0);
Â  Â  Â  Â  Â  Â  Â  Â  unitGraphics.fillRect(pos.x - barW/2, pos.y + 16, barW, barH);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // Facing Triangle
Â  Â  Â  Â  Â  Â  // Active Player sees facing on:
Â  Â  Â  Â  Â  Â  // - OWN units (subject to stack rule)
Â  Â  Â  Â  Â  Â  // - ENEMY Vehicles/HWT (subject to stack rule)
Â  Â  Â  Â  Â  Â  // - NEVER Enemy Squads/Teams
Â  Â  Â  Â  Â  Â  let showFacing = false;

Â  Â  Â  Â  Â  Â  if (visLevel === 2) {
Â  Â  Â  Â  Â  Â  Â  Â  if (unit.side === activeSide) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Own unit: standard logic
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (isTop || unit.facing !== topUnit.facing) showFacing = true;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Enemy unit: strict type check
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const cat = (unit.category || "").toLowerCase();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (cat === 'vehicle' || cat === 'hwt') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (isTop || unit.facing !== topUnit.facing) showFacing = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  if (showFacing) {
Â  Â  Â  Â  Â  Â  Â  Â  Â drawFacingIndicator(unit, pos);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // Status Markers (Damage/Shaken) - Only on Top & Active Side
Â  Â  Â  Â  Â  Â  // Hides damage info for enemy units
Â  Â  Â  Â  Â  Â  if (isTop && unit.side === activeSide && visLevel === 2) {
Â  Â  Â  Â  Â  Â  Â  Â  drawStatusMarkers(unit, pos);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });

Â  Â  Â  Â  // 3. Stack Count Badge (Only if count > 1)
Â  Â  Â  Â  if (badgeCount > 1) {Â 
Â  Â  Â  Â  Â  Â  const pos = getHexPosition(topUnit.q, topUnit.r);
Â  Â  Â  Â  Â  Â  const badgeX = pos.x + 10; const badgeY = pos.y - 18;Â 
Â  Â  Â  Â  Â  Â  badgeGraphics.fillStyle(0xffffff, 1); badgeGraphics.fillRect(badgeX, badgeY, 16, 14);Â 
Â  Â  Â  Â  Â  Â  badgeGraphics.lineStyle(1, 0x000000, 1); badgeGraphics.strokeRect(badgeX, badgeY, 16, 14);Â 
Â  Â  Â  Â  Â  Â  scene.add.text(badgeX + 8, badgeY + 7, `+${badgeCount-1}`, { font: '11px Arial', fill: '#000', fontStyle:'bold' }).setOrigin(0.5).setDepth(810).setResolution(2).setName('badgeText');Â 
Â  Â  Â  Â  }Â 
Â  Â  });
Â  Â Â 
Â  Â  // Selection Ring Logic
Â  Â  if (selectedUnit || selectedHex) {Â 
Â  Â  Â  Â  const activeHex = selectedUnit ? hexMap[selectedUnit.q][selectedUnit.r] : selectedHex;Â 
Â  Â  Â  Â  if(activeHex) {Â 
Â  Â  Â  Â  Â  Â  const p = getHexPosition(activeHex.q, activeHex.r);Â 
Â  Â  Â  Â  Â  Â  selectionGraphics.lineStyle(3, 0xffffff, 1);Â 
Â  Â  Â  Â  Â  Â  selectionGraphics.strokeCircle(p.x, p.y, HEX_RADIUS * 0.7);Â 
Â  Â  Â  Â  }Â 
Â  Â  }Â 
}

function drawFacingIndicator(unit, pos) { const facingAngles = [-90, -30, 30, 90, 150, -150]; const angleRad = Phaser.Math.DegToRad(facingAngles[unit.facing]); const indicatorDist = HEX_RADIUS * 0.75; const triX = pos.x + Math.cos(angleRad) * indicatorDist; const triY = pos.y + Math.sin(angleRad) * indicatorDist; let triColor = 0xffffff; if(unit.stance === 'moving') triColor = 0x0055ff; else if(unit.stance === 'deployed') triColor = 0xff0000; else if(unit.stance === 'cover' || unit.stance === 'setup') triColor = 0xff8095; unitGraphics.fillStyle(triColor, 1); const size = 8; unitGraphics.beginPath(); unitGraphics.moveTo(triX + Math.cos(angleRad)*size, triY + Math.sin(angleRad)*size); unitGraphics.lineTo(triX + Math.cos(angleRad+2.5)*size, triY + Math.sin(angleRad+2.5)*size); unitGraphics.lineTo(triX + Math.cos(angleRad-2.5)*size, triY + Math.sin(angleRad-2.5)*size); unitGraphics.closePath(); unitGraphics.fillPath(); }
function drawStatusMarkers(unit, pos) { if (unit.status !== 'clear') { const bx = pos.x + 15; const by = pos.y + 15; let statColor = 0xffffff; let label = "!"; if(unit.status === 'suppressed_2') { statColor = 0xffff00; label="+2"; } else if(unit.status === 'suppressed_4') { statColor = 0xffff00; label="+4"; } else if(unit.status === 'suppressed_6') { statColor = 0xffff00; label="+6"; } else if(unit.status === 'shaken') { statColor = 0xff0000; label="!"; } else if(unit.status === 'damaged') { statColor = 0x8800cc; label="X"; } else if(unit.status === 'immobilized') { statColor = 0x8800cc; label="I"; } badgeGraphics.fillStyle(statColor, 1); badgeGraphics.fillRect(bx - 8, by - 6, 16, 12); badgeGraphics.lineStyle(1, 0x000000, 1); badgeGraphics.strokeRect(bx - 8, by - 6, 16, 12); scene.add.text(bx, by, label, { font: '9px Arial', fill: '#000', fontStyle: 'bold' }).setOrigin(0.5).setDepth(810).setResolution(2).setName('badgeText'); } }
function toggleLOSTool() { losTool = !losTool; losStartHex = null; losGraphics.clear(); const container = document.getElementById('los-options'); container.style.display = losTool ? 'flex' : 'none'; document.getElementById('btn-los').classList.toggle('active', losTool); if (losTool) { if (selectedUnit) { losStartHex = hexMap[selectedUnit.q][selectedUnit.r]; let cat = selectedUnit.category || 'squad'; let lType = (cat==='vehicle' || cat==='hwt') ? 'vehicle' : 'infantry'; setLOSType(lType); highlightHex(losStartHex, 0xffffff); addToLog(`LOS Start: Unit at ${losStartHex.q},${losStartHex.r}`, "log-info"); } else if (selectedHex) { losStartHex = selectedHex; highlightHex(losStartHex, 0xffffff); addToLog(`LOS Start: Terrain at ${losStartHex.q},${losStartHex.r}`, "log-info"); } else { addToLog("LOS Tool: Select Start Hex...", "log-info"); } } else { addToLog("LOS Tool Deactivated.", "log-info"); uiUpdate(); } }
function setLOSType(type) { losUnitType = type; document.getElementById('los-inf').classList.toggle('active', type === 'infantry'); document.getElementById('los-veh').classList.toggle('active', type === 'vehicle'); }
function handleLOSToolClick(hex) { if (!losStartHex) { losStartHex = hex; highlightHex(hex, 0xffffff); addToLog("Start Hex selected. Select Target...", "log-info"); } else { const result = calculateLOS(losStartHex, hex, losUnitType); let color = 0xff0000; let txt = "BLOCKED"; if(result.status === 'clear') { color = 0x00ff00; txt = "CLEAR"; } if(result.status === 'degraded') { color = 0xffaa00; txt = "DEGRADED"; } drawVisualLOSLine(losStartHex, hex, color); addToLog(`LOS Result: ${txt} ${result.isRoad ? '(Road)' : ''}`); } }
function changeFacing(unit, targetHex) { if (unit.q === targetHex.q && unit.r === targetHex.r) return; const startPos = getHexPosition(unit.q, unit.r); const targetPos = getHexPosition(targetHex.q, targetHex.r); const angleRad = Phaser.Math.Angle.Between(startPos.x, startPos.y, targetPos.x, targetPos.y); let angleDeg = Phaser.Math.RadToDeg(angleRad); const idealAngles = [ -90, -30, 30, 90, 150, -150 ]; let closestIndex = 0; let minDiff = 360; idealAngles.forEach((ideal, index) => { let diff = Math.abs(Phaser.Math.Angle.WrapDegrees(angleDeg - ideal)); if (diff < minDiff) { minDiff = diff; closestIndex = index; } }); unit.facing = closestIndex; uiUpdate(); addToLog(`Facing set to ${["N","NE","SE","S","SW","NW"][closestIndex]}`); currentAction = null; if(currentPhase === 'SETUP') redrawAllUnits(); }
function addToLog(msg, cssClass = "") { const container = document.getElementById('log-container'); const entry = document.createElement('div'); entry.className = `log-entry ${cssClass}`; entry.innerText = msg; container.appendChild(entry); container.scrollTop = container.scrollHeight; }
function toggleMapLoader() { const el = document.getElementById('json-modal'); el.style.display = (el.style.display === 'block') ? 'none' : 'block'; }
function highlightHex(hex, color) { selectionGraphics.lineStyle(4, color); selectionGraphics.strokeCircle(hex.x, hex.y, HEX_RADIUS - 5); }
function drawVisualLOSLine(start, end, color) { losGraphics.clear(); losGraphics.lineStyle(4, color, 0.8); losGraphics.beginPath(); losGraphics.moveTo(start.x, start.y); losGraphics.lineTo(end.x, end.y); losGraphics.strokePath(); }
function displayMap() {Â 
Â  Â  if (!mapData) return;Â 
Â  Â  hexGroup.clear(true, true);Â 
Â  Â  roadGraphics.clear();Â 
Â  Â  zoneGraphics.clear();Â 
Â  Â  objGraphics.clear();Â 
Â  Â  objectiveSprites.forEach(s => s.destroy()); objectiveSprites = [];Â 
Â  Â  hexMap = {};Â 
Â  Â  const cols = mapData.cols || 0;Â 
Â  Â  const rows = mapData.rows || 0;Â 
Â  Â  for (let q = 0; q < cols; q++) {Â 
Â  Â  Â  Â  hexMap[q] = {};Â 
Â  Â  Â  Â  for (let r = 0; r < rows; r++) {Â 
Â  Â  Â  Â  Â  Â  const pos = getHexPosition(q, r);Â 
Â  Â  Â  Â  Â  Â  hexMap[q][r] = { terrain: 'clear', x: pos.x, y: pos.y, q: q, r: r, hasRoad: false, variant: null };Â 
Â  Â  Â  Â  }Â 
Â  Â  }Â 
Â  Â  if (mapData.terrain) mapData.terrain.forEach(t => { if (hexMap[t.q] && hexMap[t.q][t.r]) hexMap[t.q][t.r].terrain = t.type; });Â 
Â  Â  if (mapData.roads) mapData.roads.forEach(road => { if (hexMap[road.from.q]) hexMap[road.from.q][road.from.r].hasRoad = true; if (hexMap[road.to.q]) hexMap[road.to.q][road.to.r].hasRoad = true; });Â 
Â  Â Â 
Â  Â  // UPDATED SAFE ZONE RENDER
Â  Â  if (mapData.zones) {Â 
Â  Â  Â  Â  mapData.zones.forEach(z => {Â 
Â  Â  Â  Â  Â  Â  if (hexMap[z.q] && hexMap[z.q][z.r]) {Â 
Â  Â  Â  Â  Â  Â  Â  Â  hexMap[z.q][z.r].setupZone = z.side;Â 
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // CRITICAL SAFETY CHECK for selectedTrayItem
Â  Â  Â  Â  Â  Â  Â  Â  let isZoneDeployment = true;
Â  Â  Â  Â  Â  Â  Â  Â  if (selectedTrayItem) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (selectedTrayItem.locType === 'hex' || selectedTrayItem.locType === 'edge') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isZoneDeployment = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Render Zone if SETUP or (Deploying Zone Unit & Side Matches)
Â  Â  Â  Â  Â  Â  Â  Â  if (currentPhase === 'SETUP' || (isDeploying && isZoneDeployment && selectedTrayItem && selectedTrayItem.side === z.side)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const p = getHexPosition(z.q, z.r);Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const pts = []; for(let i=0; i<6; i++) { const a = Math.PI/3*i; pts.push({x: p.x+HEX_RADIUS*Math.cos(a), y: p.y+HEX_RADIUS*Math.sin(a)}); }Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const color = z.side === 'blue' ? 0x4488ff : 0xff4444;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  zoneGraphics.fillStyle(color, 0.2).fillPoints(pts, true);Â 
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }Â 
Â  Â  Â  Â  });Â 
Â  Â  }
Â  Â Â 
Â  Â  // SPECIFIC HEX HIGHLIGHT (SAFE)
Â  Â  if (isDeploying && selectedTrayItem && selectedTrayItem.locType === 'hex') {Â 
Â  Â  Â  Â  const [tq, tr] = selectedTrayItem.locVal.split(',').map(Number);Â 
Â  Â  Â  Â  if(hexMap[tq] && hexMap[tq][tr]) {Â 
Â  Â  Â  Â  Â  Â  const p = getHexPosition(tq, tr);Â 
Â  Â  Â  Â  Â  Â  const pts = []; for(let i=0; i<6; i++) { const a = Math.PI/3*i; pts.push({x: p.x+HEX_RADIUS*Math.cos(a), y: p.y+HEX_RADIUS*Math.sin(a)}); }Â 
Â  Â  Â  Â  Â  Â  const color = selectedTrayItem.side === 'blue' ? 0x4488ff : 0xff4444;Â 
Â  Â  Â  Â  Â  Â  zoneGraphics.fillStyle(color, 0.4).fillPoints(pts, true);Â 
Â  Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  // SPECIFIC EDGE HIGHLIGHT (SAFE)
Â  Â  if (isDeploying && selectedTrayItem && selectedTrayItem.locType === 'edge') {
Â  Â  Â  Â  const side = selectedTrayItem.locVal; // N, S, E, W
Â  Â  Â  Â  const color = selectedTrayItem.side === 'blue' ? 0x4488ff : 0xff4444;
Â  Â  Â  Â  for (let q = 0; q < mapData.cols; q++) {
Â  Â  Â  Â  Â  Â  for (let r = 0; r < mapData.rows; r++) {
Â  Â  Â  Â  Â  Â  Â  Â  let isEdge = false;
Â  Â  Â  Â  Â  Â  Â  Â  if (side === 'N' && r === 0) isEdge = true;
Â  Â  Â  Â  Â  Â  Â  Â  if (side === 'S' && r === mapData.rows - 1) isEdge = true;
Â  Â  Â  Â  Â  Â  Â  Â  if (side === 'W' && q === 0) isEdge = true;
Â  Â  Â  Â  Â  Â  Â  Â  if (side === 'E' && q === mapData.cols - 1) isEdge = true;

Â  Â  Â  Â  Â  Â  Â  Â  if (isEdge && hexMap[q][r]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const p = getHexPosition(q, r);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const pts = []; for(let i=0; i<6; i++) { const a = Math.PI/3*i; pts.push({x: p.x+HEX_RADIUS*Math.cos(a), y: p.y+HEX_RADIUS*Math.sin(a)}); }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  zoneGraphics.fillStyle(color, 0.4).fillPoints(pts, true);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }

Â  Â  const oldObjectives = mapData.objectives || mapData.victoryHexes || []; const newObjectives = (scenarioData && scenarioData.victory && scenarioData.victory.locations) ? scenarioData.victory.locations : []; const allObjectives = [...oldObjectives, ...newObjectives]; if (allObjectives.length > 0) { allObjectives.forEach(obj => { if (hexMap[obj.q] && hexMap[obj.q][obj.r]) { const hex = hexMap[obj.q][obj.r]; hex.victoryPoints = obj.points || 100; const star = scene.add.star(hex.x, hex.y, 5, 8, 16, 0xffcc00); star.setStrokeStyle(2, 0x000000); star.setDepth(150); objectiveSprites.push(star); const txt = scene.add.text(hex.x, hex.y + 10, hex.victoryPoints.toString(), { fontSize: '10px', stroke: '#000', strokeThickness: 3, fill: '#fff', fontStyle: 'bold' }).setOrigin(0.5).setDepth(151); objectiveSprites.push(txt); } }); } for (let q = 0; q < cols; q++) { for (let r = 0; r < rows; r++) { drawHex(hexMap[q][r]); } } drawRoads(); redrawAllUnits();Â 
}
function drawHex(hex) { const terrainType = hex.terrain; const x = hex.x; const y = hex.y; if (!hex.variant) hex.variant = Phaser.Math.Between(1, 3); const textureKey = `${terrainType}${hex.variant}`; if (scene.textures.exists(textureKey)) { const img = scene.add.image(x, y, textureKey).setDisplaySize(HEX_RADIUS * 2, HEX_RADIUS * 2); const shape = scene.make.graphics().fillStyle(0xffffff).beginPath(); for (let i = 0; i < 6; i++) { const angle = (Math.PI / 3) * i; const hx = x + HEX_RADIUS * Math.cos(angle); const hy = y + HEX_RADIUS * Math.sin(angle); if (i === 0) shape.moveTo(hx, hy); else shape.lineTo(hx, hy); } shape.closePath().fillPath(); img.setMask(shape.createGeometryMask()); hexGroup.add(img); const outline = scene.add.graphics().lineStyle(1, 0x333333, 0.5).beginPath(); for (let i = 0; i < 6; i++) { const angle = (Math.PI / 3) * i; const hx = x + HEX_RADIUS * Math.cos(angle); const hy = y + HEX_RADIUS * Math.sin(angle); if (i === 0) outline.moveTo(hx, hy); else outline.lineTo(hx, hy); } outline.closePath().strokePath(); hexGroup.add(outline); } else { let color = 0x555555; if(TERRAIN_TYPES[terrainType]) color = TERRAIN_TYPES[terrainType].color || 0x555555; const g = scene.add.graphics().fillStyle(color).lineStyle(1, 0x333333, 0.5).beginPath(); for (let i = 0; i < 6; i++) { const angle = (Math.PI / 3) * i; const hx = x + HEX_RADIUS * Math.cos(angle); const hy = y + HEX_RADIUS * Math.sin(angle); if (i === 0) g.moveTo(hx, hy); else g.lineTo(hx, hy); } g.closePath().fillPath().strokePath(); hexGroup.add(g); } }
function drawRoads() { if (!mapData || !mapData.roads) return; roadGraphics.lineStyle(6, 0x555555, 0.8); mapData.roads.forEach(seg => { const h1 = hexMap[seg.from.q][seg.from.r]; const h2 = hexMap[seg.to.q][seg.to.r]; if (h1 && h2) roadGraphics.beginPath().moveTo(h1.x, h1.y).lineTo(h2.x, h2.y).strokePath(); }); }
function getHexPosition(q, r) { const x = q * HEX_RADIUS * 1.5; const y = r * HEX_RADIUS * Math.sqrt(3) + (q % 2 === 1 ? HEX_RADIUS * Math.sqrt(3) / 2 : 0); return { x, y }; }
function offsetToCube(q, r) { const col = q; const row = r; const x = col; const z = row - (col - (col & 1)) / 2; const y = -x - z; return { x, y, z }; }
function getHexDistance(h1, h2) { const a = offsetToCube(h1.q, h1.r); const b = offsetToCube(h2.q, h2.r); return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y), Math.abs(a.z - b.z)); }
function getHexAtPoint(worldX, worldY) { if (!mapData) return null; let closestHex = null; let closestDist = Infinity; for (let q = 0; q < mapData.cols; q++) { for (let r = 0; r < mapData.rows; r++) { const hex = hexMap[q][r]; const dist = Math.sqrt((hex.x - worldX) ** 2 + (hex.y - worldY) ** 2); if (dist < HEX_RADIUS && dist < closestDist) { closestDist = dist; closestHex = hex; } } } return closestHex; }
function getPhysicalRange(startHex, targetHex) { const hexes = []; const dx = targetHex.x - startHex.x; const dy = targetHex.y - startHex.y; const dist = Math.sqrt(dx * dx + dy * dy); const steps = Math.ceil(dist / 2); for (let i = 0; i <= steps; i++) { const t = i / steps; const currX = startHex.x + dx * t; const currY = startHex.y + dy * t; const h = getHexAtPoint(currX, currY); if (h) { const key = `${h.q},${h.r}`; if (!hexes.includes(key) && !(h.q === startHex.q && h.r === startHex.r)) hexes.push(key); } } return hexes.length; }
function getTargetSector(attacker, target) { const targetPos = getHexPosition(target.q, target.r); const attackerPos = getHexPosition(attacker.q, attacker.r); const angleRad = Phaser.Math.Angle.Between(targetPos.x, targetPos.y, attackerPos.x, attackerPos.y); const angleDeg = Phaser.Math.RadToDeg(angleRad); const idealAngles = [ -90, -30, 30, 90, 150, -150 ]; let attackDirIndex = 0; let minDiff = 360; idealAngles.forEach((ideal, index) => { let diff = Math.abs(Phaser.Math.Angle.WrapDegrees(angleDeg - ideal)); if (diff < minDiff) { minDiff = diff; attackDirIndex = index; } }); let diff = Math.abs(target.facing - attackDirIndex); if (diff > 3) diff = 6 - diff; return diff <= 1 ? 'FRONT' : 'REAR'; }
function calculateLOS(startHex, targetHex, unitType = 'infantry') { const fromTerrain = TERRAIN_TYPES[startHex.terrain]; const fromUsableHeight = unitType === 'vehicle' ? fromTerrain.vehicleUsable : fromTerrain.infantryUsable; const dx = targetHex.x - startHex.x; const dy = targetHex.y - startHex.y; const distance = Math.sqrt(dx * dx + dy * dy); const steps = Math.ceil(distance / 2); const hexesCrossed = new Set(); const edgeSegments = []; let edgeRunLength = 0; let edgeHexPair = null; for (let i = 0; i <= steps; i++) { const t = i / steps; const x = startHex.x + dx * t; const y = startHex.y + dy * t; const currentHex = getHexAtPoint(x, y); if (!currentHex) continue; if ((currentHex.q === startHex.q && currentHex.r === startHex.r) || (currentHex.q === targetHex.q && currentHex.r === targetHex.r)) continue; const perpDx = -dy / distance; const perpDy = dx / distance; const hex1 = getHexAtPoint(x + perpDx * 3, y + perpDy * 3); const hex2 = getHexAtPoint(x - perpDx * 3, y - perpDy * 3); if (hex1 && hex2 && (hex1.q !== hex2.q || hex1.r !== hex2.r)) { const pairKey = [`${hex1.q},${hex1.r}`, `${hex2.q},${hex2.r}`].sort().join('|'); if (edgeHexPair === pairKey) edgeRunLength++; else { if (edgeRunLength > 5) edgeSegments.push(edgeHexPair); edgeHexPair = pairKey; edgeRunLength = 1; } } else { if (edgeRunLength > 5) edgeSegments.push(edgeHexPair); edgeRunLength = 0; edgeHexPair = null; hexesCrossed.add(`${currentHex.q},${currentHex.r}`); } } if (edgeRunLength > 5) edgeSegments.push(edgeHexPair); let degradingCount = 0; let hasBlocking = false; for (let key of hexesCrossed) { const [q, r] = key.split(',').map(Number); const terrain = TERRAIN_TYPES[hexMap[q][r].terrain]; let losEffect = terrain.los; if (terrain.terrainHeight < fromUsableHeight) { if (losEffect === 'blocking') losEffect = 'degrading'; else if (losEffect === 'degrading') losEffect = 'clear'; } if (losEffect === 'blocking') hasBlocking = true; else if (losEffect === 'degrading') degradingCount++; } for (let edgePair of edgeSegments) { if (!edgePair) continue; const [k1, k2] = edgePair.split('|'); const [q1, r1] = k1.split(',').map(Number); const [q2, r2] = k2.split(',').map(Number); const t1 = TERRAIN_TYPES[hexMap[q1][r1].terrain]; const t2 = TERRAIN_TYPES[hexMap[q2][r2].terrain]; let l1 = t1.los; let l2 = t2.los; if (t1.terrainHeight < fromUsableHeight) l1 = (l1==='blocking'?'degrading':(l1==='degrading'?'clear':l1)); if (t2.terrainHeight < fromUsableHeight) l2 = (l2==='blocking'?'degrading':(l2==='degrading'?'clear':l2)); if (l1 === 'blocking' && l2 === 'blocking') hasBlocking = true; else if (l1 === 'blocking' || l2 === 'blocking') degradingCount++; else if (l1 === 'degrading' && l2 === 'degrading') degradingCount++; } let standardStatus = 'clear'; if (hasBlocking || degradingCount >= 2) standardStatus = 'blocked'; else if (degradingCount === 1) standardStatus = 'degraded'; const hexesOnLine = getHexesAlongLine(startHex, targetHex); const roadLOSResult = checkRoadLOS(startHex, targetHex, hexesOnLine); if (roadLOSResult.isRoad) { const dist = getHexDistance(startHex, targetHex); let roadStatus = 'blocked'; if (dist <= 5) roadStatus = 'clear'; else if (dist <= 10) roadStatus = 'degraded'; const rank = { 'clear': 3, 'degraded': 2, 'blocked': 1 }; if (rank[roadStatus] > rank[standardStatus]) return { status: roadStatus, isRoad: true }; } return { status: standardStatus, isRoad: false }; }
function getHexesAlongLine(startHex, targetHex) { const hexes = []; const dx = targetHex.x - startHex.x; const dy = targetHex.y - startHex.y; const dist = Math.sqrt(dx*dx + dy*dy); const steps = Math.ceil(dist / 10); for(let i=0; i<=steps; i++) { const t = i/steps; const h = getHexAtPoint(startHex.x + dx*t, startHex.y + dy*t); if(h && !hexes.includes(h)) hexes.push(h); } return hexes; }
function checkRoadLOS(startHex, targetHex, hexesOnLine) { if (!mapData || !mapData.roads) return { isRoad: false }; if (!startHex.hasRoad || !targetHex.hasRoad) return { isRoad: false }; const roadPath = findRoadPath(startHex, targetHex); if (!roadPath || roadPath.length < 2) return { isRoad: false }; const idealDx = targetHex.x - startHex.x; const idealDy = targetHex.y - startHex.y; const idealLen = Math.sqrt(idealDx*idealDx + idealDy*idealDy); for (let i = 0; i < roadPath.length - 1; i++) { const c = roadPath[i]; const n = roadPath[i+1]; const sdx = n.x - c.x; const sdy = n.y - c.y; const slen = Math.sqrt(sdx*sdx + sdy*sdy); const dot = (idealDx/idealLen) * (sdx/slen) + (idealDy/idealLen) * (sdy/slen); if (dot < 0.96) return { isRoad: false }; } for (let h of hexesOnLine) { if (!roadPath.find(rh => rh.q === h.q && rh.r === h.r)) return { isRoad: false }; } return { isRoad: true }; }
function findRoadPath(start, target) { const visited = new Set(); const queue = [[start]]; while(queue.length > 0) { const path = queue.shift(); const curr = path[path.length-1]; if(curr.q === target.q && curr.r === target.r) return path; const key = `${curr.q},${curr.r}`; if(visited.has(key)) continue; visited.add(key); mapData.roads.forEach(r => { let next = null; if(r.from.q === curr.q && r.from.r === curr.r) next = hexMap[r.to.q][r.to.r]; else if(r.to.q === curr.q && r.to.r === curr.r) next = hexMap[r.from.q][r.from.r]; if(next) queue.push([...path, next]); }); } return null; }
</script>
</body>
</html>
