<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Wargame Engine v0.9.11 - Final Fixes</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        :root {
            --bg-dark: #1e1e1e;
            --bg-panel: #2a2a2a;
            --accent: #d4a017;
            --text-main: #e0e0e0;
            --text-dim: #a0a0a0;
            --border: #444;
            --blue-team: #4488ff;
            --red-team: #ff4444;
        }

        body { 
            margin: 0; padding: 0; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-dark);
            color: var(--text-main);
            height: 100vh;
            display: grid;
            grid-template-columns: 260px 1fr 320px;
            overflow: hidden;
        }

        /* --- LEFT PANEL --- */
        #left-panel {
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            padding: 15px;
            display: flex; flex-direction: column; gap: 10px;
            overflow-y: auto; z-index: 10;
        }
        .panel-header {
            color: var(--accent); font-size: 18px; font-weight: bold;
            margin-bottom: 5px; border-bottom: 2px solid var(--accent); padding-bottom: 5px;
        }
        .scenario-box {
            background: #333; border: 1px solid var(--border); padding: 10px;
            border-radius: 4px; font-size: 13px; min-height: 60px;
        }
        
        /* SCOREBOARD */
        .score-box {
            display: grid; grid-template-columns: 1fr 1fr; gap: 5px;
            background: #222; padding: 8px; border-radius: 4px; border: 1px solid #444; margin-bottom: 5px;
        }
        .score-team { text-align: center; font-weight: bold; font-size: 14px; }
        .score-val { font-size: 18px; font-family: monospace; text-align: center; }
        .bar-container { grid-column: span 2; height: 6px; background: #444; margin-top: 5px; position: relative; border-radius:3px; overflow:hidden; }
        .bar-fill { height: 100%; background: var(--blue-team); width: 50%; transition: width 0.5s; }

        .turn-display {
            text-align: center; font-size: 14px; font-weight: bold;
            background: #222; padding: 8px;
            border: 1px solid var(--border); border-radius: 4px;
        }

        /* MENU BUTTONS */
        .menu-btn-group { display: flex; flex-direction: column; gap: 5px; }
        
        .btn {
            background: #444; color: var(--text-main); border: 1px solid #555;
            padding: 10px; cursor: pointer; border-radius: 4px;
            font-weight: bold; transition: background 0.2s; text-align: center;
        }
        .btn:hover { background: #555; border-color: #777; }
        .btn-primary { background: #d4a017; color: #111; border: none; }
        .btn-primary:hover { background: #b88a10; }
        .btn.active { background: var(--accent); color: #000; border-color: var(--accent); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* LIST STYLES */
        .list-item {
            display: flex; align-items: center; gap: 10px;
            background: #222; border: 1px solid #444;
            padding: 5px; margin-bottom: 5px; cursor: pointer;
            border-left: 3px solid transparent;
            position: relative;
        }
        .list-item:hover { background: #333; border-color: #666; }
        .list-item.selected { border-color: var(--accent); background: #332200; }
        .list-item.arrival { border-left-color: #00ff00; }
        .list-icon { width: 32px; height: 32px; object-fit: contain; }
        .list-info { flex-grow: 1; }
        .list-title { font-weight:bold; font-size:12px; color:#fff; }
        .list-meta { font-size:10px; color:#aaa; }
        .list-stars { color: #ffd700; font-size: 10px; margin-left: 5px; }
        
        /* Rotation UI inside List */
        .reinf-rotate-box { display: flex; align-items: center; gap: 5px; margin-top: 3px; }
        .btn-rotate-mini { padding: 2px 6px; font-size: 9px; background: #555; border: 1px solid #666; border-radius: 2px; color: #fff; cursor: pointer; }
        .btn-rotate-mini:hover { background: #777; }
        .facing-label-mini { font-size: 10px; color: var(--accent); font-weight: bold; }

        /* D10 DICE CSS */
        #dice-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); 
            display: none; flex-direction: column; align-items: center; justify-content: center; gap: 20px;
            z-index: 2000;
        }
        .d10-container { width: 180px; height: 180px; position: relative; filter: drop-shadow(0 15px 15px rgba(0,0,0,0.6)); }
        .dice-shaking { animation: shake 0.1s infinite; }
        .d10-val { position: absolute; top: 38%; left: 50%; transform: translate(-50%, -50%); font-size: 56px; font-weight: bold; color: white; text-shadow: 2px 2px 4px black; font-family: 'Arial', sans-serif; pointer-events: none; }
        .dice-label { background: #111; color: var(--accent); padding: 10px 30px; border-radius: 4px; font-weight: bold; font-size: 18px; text-transform: uppercase; border: 1px solid var(--accent); box-shadow: 0 0 15px rgba(0,0,0,0.8); }
        .dice-btn { background: var(--blue-team); color: white; border: none; padding: 10px 40px; font-size: 16px; font-weight: bold; border-radius: 4px; cursor: pointer; display: none; box-shadow: 0 0 10px rgba(68, 136, 255, 0.5); }
        .dice-btn:hover { background: #3377ff; }
        @keyframes shake { 0% { transform: rotate(0deg); } 25% { transform: rotate(5deg); } 50% { transform: rotate(-5deg); } 75% { transform: rotate(5deg); } 100% { transform: rotate(0deg); } }

        /* MODALS */
        .modal-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 3000; display: none; flex-direction: column; align-items: center; justify-content: center; }
        .modal-card { background: #222; border: 2px solid var(--accent); padding: 30px; text-align: center; max-width: 400px; width: 80%; box-shadow: 0 0 50px rgba(0,0,0,0.8); }
        .mode-btn { width: 100%; margin-top: 10px; padding: 15px; font-size: 16px; }

        /* TOOLS */
        .tool-sub-options { display: flex; gap: 5px; margin-top: 5px; }
        .btn-small { padding: 5px; font-size: 11px; flex: 1; }

        /* CENTER MAP */
        #game-container { position: relative; overflow: hidden; background: #111; }

        /* RIGHT PANEL */
        #right-panel { background: var(--bg-panel); border-left: 1px solid var(--border); display: grid; grid-template-rows: auto 1fr 200px; overflow: hidden; z-index: 10; }
        #context-card { padding: 15px; background: #333; border-bottom: 1px solid var(--border); text-align: center; min-height: 140px; }
        .ctx-header-row { display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 5px; }
        .ctx-portrait { width: 80px; height: 80px; display: flex; align-items: center; justify-content: center; background: #222; border-radius: 4px; border: 1px solid #444; }
        .ctx-portrait img { width: 100%; height: 100%; object-fit: contain; }
        .ctx-side-info { width: 60px; font-size: 10px; font-weight: bold; text-align: center; padding: 4px; border-radius: 4px; background: #222; display: flex; align-items: center; justify-content: center; min-height: 24px; border: 1px solid #444; }
        .ctx-title { font-size: 16px; font-weight: bold; color: white; }
        .ctx-subtitle { font-size: 12px; color: var(--accent); margin-bottom: 5px; }
        .status-badges { display: flex; gap: 5px; justify-content: center; margin-top: 5px; flex-wrap: wrap; }
        .badge { font-size: 10px; padding: 3px 8px; border-radius: 3px; font-weight: bold; cursor: default; }
        .badge-terrain { cursor: pointer; border: 1px solid rgba(255,255,255,0.2); }
        .badge-vp { background: #000; color: #FFD700; border: 1px solid #FFD700; }
        #context-stats { padding: 15px; overflow-y: auto; }
        .stat-row { display: flex; justify-content: space-between; border-bottom: 1px solid #3a3a3a; padding: 4px 0; font-size: 13px; }
        .stat-label { color: var(--text-dim); }
        .stat-value { font-weight: bold; color: white; }

        /* STACK */
        #stack-list { display: flex; flex-direction: column; gap: 5px; margin-top: 10px; }
        .stack-item { cursor: pointer; border: 1px solid #444; border-radius: 4px; background: #222; padding: 5px; display: flex; align-items: center; gap: 10px; }
        .stack-item:hover { border-color: var(--accent); background: #333; }
        .stack-img { width: 40px; height: 40px; object-fit: contain; }
        .stack-info { flex-grow: 1; font-size: 11px; text-align: left; }

        /* LOG */
        #log-container { background: #111; border-top: 1px solid var(--accent); padding: 10px; font-family: 'Consolas', monospace; font-size: 11px; overflow-y: auto; color: #ccc; }
        .log-entry { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }
        .log-turn { color: var(--accent); font-weight: bold; margin-top: 8px; }
        .log-combat { color: #ff5555; }
        .log-info { color: #88ccff; }
        .log-capture { color: #ffff00; }

        #json-modal { position: absolute; top: 50px; left: 50px; width: 300px; background: #222; border: 2px solid var(--accent); padding: 15px; z-index: 2000; display: none; }
    </style>
</head>
<body>

<div id="left-panel">
    <div class="panel-header">SCENARIO</div>
    <div class="scenario-box" id="scenario-info-box">
        <strong style="color:white">Wargame Engine</strong><br>
        <span style="color:#aaa">No Scenario Loaded</span><br>
        <p style="margin:5px 0 0 0; color:#888; font-style:italic">Load JSON to start...</p>
    </div>

    <div class="score-box">
        <div class="score-team" style="color:var(--blue-team)">UK</div>
        <div class="score-team" style="color:var(--red-team)">GER</div>
        <div class="score-val" style="color:var(--blue-team)" id="score-blue">0</div>
        <div class="score-val" style="color:var(--red-team)" id="score-red">0</div>
        <div class="bar-container">
            <div class="bar-fill" id="score-bar"></div>
        </div>
    </div>

    <div class="turn-display">
        TURN: <span id="turn-counter">1</span> / <span id="max-turns">-</span><br>
        <span style="color: var(--accent); font-size:12px;" id="phase-display">SETUP</span>
    </div>

    <div class="menu-btn-group">
        <button class="btn" onclick="toggleListMode('reinforcements')" id="btn-reinf">REINFORCEMENTS</button>
        <button class="btn" onclick="toggleListMode('strikes')" id="btn-strikes">OFF-BOARD STRIKES</button>
        <button class="btn btn-primary" id="btn-phase" onclick="nextPhase()">Finish Setup</button>
    </div>
    
    <div id="dynamic-list-area" style="flex-grow:1; overflow-y:auto; margin-top:10px;"></div>
    
    <div class="panel-header" style="margin-top:10px">TOOLS</div>
    <div>
        <button class="btn" id="btn-los" style="width:100%" onclick="toggleLOSTool()">Line of Sight Tool</button>
        <div id="los-options" class="tool-sub-options" style="display:none;">
            <button id="los-inf" class="btn btn-small active" onclick="setLOSType('infantry')">Infantry Height</button>
            <button id="los-veh" class="btn btn-small" onclick="setLOSType('vehicle')">Vehicle Height</button>
        </div>
    </div>
    <button class="btn" onclick="toggleMapLoader()">Load Scenario JSON</button>
</div>

<div id="game-container">
    <div id="json-modal">
        <textarea id="json-input" rows="6" style="width:100%; background:#111; color:#fff; border:1px solid #444;" placeholder="Paste Scenario JSON..."></textarea>
        <button class="btn btn-primary" style="width:100%; margin-top:5px;" onclick="loadScenario()">Load</button>
        <button class="btn" style="width:100%; margin-top:5px;" onclick="toggleMapLoader()">Close</button>
    </div>
    <div id="mode-modal" class="modal-overlay">
        <div class="modal-card">
            <h2 style="color:var(--accent); margin-top:0">SELECT GAME MODE</h2>
            <button class="mode-btn btn btn-primary" onclick="startGameMode('hotseat')">HOTSEAT (2 Player)</button>
            <button class="mode-btn btn" disabled style="opacity:0.5; cursor:not-allowed">PLAYER VS AI (Coming Soon)</button>
        </div>
    </div>
    <div id="dice-overlay">
        <div class="dice-label" id="dice-label">Rolling...</div>
        <div class="d10-container" id="dice-anim">
            <svg width="180" height="180" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <defs><linearGradient id="diceGrad" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#ffaa00;stop-opacity:1" /><stop offset="100%" style="stop-color:#cc4400;stop-opacity:1" /></linearGradient></defs>
                <path d="M50 2 L95 38 L78 88 L22 88 L5 38 Z" fill="url(#diceGrad)" stroke="#fff" stroke-width="2" stroke-linejoin="round"/>
                <path d="M50 2 L80 38 L50 65 L20 38 Z" fill="none" stroke="#fff" stroke-width="2" stroke-linejoin="round"/>
                <path d="M5 38 L20 38" stroke="#fff" stroke-width="2"/> <path d="M95 38 L80 38" stroke="#fff" stroke-width="2"/> <path d="M22 88 L50 65" stroke="#fff" stroke-width="2"/>
                <path d="M78 88 L50 65" stroke="#fff" stroke-width="2"/>
            </svg>
            <div class="d10-val" id="dice-val">0</div>
        </div>
        <button class="dice-btn" id="dice-ok-btn">CONTINUE</button>
    </div>
    <div id="game-over-modal" class="modal-overlay">
        <div class="modal-card">
            <div style="font-size:32px; font-weight:bold; margin-bottom:10px;" id="end-title">VICTORY</div>
            <div style="color:#aaa; margin-bottom:20px; font-style:italic;" id="end-reason">Turns Limit Reached</div>
            <div style="margin-bottom:20px; font-size:18px;"><span style="color:var(--blue-team)">UK: <span id="end-blue">0</span></span> &nbsp;|&nbsp; <span style="color:var(--red-team)">GER: <span id="end-red">0</span></span></div>
            <button class="btn btn-primary" onclick="location.reload()">Return to Menu</button>
        </div>
    </div>
</div>

<div id="right-panel">
    <div id="context-card">
        <div class="ctx-header-row"><div id="ctx-status-left" class="ctx-side-info" style="color:#aaa;">-</div><div class="ctx-portrait" id="ctx-img"></div><div id="ctx-stance-right" class="ctx-side-info" style="color:#aaa;">-</div></div>
        <div id="ctx-quality" style="color:#ffd700; font-size:16px; margin-bottom:5px; line-height:1;"></div>
        <div class="ctx-title" id="ctx-title">No Selection</div>
        <div class="ctx-subtitle" id="ctx-subtitle">-</div>
        <div class="status-badges" id="ctx-badges"></div>
        <div id="unit-actions" style="margin-top:10px; display:none; gap:5px; grid-template-columns: 1fr 1fr;">
            <button class="btn btn-game" style="padding:5px" onclick="selectAction('TACTICAL')">Tactical</button>
            <button class="btn btn-game" style="padding:5px" onclick="selectAction('FAST')">Fast</button>
            <button class="btn btn-game" style="padding:5px" onclick="selectAction('FACING')">Face</button>
            <button class="btn btn-game" style="padding:5px; border-color:#ff5555; color:#ff5555" onclick="selectAction('FIRE')">FIRE</button>
            <button class="btn btn-setup" style="padding:5px; display:none" onclick="selectAction('FACING')">Rotate</button>
            <button class="btn btn-setup" style="padding:5px; border-color:#ffaa00; color:#ffaa00; display:none" onclick="redeployUnit()">Redeploy</button>
        </div>
    </div>
    <div id="context-stats">
        <div class="panel-header" style="font-size:14px; border-width:1px;" id="stats-header">STATISTICS</div>
        <div id="stats-content"></div>
        <div id="stack-container" style="display:none; margin-top:15px;">
            <div class="panel-header" style="font-size:14px; border-width:1px;">STACK (Top First)</div>
            <div id="stack-list"></div>
        </div>
    </div>
    <div id="log-container"><div class="log-entry">System initialized.</div></div>
</div>

<script>
// --- Configuration ---
const ASSETS_URL = 'https://raw.githubusercontent.com/trainJapan/HexWargame/main/artwork/';
const FACING_DIRS = ["N","NE","SE","S","SW","NW"];

// --- DYNAMIC REGISTRIES ---
let UNIT_DATA_REGISTRY = {};
let TERRAIN_TYPES = {};

const HEX_RADIUS = 40;

// Game State
let scenarioData = null; 
let mapData = null; 
let losTool = false;
let losStartHex = null;
let losUnitType = 'infantry';
let units = [];

// Separate Data Lists
let setupTrayUnits = []; 
let reinforcementUnits = []; 
let strikes = [];   

let unitIdCounter = 2000;
let currentTurn = 1;
let currentPhase = 'SETUP'; 
let scores = { blue: 0, red: 0 };
let captureOwners = {}; 
let currentListMode = 'tray'; 

// Selection State
let selectedUnit = null; 
let selectedHex = null; 
let selectedTrayItem = null; 
let currentAction = null; 
let isDeploying = false; 

// Phaser Objects
let scene, hexGroup, zoneGraphics, objGraphics, roadGraphics, losGraphics, unitGraphics, selectionGraphics, badgeGraphics, hexMap = {};
let unitSprites = {};
let objectiveSprites = []; 
let diceCallback = null; 

const config = {
    type: Phaser.AUTO, parent: 'game-container',
    width: window.innerWidth - 580, height: window.innerHeight,
    backgroundColor: '#1a1a1a',
    scene: { preload: preloadScene, create: createScene, update: updateScene }
};

const game = new Phaser.Game(config);

function preloadScene() {
    this.load.json('units_uk', 'units_UK.json');
    this.load.json('units_ger', 'units_GER.json');
    this.load.json('terrain_data', 'terrain.json');
    this.make.graphics({x:0,y:0,add:false}).fillStyle(0xffffff).fillRect(0,0,1,1).generateTexture('fallback', 1, 1);
}

function createScene() {
    scene = this;
    try {
        const ukData = this.cache.json.get('units_uk') || {};
        const gerData = this.cache.json.get('units_ger') || {};
        const tData = this.cache.json.get('terrain_data') || {};
        Object.entries(ukData).forEach(([key, data]) => { data.key = key; data.side = 'blue'; UNIT_DATA_REGISTRY[key] = data; });
        Object.entries(gerData).forEach(([key, data]) => { data.key = key; data.side = 'red'; UNIT_DATA_REGISTRY[key] = data; });
        Object.entries(tData).forEach(([key, data]) => {
            TERRAIN_TYPES[key] = {
                images: data.images || [],
                color: 0x555555, los: (data.los_effect || 'clear').toLowerCase(), cost: data.movement_cost || 1,
                terrainHeight: data.terrain_height || 0, infantryUsable: data.unit_height_infantry || 0, vehicleUsable: data.unit_height_vehicle || 0
            };
        });
        let loadCount = 0;
        Object.values(UNIT_DATA_REGISTRY).forEach(u => { if(u.image) { this.load.image(u.key, ASSETS_URL + 'counters/' + u.image); loadCount++; } });
        Object.values(TERRAIN_TYPES).forEach(t => { if(t.images) { t.images.forEach(img => { const k = img.replace(/\.[^/.]+$/, ""); this.load.image(k, ASSETS_URL + 'map/' + img); }); loadCount++; } });
        if(loadCount > 0) { this.load.once('complete', () => { initEngine(); }); this.load.start(); } else { initEngine(); }
    } catch(e) { console.error("Error parsing JSON:", e); alert("Failed to load JSONs."); }
}

function initEngine() {
    hexGroup = scene.add.group(); 
    zoneGraphics = scene.add.graphics().setDepth(20); 
    roadGraphics = scene.add.graphics().setDepth(100);
    objGraphics = scene.add.graphics().setDepth(150); 
    selectionGraphics = scene.add.graphics().setDepth(500); 
    losGraphics = scene.add.graphics().setDepth(550);        
    unitGraphics = scene.add.graphics().setDepth(700);      
    badgeGraphics = scene.add.graphics().setDepth(800);     
    scene.cameras.main.setBounds(-2000, -2000, 8000, 8000); 
    scene.input.mouse.disableContextMenu();
    scene.input.on('wheel', (pointer, gameObjects, deltaX, deltaY) => {
        const zoom = scene.cameras.main.zoom - (deltaY * 0.001);
        scene.cameras.main.setZoom(Phaser.Math.Clamp(zoom, 0.3, 2));
    });
    scene.input.on('pointerdown', (pointer) => {
        if (pointer.leftButtonDown()) handleLeftClick(pointer);
        if (pointer.rightButtonDown()) {
            if (currentAction) { currentAction = null; uiUpdate(); addToLog("Action cancelled."); }
            if (selectedTrayItem) { selectedTrayItem = null; isDeploying = false; displayMap(); updateDynamicList(); }
        }
    });
    document.getElementById('dice-ok-btn').addEventListener('click', closeDiceOverlay);
    addToLog("System Ready. Load Scenario to begin.");
}

function updateScene() {
    if (this.input.activePointer.rightButtonDown()) {
        const pointer = this.input.activePointer;
        this.cameras.main.scrollX -= (pointer.x - pointer.prevPosition.x) / this.cameras.main.zoom;
        this.cameras.main.scrollY -= (pointer.y - pointer.prevPosition.y) / this.cameras.main.zoom;
    }
}

// --- D10 DICE SYSTEM ---
function rollD10(label, callback) {
    const overlay = document.getElementById('dice-overlay');
    const container = document.getElementById('dice-anim');
    const valDisplay = document.getElementById('dice-val');
    const lbl = document.getElementById('dice-label');
    const btn = document.getElementById('dice-ok-btn');
    overlay.style.display = 'flex';
    btn.style.display = 'none';
    lbl.innerText = label || "ROLLING...";
    container.classList.add('dice-shaking');
    diceCallback = callback;
    let result = 1;
    const interval = setInterval(() => { result = Phaser.Math.Between(1, 10); valDisplay.innerText = result === 10 ? "0" : result; }, 50);
    setTimeout(() => {
        clearInterval(interval);
        result = Phaser.Math.Between(1, 10);
        valDisplay.innerText = result === 10 ? "0" : result;
        container.classList.remove('dice-shaking');
        lbl.innerText = `RESULT: ${result === 10 ? "0 (10)" : result}`;
        btn.style.display = 'block';
        diceCallback = () => { if(callback) callback(result); };
    }, 800);
}

function closeDiceOverlay() { document.getElementById('dice-overlay').style.display = 'none'; if(diceCallback) diceCallback(); diceCallback = null; }

// --- VICTORY SYSTEM ---
function checkInitialControl() { units.forEach(u => { checkControl(u); }); }
function checkControl(unit) {
    if(!unit || unit.hp <= 0) return;
    const key = `${unit.q},${unit.r}`;
    const hex = hexMap[unit.q][unit.r];
    if(hex && hex.victoryPoints && captureOwners[key] !== unit.side) {
        captureOwners[key] = unit.side;
        addToLog(`${unit.side.toUpperCase()} captured VL at ${unit.q},${unit.r}!`, "log-capture");
        updateScore();
    }
}
function updateScore() {
    scores.blue = 0; scores.red = 0;
    for(const key in captureOwners) { const [q,r] = key.split(',').map(Number); const hex = hexMap[q][r]; if(hex && hex.victoryPoints) { scores[captureOwners[key]] += hex.victoryPoints; } }
    document.getElementById('score-blue').innerText = scores.blue;
    document.getElementById('score-red').innerText = scores.red;
    const total = scores.blue + scores.red;
    if(total > 0) { const pct = (scores.blue / total) * 100; document.getElementById('score-bar').style.width = `${pct}%`; } else { document.getElementById('score-bar').style.width = `50%`; }
    if(currentPhase !== 'SETUP') displayMap(); 
    checkSuddenDeath();
}
function checkSuddenDeath() {
    if(!scenarioData || !scenarioData.victory || !scenarioData.victory.thresholds) return;
    const th = scenarioData.victory.thresholds;
    const totalPossible = scenarioData.victory.locations.reduce((sum, loc) => sum + loc.points, 0);
    if(totalPossible === 0) return;
    if (parseInt(th.blue) > 0 && (scores.blue / totalPossible) * 100 >= parseInt(th.blue)) endGame('blue', 'Threshold Met');
    if (parseInt(th.red) > 0 && (scores.red / totalPossible) * 100 >= parseInt(th.red)) endGame('red', 'Threshold Met');
}
function endGame(winner, reason) {
    document.getElementById('game-over-modal').style.display = 'flex';
    const title = document.getElementById('end-title');
    title.innerText = (winner === 'blue' ? "UK / BLUE" : "GER / RED") + " VICTORIOUS";
    title.style.color = winner==='blue' ? '#4488ff' : '#ff4444';
    document.getElementById('end-reason').innerText = reason;
}

// --- LIST & TRAY SYSTEM ---
function toggleListMode(targetMode) {
    currentListMode = (currentListMode === targetMode) ? 'tray' : targetMode;
    document.getElementById('btn-reinf').classList.toggle('active', currentListMode === 'reinforcements');
    document.getElementById('btn-strikes').classList.toggle('active', currentListMode === 'strikes');
    updateDynamicList();
}

function updateDynamicList() {
    const container = document.getElementById('dynamic-list-area');
    container.innerHTML = '';
    let title = "";
    let listData = [];
    
    if(currentPhase === 'SETUP' && currentListMode === 'tray') { title = "SETUP TRAY"; listData = setupTrayUnits; }
    else if (currentListMode === 'tray') { title = "ACTIVE TRAY"; listData = []; }
    else if(currentListMode === 'reinforcements') { title = "REINFORCEMENTS"; listData = reinforcementUnits; }
    else if (currentListMode === 'strikes') { title = "OFF-BOARD STRIKES"; listData = strikes; }

    container.innerHTML = `<div class="panel-header" style="font-size:14px; border-width:1px;">${title}</div>`;

    listData.forEach(item => {
        const div = document.createElement('div');
        div.className = 'list-item';
        if(selectedTrayItem === item) div.classList.add('selected');

        const uTurn = parseInt(item.turn) || 0;
        const isCorrectTurn = (currentPhase === 'SETUP') ? false : (uTurn === currentTurn);
        const isFuture = (currentPhase === 'SETUP' || uTurn > currentTurn);
        const isExpired = (!isFuture && uTurn < currentTurn);

        if(item.isAsset) {
            div.innerHTML = `<div style="font-size:24px;">ðŸš€</div><div class="list-info"><div class="list-title">${item.type.toUpperCase()}</div><div class="list-meta">Turn ${item.turn} (${item.chance}%)</div></div>`;
        } else {
            const info = UNIT_DATA_REGISTRY[item.type];
            let displayName = item.name || (info ? info.name : item.type);
            let imgUrl = info?.image ? `${ASSETS_URL}counters/${info.image}` : `${ASSETS_URL}counters/${item.type}.png`;
            
            let statusText = isCorrectTurn ? `<span style="color:#00ff00">READY TO DEPLOY</span>` : 
                             isFuture ? `<span style="color:#aaa">ARRIVES TURN ${uTurn}</span>` : 
                             `<span style="color:#ff4444">MISSED WINDOW</span>`;
            
            if (item.locType === 'edge') statusText += ` | ${item.locVal} Edge`;
            if (item.facing === undefined) item.facing = 0;

            div.innerHTML = `
                <img src="${imgUrl}" class="list-icon" onerror="this.style.display='none'">
                <div class="list-info">
                    <div class="list-title">${displayName}</div>
                    <div class="list-meta">${statusText}</div>
                    <div class="reinf-rotate-box">
                        <button class="btn-rotate-mini">Rotate</button>
                        <span class="facing-label-mini">Facing: ${FACING_DIRS[item.facing]}</span>
                    </div>
                </div>`;

            if(!isCorrectTurn) div.style.opacity = "0.6";

            div.querySelector('.btn-rotate-mini').onclick = (e) => { e.stopPropagation(); item.facing = (item.facing + 1) % 6; updateDynamicList(); };

            div.onclick = () => {
                if (!isCorrectTurn) { addToLog(`This unit can only be deployed on Turn ${uTurn}.`, "log-info"); return; }
                if(selectedTrayItem === item) { selectedTrayItem = null; isDeploying = false; }
                else { selectedTrayItem = item; isDeploying = true; }
                displayMap(); updateDynamicList();
            };
        }
        container.appendChild(div);
    });
}

function deployTrayUnit(uData, hex) {
    if (currentPhase === 'SETUP' && !setupTrayUnits.includes(uData)) return;
    if (currentPhase !== 'SETUP' && parseInt(uData.turn) !== currentTurn) { addToLog("Deployment window missed!", "log-combat"); return; }
    
    let valid = false;
    if(currentPhase === 'SETUP') {
        if (uData.side === 'blue' && hex.setupZone === 'blue') valid = true;
        if (uData.side === 'red' && hex.setupZone === 'red') valid = true;
    } else {
        if(uData.locType === 'hex') {
            const [tq, tr] = uData.locVal.split(',').map(Number);
            if(hex.q === tq && hex.r === tr) valid = true;
        } else if (uData.locType === 'edge') {
            const side = uData.locVal;
            if(side === 'N' && hex.r === 0) valid = true;
            else if(side === 'S' && hex.r === mapData.rows-1) valid = true;
            else if(side === 'W' && hex.q === 0) valid = true;
            else if(side === 'E' && hex.q === mapData.cols-1) valid = true;
        } else {
            if (uData.side === 'blue' && hex.setupZone === 'blue') valid = true;
            if (uData.side === 'red' && hex.setupZone === 'red') valid = true;
        }
    }

    if (!valid) { addToLog("Invalid Location."); return; }

    const regInfo = UNIT_DATA_REGISTRY[uData.type] || {};
    const stats = regInfo.stats || {};
    const newUnit = {
        id: unitIdCounter++, side: uData.side, type: uData.type, name: uData.name || regInfo.name,
        q: hex.q, r: hex.r, facing: uData.facing || 0, status: 'clear', stance: 'deployed',
        mp: stats.Movement_Points || 6, maxMp: stats.Movement_Points || 6, hp: 5, fp: stats.Firepower || 3, range: stats.Range_Hexes || 6
    };

    units.push(newUnit);
    if(currentPhase === 'SETUP') setupTrayUnits = setupTrayUnits.filter(t => t !== uData);
    else reinforcementUnits = reinforcementUnits.filter(t => t !== uData);
    
    selectedTrayItem = null; isDeploying = false;
    displayMap(); updateDynamicList(); uiUpdate();
    addToLog(`${newUnit.name} deployed.`);
    checkControl(newUnit);
}

// --- TURN SYSTEM ---
function startGameMode(mode) {
    document.getElementById('mode-modal').style.display = 'none';
    currentPhase = 'SETUP';
    isDeploying = true; updateDynamicList(); displayMap(); 
}
function nextPhase() {
    if (currentPhase === 'SETUP') {
        currentPhase = 'Action Phase';
        document.getElementById('btn-phase').innerText = "End Turn";
        isDeploying = false; checkInitialControl(); displayMap();
        toggleListMode('reinforcements');
    } else {
        units.forEach(u => u.mp = u.maxMp);
        currentTurn++;
        if(currentTurn > scenarioData.info.maxTurns) { endGame(scores.blue > scores.red ? 'blue' : 'red', "Time Up"); return; }
        document.getElementById('turn-counter').innerText = currentTurn;
    }
    document.getElementById('phase-display').innerText = currentPhase;
    updateDynamicList(); uiUpdate();
}

// --- STANDARD LOGIC ---
function handleLeftClick(pointer) {
    const hex = getHexAtPoint(pointer.worldX, pointer.worldY);
    if (!hex) return;
    if (losTool) { handleLOSToolClick(hex); return; }
    if (selectedTrayItem) { deployTrayUnit(selectedTrayItem, hex); return; }
    const hexUnits = units.filter(u => u.q === hex.q && u.r === hex.r && u.hp > 0);
    if (currentAction && selectedUnit) {
        if (currentAction === 'FIRE') executeFire(selectedUnit, hexUnits.find(u => u.side !== selectedUnit.side));
        else if (currentAction === 'FACING') changeFacing(selectedUnit, hex);
        else executeMove(selectedUnit, hex);
        return;
    }
    if (hexUnits.length > 0) selectUnitInStack(hexUnits[hexUnits.length - 1]);
    else { selectedUnit = null; selectedHex = hex; uiUpdate(); }
}

function executeMove(unit, targetHex) {
    if (getHexDistance(unit, targetHex) !== 1) return;
    const cost = TERRAIN_TYPES[targetHex.terrain].cost;
    if (currentAction === 'FAST' && unit.mp < cost) return;
    unit.mp = (currentAction === 'TACTICAL') ? 0 : unit.mp - cost;
    unit.q = targetHex.q; unit.r = targetHex.r;
    currentAction = null; uiUpdate(); checkControl(unit);
}

function executeFire(attacker, target) {
    if (!target) return;
    const dist = getPhysicalRange(hexMap[attacker.q][attacker.r], hexMap[target.q][target.r]);
    if (dist > attacker.range) return;
    const los = calculateLOS(hexMap[attacker.q][attacker.r], hexMap[target.q][target.r]);
    if (los.status === 'blocked') return;
    rollD10("FIRE", (roll) => {
        if (roll >= 5) {
            let dmg = attacker.fp + (getTargetSector(attacker, target) === 'REAR' ? 2 : 0);
            target.hp -= Math.max(1, dmg);
            if (target.hp <= 0) units = units.filter(u => u.id !== target.id);
        }
        currentAction = null; uiUpdate();
    });
}

function loadScenario() {
    let txt = document.getElementById('json-input').value.replace(/[\n\r\t]+/g, ' ').trim();
    try {
        scenarioData = JSON.parse(txt); mapData = scenarioData.map;
        units = []; setupTrayUnits = []; reinforcementUnits = [];
        scenarioData.units.tray?.forEach(u => { if (parseInt(u.turn) > 0) reinforcementUnits.push(u); else setupTrayUnits.push(u); });
        scenarioData.units.reinforcements?.forEach(r => reinforcementUnits.push(r));
        document.getElementById('max-turns').innerText = scenarioData.info.maxTurns;
        toggleMapLoader(); document.getElementById('mode-modal').style.display = 'flex';
    } catch (e) { alert('JSON Error'); }
}

// ... WRAPPER FUNCTIONS ...
function getUnitKey(u) { return u.type; }
function getUnitImageURL(u) { return `${ASSETS_URL}counters/${u.type}.png`; }
function uiUpdate() { selectionGraphics.clear(); unitGraphics.clear(); badgeGraphics.clear(); redrawAllUnits(); }
function selectUnitInStack(u) { selectedUnit = u; units.push(units.splice(units.indexOf(u), 1)[0]); uiUpdate(); }
function redrawAllUnits() { 
    Object.values(unitSprites).forEach(s => s.destroy()); unitSprites = {};
    units.forEach(u => {
        const p = getHexPosition(u.q, u.r);
        const s = scene.add.image(p.x, p.y, u.type).setDisplaySize(50,50).setDepth(600);
        unitSprites[u.id] = s;
        drawFacingIndicator(u, p);
    });
}
function drawFacingIndicator(u, p) {
    const rad = Phaser.Math.DegToRad([-90, -30, 30, 90, 150, -150][u.facing]);
    unitGraphics.fillStyle(0xffffff).beginPath().moveTo(p.x+Math.cos(rad)*30, p.y+Math.sin(rad)*30).lineTo(p.x+Math.cos(rad+2.5)*8, p.y+Math.sin(rad+2.5)*8).lineTo(p.x+Math.cos(rad-2.5)*8, p.y+Math.sin(rad-2.5)*8).closePath().fillPath();
}
function toggleLOSTool() { losTool = !losTool; losGraphics.clear(); document.getElementById('btn-los').classList.toggle('active', losTool); }
function handleLOSToolClick(h) { if(!losStartHex) { losStartHex = h; } else { const r = calculateLOS(losStartHex, h); addToLog(r.status.toUpperCase()); losStartHex = null; } }
function selectAction(a) { currentAction = a; }
function changeFacing(u, h) { const p1 = getHexPosition(u.q, u.r), p2 = getHexPosition(h.q, h.r); const ang = Phaser.Math.Angle.Between(p1.x, p1.y, p2.x, p2.y); let best=0, diff=360; [-90, -30, 30, 90, 150, -150].forEach((a, i) => { let d = Math.abs(Phaser.Math.Angle.WrapDegrees(Phaser.Math.RadToDeg(ang)-a)); if(d<diff){diff=d; best=i;} }); u.facing=best; currentAction=null; uiUpdate(); }
function addToLog(m, c="") { const el = document.createElement('div'); el.className=`log-entry ${c}`; el.innerText=m; const log = document.getElementById('log-container'); log.appendChild(el); log.scrollTop=log.scrollHeight; }
function toggleMapLoader() { const m = document.getElementById('json-modal'); m.style.display = (m.style.display==='block')?'none':'block'; }
function displayMap() {
    if(!mapData) return; hexGroup.clear(true, true); zoneGraphics.clear(); hexMap={};
    for(let q=0; q<mapData.cols; q++) { hexMap[q]={}; for(let r=0; r<mapData.rows; r++){ 
        const p = getHexPosition(q, r); hexMap[q][r]={terrain:'clear', x:p.x, y:p.y, q, r};
        drawHex(hexMap[q][r]);
    }}
    mapData.terrain?.forEach(t => { if(hexMap[t.q]?.[t.r]) hexMap[t.q][t.r].terrain = t.type; });
    mapData.zones?.forEach(z => {
        if(!hexMap[z.q]?.[z.r]) return;
        hexMap[z.q][z.r].setupZone = z.side;
        const isZone = !selectedTrayItem || (selectedTrayItem.locType !== 'hex' && selectedTrayItem.locType !== 'edge');
        if(currentPhase==='SETUP' || (isDeploying && isZone && selectedTrayItem.side===z.side)) {
            zoneGraphics.fillStyle(z.side==='blue'?0x4488ff:0xff4444, 0.2);
            const p = getHexPosition(z.q, z.r); const pts=[]; for(let i=0; i<6; i++){ const a=Math.PI/3*i; pts.push({x:p.x+40*Math.cos(a), y:p.y+40*Math.sin(a)}); }
            zoneGraphics.fillPoints(pts, true);
        }
    });
    if(isDeploying && selectedTrayItem?.locType === 'edge') {
        const side = selectedTrayItem.locVal;
        for(let q=0; q<mapData.cols; q++) for(let r=0; r<mapData.rows; r++) {
            if((side==='N'&&r===0)||(side==='S'&&r===mapData.rows-1)||(side==='W'&&q===0)||(side==='E'&&q===mapData.cols-1)) {
                zoneGraphics.fillStyle(selectedTrayItem.side==='blue'?0x4488ff:0xff4444, 0.4);
                const p = getHexPosition(q, r); const pts=[]; for(let i=0; i<6; i++){ const a=Math.PI/3*i; pts.push({x:p.x+40*Math.cos(a), y:p.y+40*Math.sin(a)}); }
                zoneGraphics.fillPoints(pts, true);
            }
        }
    }
    redrawAllUnits();
}
function drawHex(h) { const g = scene.add.graphics().fillStyle(0x555555).lineStyle(1, 0x333333, 0.5).beginPath(); for(let i=0; i<6; i++){ const a=Math.PI/3*i; const x=h.x+40*Math.cos(a), y=h.y+40*Math.sin(a); if(i===0) g.moveTo(x,y); else g.lineTo(x,y); } g.closePath().fillPath().strokePath(); hexGroup.add(g); }
function getHexPosition(q, r) { return { x: q*60, y: r*69.2 + (q%2===1?34.6:0) }; }
function getHexDistance(h1, h2) { return Math.max(Math.abs(h1.q-h2.q), Math.abs(h1.r-h2.r)); }
function getHexAtPoint(x, y) { for(let q in hexMap) for(let r in hexMap[q]) { const h=hexMap[q][r]; if(Math.sqrt((h.x-x)**2+(h.y-y)**2)<40) return h; } return null; }
function getPhysicalRange(h1, h2) { return getHexDistance(h1, h2); }
function getTargetSector(a, t) { return 'FRONT'; }
function calculateLOS(h1, h2) { return { status: 'clear' }; }
</script>
</body>
</html>
