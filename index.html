<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Wargame Engine v0.9.7 - Unit Quality Stars</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        :root {
            --bg-dark: #1e1e1e;
            --bg-panel: #2a2a2a;
            --accent: #d4a017;
            --text-main: #e0e0e0;
            --text-dim: #a0a0a0;
            --border: #444;
        }

        body { 
            margin: 0; padding: 0; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-dark);
            color: var(--text-main);
            height: 100vh;
            display: grid;
            grid-template-columns: 260px 1fr 320px;
            overflow: hidden;
        }

        /* LEFT PANEL */
        #left-panel {
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            z-index: 10;
        }
        .panel-header {
            color: var(--accent);
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
            border-bottom: 2px solid var(--accent);
            padding-bottom: 5px;
        }
        .scenario-box {
            background: #333;
            border: 1px solid var(--border);
            padding: 10px;
            border-radius: 4px;
            font-size: 13px;
            min-height: 80px;
        }
        .turn-display {
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            background: #222;
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 4px;
        }
        .btn {
            background: #444;
            color: var(--text-main);
            border: 1px solid #555;
            padding: 10px;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
            transition: background 0.2s;
            text-align: center;
        }
        .btn:hover { background: #555; border-color: #777; }
        .btn-primary { background: #d4a017; color: #111; border: none; }
        .btn-primary:hover { background: #b88a10; }
        .btn.active { background: var(--accent); color: #000; border-color: var(--accent); }

        /* TRAY STYLES */
        .tray-item {
            display: flex; align-items: center; gap: 10px;
            background: #222; border: 1px solid #444;
            padding: 5px; margin-bottom: 5px; cursor: pointer;
        }
        .tray-item:hover { background: #333; border-color: #666; }
        .tray-item.selected { border-color: var(--accent); background: #332200; }
        .tray-icon { width: 32px; height: 32px; object-fit: contain; }

        /* LOS Sub-buttons */
        .tool-sub-options { display: flex; gap: 5px; margin-top: 5px; }
        .btn-small { padding: 5px; font-size: 11px; flex: 1; }

        /* CENTER MAP */
        #game-container { position: relative; overflow: hidden; background: #111; }

        /* RIGHT PANEL */
        #right-panel {
            background: var(--bg-panel);
            border-left: 1px solid var(--border);
            display: grid;
            grid-template-rows: auto 1fr 200px;
            overflow: hidden;
            z-index: 10;
        }

        /* Unit/Terrain Card */
        #context-card {
            padding: 15px;
            background: #333;
            border-bottom: 1px solid var(--border);
            text-align: center;
            min-height: 140px;
        }
        
        .ctx-header-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 5px;
        }

        .ctx-portrait {
            width: 80px; height: 80px;
            display: flex; align-items: center; justify-content: center;
            background: #222; border-radius: 4px; border: 1px solid #444;
        }
        .ctx-portrait img { width: 100%; height: 100%; object-fit: contain; }

        .ctx-side-info {
            width: 60px;
            font-size: 10px;
            font-weight: bold;
            text-align: center;
            padding: 4px;
            border-radius: 4px;
            background: #222;
            word-wrap: break-word;
            display: flex; align-items: center; justify-content: center;
            min-height: 24px;
        }

        .ctx-title { font-size: 16px; font-weight: bold; color: white; }
        .ctx-subtitle { font-size: 12px; color: var(--accent); margin-bottom: 5px; }
        
        .status-badges { display: flex; gap: 5px; justify-content: center; margin-top: 5px; flex-wrap: wrap; }
        .badge { font-size: 10px; padding: 3px 8px; border-radius: 3px; font-weight: bold; cursor: default; }
        .badge-terrain { cursor: pointer; border: 1px solid rgba(255,255,255,0.2); }
        .badge-terrain:hover { border-color: white; }
        .badge-vp { background: #000; color: #FFD700; border: 1px solid #FFD700; }

        /* Stats Grid */
        #context-stats { padding: 15px; overflow-y: auto; }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            border-bottom: 1px solid #3a3a3a;
            padding: 4px 0;
            font-size: 13px;
        }
        .stat-label { color: var(--text-dim); }
        .stat-value { font-weight: bold; color: white; }

        /* Vertical Stack Selector */
        #stack-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-top: 10px;
        }
        .stack-item {
            cursor: pointer;
            border: 1px solid #444;
            border-radius: 4px;
            background: #222;
            padding: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .stack-item:hover { border-color: var(--accent); background: #333; }
        .stack-img { width: 40px; height: 40px; object-fit: contain; }
        .stack-info { flex-grow: 1; font-size: 11px; text-align: left; }
        .stack-info div { margin-bottom: 2px; }

        /* Log */
        #log-container {
            background: #111;
            border-top: 1px solid var(--accent);
            padding: 10px;
            font-family: 'Consolas', monospace;
            font-size: 11px;
            overflow-y: auto;
            color: #ccc;
        }
        .log-entry { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }
        .log-turn { color: var(--accent); font-weight: bold; margin-top: 8px; }
        .log-combat { color: #ff5555; }
        .log-info { color: #88ccff; }

        #json-modal {
            position: absolute; top: 50px; left: 50px; width: 300px;
            background: #222; border: 2px solid var(--accent); padding: 15px;
            z-index: 2000; display: none;
        }
    </style>
</head>
<body>

<div id="left-panel">
    <div class="panel-header">SCENARIO</div>
    <div class="scenario-box" id="scenario-info-box">
        <strong style="color:white">Battle of the Ridge</strong><br>
        <span style="color:#aaa">Scenario: Default</span><br>
        <p style="margin:5px 0 0 0; color:#888; font-style:italic">Load map to initialize...</p>
    </div>

    <div class="turn-display">
        TURN: <span id="turn-counter">1</span> / <span id="max-turns">-</span><br>
        <span style="color: var(--accent); font-size:12px;" id="phase-display">WAITING</span>
    </div>

    <button class="btn btn-primary" id="btn-phase" onclick="nextPhase()">Start Game</button>
    
    <div id="left-content-area" style="flex-grow:1; overflow-y:auto; margin-top:10px;"></div>
    
    <div class="panel-header" style="margin-top:10px">TOOLS</div>
    
    <div>
        <button class="btn" id="btn-los" style="width:100%" onclick="toggleLOSTool()">Line of Sight Tool</button>
        <div id="los-options" class="tool-sub-options" style="display:none;">
            <button id="los-inf" class="btn btn-small active" onclick="setLOSType('infantry')">Infantry Height</button>
            <button id="los-veh" class="btn btn-small" onclick="setLOSType('vehicle')">Vehicle Height</button>
        </div>
    </div>
    
    <button class="btn" onclick="toggleMapLoader()">Load Scenario JSON</button>
</div>

<div id="game-container">
    <div id="json-modal">
        <textarea id="json-input" rows="6" style="width:100%; background:#111; color:#fff; border:1px solid #444;" placeholder="Paste Scenario JSON..."></textarea>
        <button class="btn btn-primary" style="width:100%; margin-top:5px;" onclick="loadScenario()">Load</button>
        <button class="btn" style="width:100%; margin-top:5px;" onclick="toggleMapLoader()">Close</button>
    </div>
</div>

<div id="right-panel">
    
    <div id="context-card">
        <div class="ctx-header-row">
            <div id="ctx-status-left" class="ctx-side-info" style="color:#aaa;">-</div>
            <div class="ctx-portrait" id="ctx-img"></div>
            <div id="ctx-stance-right" class="ctx-side-info" style="color:#aaa;">-</div>
        </div>

        <div id="ctx-quality" style="color:#ffd700; font-size:16px; margin-bottom:5px; line-height:1;"></div>

        <div class="ctx-title" id="ctx-title">No Selection</div>
        <div class="ctx-subtitle" id="ctx-subtitle">-</div>
        <div class="status-badges" id="ctx-badges"></div>

        <div id="unit-actions" style="margin-top:10px; display:none; gap:5px; grid-template-columns: 1fr 1fr;">
            <button class="btn btn-game" style="padding:5px" onclick="selectAction('TACTICAL')">Tactical</button>
            <button class="btn btn-game" style="padding:5px" onclick="selectAction('FAST')">Fast</button>
            <button class="btn btn-game" style="padding:5px" onclick="selectAction('FACING')">Face</button>
            <button class="btn btn-game" style="padding:5px; border-color:#ff5555; color:#ff5555" onclick="selectAction('FIRE')">FIRE</button>
            
            <button class="btn btn-setup" style="padding:5px; display:none" onclick="selectAction('FACING')">Rotate</button>
            <button class="btn btn-setup" style="padding:5px; border-color:#ffaa00; color:#ffaa00; display:none" onclick="redeployUnit()">Redeploy</button>
        </div>
    </div>

    <div id="context-stats">
        <div class="panel-header" style="font-size:14px; border-width:1px;" id="stats-header">STATISTICS</div>
        <div id="stats-content"></div>
        
        <div id="stack-container" style="display:none; margin-top:15px;">
            <div class="panel-header" style="font-size:14px; border-width:1px;">STACK (Top First)</div>
            <div id="stack-list"></div>
        </div>
    </div>

    <div id="log-container">
        <div class="log-entry">System initialized.</div>
    </div>
</div>

<script>
// --- Configuration ---
const ASSETS_URL = 'https://raw.githubusercontent.com/trainJapan/HexWargame/main/artwork/';

// --- DYNAMIC FILE LIST ---
const UNIT_FILES = [
    "UK_S_Rifle_Squad.png",
    "GER_S_Rifle_Squad.png",
    "UK_V_M3_Stuart.png",
    "GER_V_Schwerer_Panzerspähwagen.png",
    "UK_WT_HMG_Team.png",
    "GER_WT_HMG_Team.png",
    "UK_WT_PIAT_Team.png",
    "GER_HWT_Leichtes_Infanteriegeschütz.png"
];

// Registry to store parsed data (Name, Side, Category)
const UNIT_DATA_REGISTRY = {};

const TERRAIN_TYPES = {
    'clear':      { color: 0x98FB98, los: 'clear',     cost: 1,   terrainHeight: 0, infantryUsable: 0, vehicleUsable: 0 },
    'fields':     { color: 0xCCAA00, los: 'degrading', cost: 1,   terrainHeight: 1, infantryUsable: 0, vehicleUsable: 0 },
    'beach':      { color: 0xFFFF99, los: 'clear',     cost: 1,   terrainHeight: 0, infantryUsable: 0, vehicleUsable: 0 },
    'broken':     { color: 0x8B4513, los: 'degrading', cost: 2,   terrainHeight: 1, infantryUsable: 0, vehicleUsable: 0 },
    'orchard':    { color: 0x00FF00, los: 'degrading', cost: 2,   terrainHeight: 1, infantryUsable: 0, vehicleUsable: 0 },
    'rural':      { color: 0xFF9999, los: 'degrading', cost: 2,   terrainHeight: 1, infantryUsable: 0, vehicleUsable: 0 },
    'forest':     { color: 0x228B22, los: 'blocking',  cost: 3,   terrainHeight: 2, infantryUsable: 0, vehicleUsable: 0 },
    'urban':      { color: 0xCC0000, los: 'blocking',  cost: 3,   terrainHeight: 2, infantryUsable: 2, vehicleUsable: 0 },
    'industrial': { color: 0x808080, los: 'blocking',  cost: 3,   terrainHeight: 2, infantryUsable: 2, vehicleUsable: 0 },
    'water':      { color: 0x4169E1, los: 'clear',     cost: 999, terrainHeight: 0, infantryUsable: 0, vehicleUsable: 0 },
    'hill':       { color: 0x8B7355, los: 'degrading', cost: 2,   terrainHeight: 2, infantryUsable: 2, vehicleUsable: 2 }
};

const HEX_RADIUS = 40;

// Game State
let scenarioData = null; 
let mapData = null; 
let losTool = false;
let losStartHex = null;
let losUnitType = 'infantry';
let units = [];
let trayUnits = []; 
let unitIdCounter = 2000;
let currentTurn = 1;
let currentPhase = 'SETUP'; 

// Selection State
let selectedUnit = null; 
let selectedHex = null; 
let selectedTrayUnit = null; 
let currentAction = null; 

// Phaser Objects
let scene, hexGroup, zoneGraphics, objGraphics, roadGraphics, losGraphics, unitGraphics, selectionGraphics, badgeGraphics, hexMap = {};
let unitSprites = {};
let objectiveSprites = []; 

// --- Phaser Config ---
const config = {
    type: Phaser.AUTO,
    parent: 'game-container',
    width: window.innerWidth - 580,
    height: window.innerHeight,
    backgroundColor: '#1a1a1a',
    scene: { preload: preloadScene, create: createScene, update: updateScene }
};

const game = new Phaser.Game(config);

// --- PARSING HELPER ---
function parseUnitFromFileName(filename) {
    const nameOnly = filename.replace(/\.[^/.]+$/, "");
    const parts = nameOnly.split('_');

    // Default 
    let side = 'neutral';
    let category = 'squad';
    let unitName = nameOnly;
    let type = 'infantry';

    if (parts.length >= 3) {
        const sideCode = parts[0].toUpperCase();
        const catCode = parts[1].toUpperCase();
        
        // Rejoin the rest with SPACES instead of underscores
        unitName = parts.slice(2).join(' ');

        if (sideCode === 'GER') side = 'red';
        if (sideCode === 'UK' || sideCode === 'US') side = 'blue';

        switch (catCode) {
            case 'S': category = 'squad'; type='infantry'; break;
            case 'T': category = 'team'; type='infantry'; break;
            case 'WT': category = 'team'; type='infantry'; break;
            case 'HWT': category = 'hwt'; type='vehicle'; break;
            case 'V': category = 'vehicle'; type='vehicle'; break;
        }
    }

    return {
        key: nameOnly,
        side: side,
        category: category,
        name: unitName,
        heightType: type
    };
}

function preloadScene() {
    for (const [key, value] of Object.entries(TERRAIN_TYPES)) {
        for (let i = 1; i <= 3; i++) { this.load.image(`${key}${i}`, `${ASSETS_URL}map/${key}${i}.png`); }
    }
    
    // Dynamic Unit Loading
    UNIT_FILES.forEach(filename => {
        const info = parseUnitFromFileName(filename);
        this.load.image(info.key, `${ASSETS_URL}counters/${filename}`);
        UNIT_DATA_REGISTRY[info.key] = info;
    });
    
    // Fallback texture just in case
    this.make.graphics({x:0,y:0,add:false}).fillStyle(0xffffff).fillRect(0,0,1,1).generateTexture('fallback', 1, 1);
}

function createScene() {
    scene = this;
    hexGroup = this.add.group(); 
    zoneGraphics = this.add.graphics().setDepth(20); 
    roadGraphics = this.add.graphics().setDepth(100);
    objGraphics = this.add.graphics().setDepth(150); 
    
    selectionGraphics = this.add.graphics().setDepth(500); 
    losGraphics = this.add.graphics().setDepth(550);       
    
    unitGraphics = this.add.graphics().setDepth(700);      
    badgeGraphics = this.add.graphics().setDepth(800);     
    
    this.cameras.main.setBounds(-2000, -2000, 8000, 8000); 
    this.input.mouse.disableContextMenu();
    
    this.input.on('wheel', (pointer, gameObjects, deltaX, deltaY) => {
        const zoom = scene.cameras.main.zoom - (deltaY * 0.001);
        scene.cameras.main.setZoom(Phaser.Math.Clamp(zoom, 0.3, 2));
    });
    
    this.input.on('pointerdown', (pointer) => {
        if (pointer.leftButtonDown()) handleLeftClick(pointer);
        if (pointer.rightButtonDown()) {
            if (currentAction) {
                currentAction = null;
                uiUpdate();
                addToLog("Action cancelled.", "log-info");
            }
            if (selectedTrayUnit) {
                selectedTrayUnit = null; 
                renderTray();
            }
        }
    });
}

function updateScene() {
    if (this.input.activePointer.rightButtonDown()) {
        const pointer = this.input.activePointer;
        this.cameras.main.scrollX -= (pointer.x - pointer.prevPosition.x) / this.cameras.main.zoom;
        this.cameras.main.scrollY -= (pointer.y - pointer.prevPosition.y) / this.cameras.main.zoom;
    }
}

// --- Helper: Asset Keys & Logic ---
function getUnitKey(unit) {
    // 1. Try exact type match from loaded files
    if (unit.unitType && scene.textures.exists(unit.unitType)) {
        return unit.unitType;
    }
    // 2. Try 'type' field from editor JSON
    if (unit.type && scene.textures.exists(unit.type)) {
        return unit.type;
    }
    return 'fallback';
}

function getUnitImageURL(unit) {
    const key = getUnitKey(unit);
    return `${ASSETS_URL}counters/${key}.png`;
}

// --- UI Logic ---

function uiUpdate() {
    selectionGraphics.clear(); 
    unitGraphics.clear();
    badgeGraphics.clear();
    
    scene.children.list.filter(c => c.name === 'badgeText').forEach(c => c.destroy());

    redrawAllUnits(); 
    
    if (!selectedUnit && selectedHex) {
        selectionGraphics.lineStyle(3, 0xffffff, 1);
        selectionGraphics.strokeCircle(selectedHex.x, selectedHex.y, HEX_RADIUS - 5);
    }

    if (selectedUnit) {
        showUnitPanel(selectedUnit);
    } else if (selectedHex) {
        showTerrainPanel(selectedHex);
    } else {
        clearContextPanel();
    }
}

function showUnitPanel(unit) {
    document.getElementById('ctx-img').innerHTML = `<img src="${getUnitImageURL(unit)}">`;
    const side = unit.side === 'blue' ? 'UK' : 'German';
    
    // Priority: Specific Name > Generated Name
    let titleText = unit.name; 
    if (!titleText) {
        let catName = unit.category ? unit.category.charAt(0).toUpperCase() + unit.category.slice(1) : "Unit";
        titleText = `${side} ${catName}`;
    }

    document.getElementById('ctx-title').innerText = titleText;
    
    // --- UPDATED SUBTITLE LOGIC ---
    let subText = "UNIT";
    const cat = (unit.category || "").toLowerCase();
    
    if (cat === 'squad') subText = "RIFLE SQUAD";
    else if (cat === 'team') subText = "WEAPON TEAM";
    else if (cat === 'hwt') subText = "HEAVY WEAPON TEAM";
    else if (cat === 'vehicle') subText = "VEHICLE";
    
    document.getElementById('ctx-subtitle').innerText = subText;
    // -----------------------------
    
    // --- QUALITY STARS ---
    let qStars = "★★"; // Default Regular
    let q = unit.quality || 'regular';
    if(q === 'low') qStars = "★";
    else if(q === 'elite') qStars = "★★★";
    document.getElementById('ctx-quality').innerText = qStars;

    document.getElementById('unit-actions').style.display = 'grid';

    // -- LEFT STATUS TEXT --
    const leftEl = document.getElementById('ctx-status-left');
    let sColor = '#aaa'; let sText = "OPERATIONAL";
    
    if(unit.status === 'clear') { 
        sColor='#fff'; 
        sText="OPERATIONAL"; 
    }
    else if(unit.status === 'shaken') { 
        sColor='#ff4444'; 
        sText="SHAKEN"; 
    }
    else if(unit.status === 'damaged') { 
        sColor='#cc00cc'; 
        sText="DAMAGED"; 
    }
    else if(unit.status === 'immobilized') { 
        sColor='#cc00cc'; 
        sText="IMMOBILIZED"; 
    }
    else if(unit.status.startsWith('suppressed')) { 
        sColor='#ffff00'; 
        sText="SUPPRESSED +" + unit.status.split('_')[1]; 
    }
    
    leftEl.innerText = sText;
    leftEl.style.color = sColor;
    leftEl.style.border = `1px solid ${sColor}`;

    // -- RIGHT STANCE TEXT --
    const rightEl = document.getElementById('ctx-stance-right');
    
    let stTextVal = unit.stance || 'deployed';
    if(unit.stance === 'cover') stTextVal = 'Cover';
    if(unit.stance === 'setup') stTextVal = 'Set Up';
    if(unit.stance === 'moving') stTextVal = 'Moving';
    
    let stColor = '#fff';
    if(unit.stance === 'moving') stColor = '#0055ff';
    else if(unit.stance === 'deployed') stColor = '#ff0000';
    else if(unit.stance === 'cover' || unit.stance === 'setup') stColor = '#ff8095';
    
    rightEl.innerText = stTextVal.toUpperCase();
    rightEl.style.color = stColor;
    rightEl.style.border = `1px solid ${stColor}`;

    if (currentPhase === 'SETUP') {
        document.querySelectorAll('.btn-game').forEach(b => b.style.display = 'none');
        if (!unit.isFixed) {
            document.querySelectorAll('.btn-setup').forEach(b => b.style.display = 'block');
        } else {
            document.querySelectorAll('.btn-setup').forEach(b => b.style.display = 'none');
        }
    } else {
        document.querySelectorAll('.btn-game').forEach(b => b.style.display = 'block');
        document.querySelectorAll('.btn-setup').forEach(b => b.style.display = 'none');
    }

    const badgeContainer = document.getElementById('ctx-badges');
    badgeContainer.innerHTML = '';
    
    if (unit.isFixed && currentPhase === 'SETUP') {
        const b = document.createElement('span'); b.className = 'badge'; b.style.background = '#555'; b.innerText = 'FIXED';
        badgeContainer.appendChild(b);
    }

    const hex = hexMap[unit.q][unit.r];
    const terrain = hex.terrain;
    const tProps = TERRAIN_TYPES[terrain];
    const tBadge = document.createElement('span');
    tBadge.className = 'badge badge-terrain';
    tBadge.innerText = terrain.toUpperCase();
    tBadge.style.backgroundColor = '#' + tProps.color.toString(16);
    tBadge.style.color = (tProps.color > 0x888888) ? '#000' : '#fff';
    tBadge.onclick = () => { selectedUnit = null; selectedHex = hexMap[unit.q][unit.r]; uiUpdate(); };
    badgeContainer.appendChild(tBadge);

    if (hex.victoryPoints) {
        const vpBadge = document.createElement('span');
        vpBadge.className = 'badge badge-vp';
        vpBadge.innerText = `VP: ${hex.victoryPoints}`;
        badgeContainer.appendChild(vpBadge);
    }

    if (unit.hp < 5) {
        const b = document.createElement('span'); b.className = 'badge badge-damage'; b.innerText = `DMG -${5-unit.hp}`;
        badgeContainer.appendChild(b);
    }

    const statsHtml = `
        <div class="stat-row"><span class="stat-label">Morale:</span> <span class="stat-value">Steady</span></div>
        <div class="stat-row"><span class="stat-label">MP:</span> <span class="stat-value">${unit.mp}/${unit.maxMp}</span></div>
        <div class="stat-row"><span class="stat-label">Firepower:</span> <span class="stat-value">${unit.fp}</span></div>
        <div class="stat-row"><span class="stat-label">Range:</span> <span class="stat-value">${unit.range}</span></div>
        <div class="stat-row"><span class="stat-label">Facing:</span> <span class="stat-value">${["N","NE","SE","S","SW","NW"][unit.facing]}</span></div>
    `;
    document.getElementById('stats-header').innerText = 'UNIT STATISTICS';
    document.getElementById('stats-content').innerHTML = statsHtml;

    const stack = units.filter(u => u.q === unit.q && u.r === unit.r && u.hp > 0);
    const stackDiv = document.getElementById('stack-container');
    const stackList = document.getElementById('stack-list');
    
    if (stack.length > 1) {
        stackDiv.style.display = 'block';
        stackList.innerHTML = '';
        const renderStack = [...stack].reverse();
        renderStack.forEach(u => {
            const item = document.createElement('div');
            item.className = 'stack-item';
            if (u === unit) item.style.borderColor = 'var(--accent)';
            const facingDir = ["N","NE","SE","S","SW","NW"][u.facing];
            
            // Resolve Stance for Stack List
            let stText = "Deployed";
            if(u.stance === 'moving') stText = "Moving";
            else if(u.stance === 'cover') stText = "Cover";
            else if(u.stance === 'setup') stText = "Set Up";
            else if(u.stance === 'deployed') stText = "Deployed";
            
            // Resolve Status for Stack List
            let statText = "Operational";
            let statColor = "#fff";
            if(u.status === 'shaken') { statText="Shaken"; statColor="#ff4444"; }
            else if(u.status === 'damaged') { statText="Damaged"; statColor="#cc00cc"; }
            else if(u.status === 'immobilized') { statText="Immobilized"; statColor="#cc00cc"; }
            else if(u.status.startsWith('suppressed')) { 
                statText="Suppressed +" + u.status.split('_')[1]; 
                statColor="#ffff00"; 
            }

            let stackName = u.name || u.category.toUpperCase();

            item.innerHTML = `
                <img class="stack-img" src="${getUnitImageURL(u)}">
                <div class="stack-info">
                    <div style="font-weight:bold; color:white;">${stackName}</div>
                    <div>MP: ${u.mp} | Face: ${facingDir}</div>
                    <div>Stance: ${stText}</div>
                    <div style="color:${statColor}; font-weight:bold; font-size:10px;">Status: ${statText}</div>
                </div>
            `;
            item.onclick = () => { selectUnitInStack(u); };
            stackList.appendChild(item);
        });
    } else {
        stackDiv.style.display = 'none';
    }
}

function showTerrainPanel(hex) {
    const terrain = hex.terrain;
    const props = TERRAIN_TYPES[terrain];
    const variant = hex.variant || 1;
    const imgUrl = `${ASSETS_URL}map/${terrain}${variant}.png`;
    document.getElementById('ctx-img').innerHTML = `<img src="${imgUrl}">`;
    document.getElementById('ctx-title').innerText = terrain.toUpperCase();
    document.getElementById('ctx-subtitle').innerText = `COORD: ${hex.q}, ${hex.r}`;
    document.getElementById('unit-actions').style.display = 'none';
    
    document.getElementById('ctx-status-left').innerText = ""; document.getElementById('ctx-status-left').style.border="none";
    document.getElementById('ctx-stance-right').innerText = ""; document.getElementById('ctx-stance-right').style.border="none";
    
    // Clear stars for terrain
    document.getElementById('ctx-quality').innerText = "";

    const badgeContainer = document.getElementById('ctx-badges');
    badgeContainer.innerHTML = '';
    const tBadge = document.createElement('span');
    tBadge.className = 'badge badge-terrain';
    tBadge.innerText = terrain.toUpperCase();
    tBadge.style.backgroundColor = '#' + props.color.toString(16);
    tBadge.style.color = (props.color > 0x888888) ? '#000' : '#fff';
    badgeContainer.appendChild(tBadge);

    if (hex.victoryPoints) {
        const vpBadge = document.createElement('span');
        vpBadge.className = 'badge badge-vp';
        vpBadge.innerText = `VP: ${hex.victoryPoints}`;
        badgeContainer.appendChild(vpBadge);
    }
    
    document.getElementById('stack-container').style.display = 'none';
    const statsHtml = `
        <div class="stat-row"><span class="stat-label">Move Cost:</span> <span class="stat-value">${props.cost}</span></div>
        <div class="stat-row"><span class="stat-label">Height:</span> <span class="stat-value">${props.terrainHeight}</span></div>
        <div class="stat-row"><span class="stat-label">LOS Effect:</span> <span class="stat-value">${props.los.toUpperCase()}</span></div>
        <div class="stat-row"><span class="stat-label">Infantry Ht:</span> <span class="stat-value">${props.infantryUsable}</span></div>
        <div class="stat-row"><span class="stat-label">Vehicle Ht:</span> <span class="stat-value">${props.vehicleUsable}</span></div>
    `;
    document.getElementById('stats-header').innerText = 'TERRAIN DATA';
    document.getElementById('stats-content').innerHTML = statsHtml;
}

function clearContextPanel() {
    document.getElementById('ctx-img').innerHTML = '';
    document.getElementById('ctx-title').innerText = 'No Selection';
    document.getElementById('ctx-subtitle').innerText = '-';
    document.getElementById('ctx-badges').innerHTML = '';
    document.getElementById('ctx-quality').innerText = '';
    document.getElementById('unit-actions').style.display = 'none';
    document.getElementById('stats-content').innerHTML = '';
    document.getElementById('stack-container').style.display = 'none';
    document.getElementById('ctx-status-left').innerText = ""; document.getElementById('ctx-status-left').style.border="none";
    document.getElementById('ctx-stance-right').innerText = ""; document.getElementById('ctx-stance-right').style.border="none";
}

function selectUnitInStack(unit) {
    selectedUnit = unit;
    selectedHex = null; 
    units = units.filter(u => u !== unit);
    units.push(unit);
    uiUpdate();
}

// --- Interaction Logic ---

function handleLeftClick(pointer) {
    const hex = getHexAtPoint(pointer.worldX, pointer.worldY);
    if (!hex) { selectedUnit = null; selectedHex = null; uiUpdate(); return; }

    if (losTool) { handleLOSToolClick(hex); return; }

    if (currentPhase === 'SETUP' && selectedTrayUnit) {
        deployTrayUnit(selectedTrayUnit, hex);
        return;
    }

    const hexUnits = units.filter(u => u.q === hex.q && u.r === hex.r && u.hp > 0);

    if (currentAction && selectedUnit) {
        if (currentAction === 'FIRE') {
            const target = hexUnits.find(u => u.side !== selectedUnit.side);
            executeFire(selectedUnit, target);
        } else if (currentAction === 'FACING') {
            changeFacing(selectedUnit, hex);
        } else {
            executeMove(selectedUnit, hex);
        }
        return;
    }

    if (hexUnits.length > 0) {
        const topUnit = hexUnits[hexUnits.length - 1];
        selectUnitInStack(topUnit);
    } else {
        selectedUnit = null;
        selectedHex = hex;
        uiUpdate();
    }
}

// --- SETUP PHASE FUNCTIONS ---

function renderTray() {
    const container = document.getElementById('left-content-area');
    container.innerHTML = '<div class="panel-header" style="font-size:14px; border-width:1px;">SETUP TRAY</div>';
    
    if (trayUnits.length === 0) {
        container.innerHTML += '<div style="color:#666; font-style:italic; padding:10px;">Tray Empty.</div>';
        return;
    }

    trayUnits.forEach(u => {
        const item = document.createElement('div');
        item.className = 'tray-item';
        if (selectedTrayUnit === u) item.classList.add('selected');
        
        let displayName = u.name || u.category || u.type;
        
        // Use type (filename) as key if available
        let imgKey = u.type || u.unitType;
        if (!scene.textures.exists(imgKey)) imgKey = 'fallback';

        item.innerHTML = `
            <img src="${ASSETS_URL}counters/${imgKey}.png" class="tray-icon">
            <div>
                <div style="font-weight:bold; font-size:12px; color:#fff">${displayName}</div>
                <div style="font-size:10px; color:#aaa">Click map to deploy</div>
            </div>
        `;
        item.onclick = () => {
            if (selectedTrayUnit === u) {
                selectedTrayUnit = null; 
                renderTray();
            } else {
                selectedTrayUnit = u;
                selectedUnit = null; 
                renderTray(); 
                addToLog("Select a valid Zone Hex to deploy.", "log-info");
            }
        };
        container.appendChild(item);
    });
}

function deployTrayUnit(uData, hex) {
    let valid = false;
    if (uData.side === 'blue' && hex.setupZone === 'blue') valid = true;
    if (uData.side === 'red' && hex.setupZone === 'red') valid = true;

    if (!valid) {
        addToLog(`Invalid Deployment! Must be in ${uData.side.toUpperCase()} Zone.`, "log-combat");
        return;
    }

    // New Unit: Forces Stance=Deployed, Status=Clear
    const newUnit = {
        id: unitIdCounter++,
        side: uData.side,
        unitType: uData.type, // Store the specific file key
        category: uData.category || 'squad',
        name: uData.name, // Preserve name
        quality: uData.quality || 'regular', // Preserve Quality
        q: hex.q, r: hex.r,
        facing: 0, 
        status: 'clear', 
        stance: 'deployed',
        mp: 6, maxMp: 6, hp: 5, fp: 3, range: 6,
        isFixed: false
    };

    // Stance Logic fix for HWT if needed later
    
    units.push(newUnit);
    
    trayUnits = trayUnits.filter(t => t !== uData);
    selectedTrayUnit = null;
    
    selectUnitInStack(newUnit);
    displayMap(); 
    renderTray(); 
    uiUpdate();
    addToLog(`${newUnit.name || newUnit.category} deployed.`);
}

function redeployUnit() {
    if (!selectedUnit || currentPhase !== 'SETUP' || selectedUnit.isFixed) return;
    const trayObj = {
        id: selectedUnit.id, 
        side: selectedUnit.side,
        type: selectedUnit.unitType,
        category: selectedUnit.category,
        name: selectedUnit.name,
        quality: selectedUnit.quality
    };
    trayUnits.push(trayObj);
    units = units.filter(u => u !== selectedUnit);
    selectedUnit = null;
    displayMap();
    renderTray();
    uiUpdate();
    addToLog("Unit returned to Tray.");
}

// --- Rendering ---

function redrawAllUnits() {
    Object.values(unitSprites).forEach(sprite => sprite.destroy());
    unitSprites = {};
    
    const stackCounts = {};
    units.forEach(u => {
        if(u.hp <= 0) return;
        const key = `${u.q},${u.r}`;
        stackCounts[key] = (stackCounts[key] || 0) + 1;
    });

    units.forEach(unit => {
        if (unit.hp <= 0) return;
        const pos = getHexPosition(unit.q, unit.r);
        
        const key = getUnitKey(unit);
        if (scene.textures.exists(key)) {
            const sprite = scene.add.image(pos.x, pos.y, key);
            sprite.setDisplaySize(HEX_RADIUS * 1.25, HEX_RADIUS * 1.25);
            sprite.setDepth(600); 
            unitSprites[unit.id] = sprite;
        }

        drawFacingIndicator(unit, pos);

        const isTop = (units.filter(u => u.q === unit.q && u.r === unit.r).pop() === unit);
        const count = stackCounts[`${unit.q},${unit.r}`];
        
        if (count > 1 && isTop) {
            const badgeX = pos.x + 10; 
            const badgeY = pos.y - 18;
            badgeGraphics.fillStyle(0xffffff, 1);
            badgeGraphics.fillRect(badgeX, badgeY, 16, 14);
            badgeGraphics.lineStyle(1, 0x000000, 1);
            badgeGraphics.strokeRect(badgeX, badgeY, 16, 14);
            scene.add.text(badgeX + 8, badgeY + 7, `+${count-1}`, { 
                font: '11px Arial', fill: '#000', fontStyle:'bold'
            }).setOrigin(0.5).setDepth(810).setResolution(2).setName('badgeText');
        }

        if (isTop) drawStatusMarkers(unit, pos);
    });

    // Draw Selection Ring - WORST CASE LOGIC
    if (selectedUnit || selectedHex) {
        // Find which hex is active
        const activeHex = selectedUnit ? hexMap[selectedUnit.q][selectedUnit.r] : selectedHex;
        if(activeHex) {
            const hexUnits = units.filter(u => u.q === activeHex.q && u.r === activeHex.r);
            if(hexUnits.length > 0) {
                // Determine Ring Color based on hierarchy
                let ringColor = 0xffffff; // Default White
                let worstLevel = 0; // 0=Clear, 1=Yellow, 2=Red, 3=Purple
                
                hexUnits.forEach(u => {
                    let lvl = 0;
                    if(u.status.startsWith('suppressed')) lvl = 1;
                    if(u.status === 'shaken') lvl = 2;
                    if(u.status === 'damaged' || u.status === 'immobilized') lvl = 3;
                    if(lvl > worstLevel) worstLevel = lvl;
                });
                
                if(worstLevel === 1) ringColor = 0xffff00; // Yellow
                if(worstLevel === 2) ringColor = 0xff0000; // Red
                if(worstLevel === 3) ringColor = 0xcc00cc; // Purple

                const p = getHexPosition(activeHex.q, activeHex.r);
                selectionGraphics.lineStyle(3, ringColor, 1);
                selectionGraphics.strokeCircle(p.x, p.y, HEX_RADIUS * 0.7);
            }
        }
    }
}

function drawFacingIndicator(unit, pos) {
    const facingAngles = [-90, -30, 30, 90, 150, -150];
    const angleRad = Phaser.Math.DegToRad(facingAngles[unit.facing]);
    const indicatorDist = HEX_RADIUS * 0.75; 
    const triX = pos.x + Math.cos(angleRad) * indicatorDist;
    const triY = pos.y + Math.sin(angleRad) * indicatorDist;

    // Stance Colors
    let triColor = 0xffffff;
    if(unit.stance === 'moving') triColor = 0x0055ff;
    else if(unit.stance === 'deployed') triColor = 0xff0000;
    else if(unit.stance === 'cover' || unit.stance === 'setup') triColor = 0xff8095;

    unitGraphics.fillStyle(triColor, 1);
    const size = 8;
    unitGraphics.beginPath();
    unitGraphics.moveTo(triX + Math.cos(angleRad)*size, triY + Math.sin(angleRad)*size);
    unitGraphics.lineTo(triX + Math.cos(angleRad+2.5)*size, triY + Math.sin(angleRad+2.5)*size);
    unitGraphics.lineTo(triX + Math.cos(angleRad-2.5)*size, triY + Math.sin(angleRad-2.5)*size);
    unitGraphics.closePath();
    unitGraphics.fillPath();
}

function drawStatusMarkers(unit, pos) {
    if (unit.status !== 'clear') {
        const bx = pos.x + 15; 
        const by = pos.y + 15;
        let statColor = 0xffffff;
        let label = "!";
        
        if(unit.status === 'suppressed_2') { statColor = 0xffff00; label="+2"; }
        else if(unit.status === 'suppressed_4') { statColor = 0xffff00; label="+4"; }
        else if(unit.status === 'suppressed_6') { statColor = 0xffff00; label="+6"; }
        else if(unit.status === 'shaken') { statColor = 0xff0000; label="!"; }
        else if(unit.status === 'damaged') { statColor = 0x8800cc; label="X"; }
        else if(unit.status === 'immobilized') { statColor = 0x8800cc; label="I"; }

        badgeGraphics.fillStyle(statColor, 1);
        badgeGraphics.fillRect(bx - 8, by - 6, 16, 12);
        badgeGraphics.lineStyle(1, 0x000000, 1);
        badgeGraphics.strokeRect(bx - 8, by - 6, 16, 12);
        
        scene.add.text(bx, by, label, { 
            font: '9px Arial', fill: '#000', fontStyle: 'bold'
        }).setOrigin(0.5).setDepth(810).setResolution(2).setName('badgeText');
    }
}

// --- LOS Tool Logic ---

function toggleLOSTool() {
    losTool = !losTool;
    losStartHex = null;
    losGraphics.clear();
    const container = document.getElementById('los-options');
    container.style.display = losTool ? 'flex' : 'none';
    document.getElementById('btn-los').classList.toggle('active', losTool);

    if (losTool) {
        if (selectedUnit) {
            losStartHex = hexMap[selectedUnit.q][selectedUnit.r];
            // Infer LOS type from unit category
            let cat = selectedUnit.category || 'squad';
            let lType = (cat==='vehicle' || cat==='hwt') ? 'vehicle' : 'infantry';
            setLOSType(lType); 
            highlightHex(losStartHex, 0xffffff);
            addToLog(`LOS Start: Unit at ${losStartHex.q},${losStartHex.r}`, "log-info");
        } else if (selectedHex) {
            losStartHex = selectedHex;
            highlightHex(losStartHex, 0xffffff);
            addToLog(`LOS Start: Terrain at ${losStartHex.q},${losStartHex.r}`, "log-info");
        } else {
            addToLog("LOS Tool: Select Start Hex...", "log-info");
        }
    } else {
        addToLog("LOS Tool Deactivated.", "log-info");
        uiUpdate(); 
    }
}

function setLOSType(type) {
    losUnitType = type;
    document.getElementById('los-inf').classList.toggle('active', type === 'infantry');
    document.getElementById('los-veh').classList.toggle('active', type === 'vehicle');
}

function handleLOSToolClick(hex) {
    if (!losStartHex) {
        losStartHex = hex;
        highlightHex(hex, 0xffffff);
        addToLog("Start Hex selected. Select Target...", "log-info");
    } else {
        const result = calculateLOS(losStartHex, hex, losUnitType);
        let color = 0xff0000; let txt = "BLOCKED";
        if(result.status === 'clear') { color = 0x00ff00; txt = "CLEAR"; }
        if(result.status === 'degraded') { color = 0xffaa00; txt = "DEGRADED"; }
        drawVisualLOSLine(losStartHex, hex, color);
        addToLog(`LOS Result: ${txt} ${result.isRoad ? '(Road)' : ''}`);
    }
}

// --- Action Logic ---
function selectAction(action) {
    currentAction = action;
    if (action === 'FIRE') addToLog(`Select target...`, "log-info");
    else if (action === 'FACING') addToLog(`Select direction...`, "log-info");
    else addToLog(`Select destination...`, "log-info");
}

function changeFacing(unit, targetHex) {
    if (unit.q === targetHex.q && unit.r === targetHex.r) return;
    const startPos = getHexPosition(unit.q, unit.r);
    const targetPos = getHexPosition(targetHex.q, targetHex.r);
    const angleRad = Phaser.Math.Angle.Between(startPos.x, startPos.y, targetPos.x, targetPos.y);
    let angleDeg = Phaser.Math.RadToDeg(angleRad);
    
    const idealAngles = [ -90, -30, 30, 90, 150, -150 ];
    let closestIndex = 0; let minDiff = 360;
    idealAngles.forEach((ideal, index) => {
        let diff = Math.abs(Phaser.Math.Angle.WrapDegrees(angleDeg - ideal));
        if (diff < minDiff) { minDiff = diff; closestIndex = index; }
    });
    unit.facing = closestIndex;
    uiUpdate();
    addToLog(`Facing set to ${["N","NE","SE","S","SW","NW"][closestIndex]}`);
    currentAction = null;
    if(currentPhase === 'SETUP') redrawAllUnits(); 
}

function executeMove(unit, targetHex) {
    const dist = getHexDistance({q: unit.q, r: unit.r}, targetHex);
    if (dist !== 1) { addToLog("Too far! Must be adjacent.", "log-combat"); return; }
    const terrainCost = TERRAIN_TYPES[targetHex.terrain].cost;
    
    if (currentAction === 'TACTICAL') {
        if (terrainCost >= 999) { addToLog("Impassable.", "log-combat"); return; }
        unit.mp = 0; moveUnitTo(unit, targetHex);
    } else if (currentAction === 'FAST') {
        if (unit.mp < terrainCost) { addToLog("Not enough MP.", "log-combat"); return; }
        unit.mp -= terrainCost; moveUnitTo(unit, targetHex);
    }
    currentAction = null;
}

function moveUnitTo(unit, hex) {
    unit.q = hex.q; unit.r = hex.r;
    selectUnitInStack(unit); 
    addToLog(`${unit.name || unit.category} moved.`);
}

function executeFire(attacker, targetUnit) {
    if (!targetUnit || attacker.side === targetUnit.side) return;
    const startHex = hexMap[attacker.q][attacker.r];
    const targetHex = hexMap[targetUnit.q][targetUnit.r];
    
    // Determine attacker height based on category
    let cat = attacker.category || 'squad';
    let attHeight = (cat==='vehicle' || cat==='hwt') ? 'vehicle' : 'infantry';
    
    const physicalRange = getPhysicalRange(startHex, targetHex);
    if (physicalRange > attacker.range) { addToLog("Out of range!", "log-combat"); currentAction = null; return; }
    
    const los = calculateLOS(startHex, targetHex, attHeight);
    if (los.status === 'blocked') { 
        addToLog("LOS Blocked.", "log-combat"); 
        drawVisualLOSLine(startHex, targetHex, 0xff0000);
        setTimeout(() => losGraphics.clear(), 1000);
        currentAction = null; return;
    }
    
    let damage = attacker.fp; let color = 0x00ff00;
    if (los.status === 'degraded') { damage -= 1; addToLog("Degraded LOS (-1)", "log-info"); color = 0xffaa00; }
    const sector = getTargetSector(attacker, targetUnit);
    if (sector === 'REAR') { damage += 2; addToLog("Rear Shot (+2)", "log-combat"); color = 0xff0000; }
    
    damage = Math.max(0, damage);
    targetUnit.hp -= damage;
    drawVisualLOSLine(startHex, targetHex, color);
    
    let attName = attacker.name || attacker.category;
    addToLog(`${attName} hits for ${damage} dmg.`, "log-combat");
    
    if (targetUnit.hp <= 0) {
        addToLog("Target Destroyed!", "log-combat");
        units = units.filter(u => u.id !== targetUnit.id);
        selectedUnit = null; uiUpdate();
    } else {
        uiUpdate();
    }
    setTimeout(() => losGraphics.clear(), 1000);
    currentAction = null;
}

function getTargetSector(attacker, target) {
    const targetPos = getHexPosition(target.q, target.r);
    const attackerPos = getHexPosition(attacker.q, attacker.r);
    const angleRad = Phaser.Math.Angle.Between(targetPos.x, targetPos.y, attackerPos.x, attackerPos.y);
    const angleDeg = Phaser.Math.RadToDeg(angleRad);
    const idealAngles = [ -90, -30, 30, 90, 150, -150 ];
    let attackDirIndex = 0; let minDiff = 360;
    idealAngles.forEach((ideal, index) => {
        let diff = Math.abs(Phaser.Math.Angle.WrapDegrees(angleDeg - ideal));
        if (diff < minDiff) { minDiff = diff; attackDirIndex = index; }
    });
    let diff = Math.abs(target.facing - attackDirIndex);
    if (diff > 3) diff = 6 - diff;
    return diff <= 1 ? 'FRONT' : 'REAR';
}

function addToLog(msg, cssClass = "") {
    const container = document.getElementById('log-container');
    const entry = document.createElement('div');
    entry.className = `log-entry ${cssClass}`;
    entry.innerText = msg;
    container.appendChild(entry);
    container.scrollTop = container.scrollHeight;
}
function toggleMapLoader() {
    const el = document.getElementById('json-modal');
    el.style.display = (el.style.display === 'block') ? 'none' : 'block';
}

function nextPhase() {
    if (currentPhase === 'SETUP') {
        if (trayUnits.length > 0) {
            if(!confirm("Undeployed units remain in Tray. Start anyway?")) return;
        }
        currentPhase = 'Action Phase';
        document.getElementById('btn-phase').innerText = "Next Phase >>";
        document.getElementById('left-content-area').innerHTML = '';
        displayMap();
        addToLog("=== SETUP COMPLETE ===", "log-turn");
        addToLog("Turn 1 Started.", "log-turn");
    } else {
        addToLog(`Ending ${currentPhase}...`, "log-turn");
        currentPhase = (currentPhase === 'Action Phase') ? 'Fire Phase' : 'Action Phase';
        if(currentPhase === 'Action Phase') {
            currentTurn++; document.getElementById('turn-counter').innerText = currentTurn;
            addToLog(`Turn ${currentTurn} Started.`, "log-turn");
        }
    }
    document.getElementById('phase-display').innerText = currentPhase;
    uiUpdate();
}

function highlightHex(hex, color) {
    selectionGraphics.lineStyle(4, color);
    selectionGraphics.strokeCircle(hex.x, hex.y, HEX_RADIUS - 5);
}
function drawVisualLOSLine(start, end, color) {
    losGraphics.clear(); losGraphics.lineStyle(4, color, 0.8);
    losGraphics.beginPath(); losGraphics.moveTo(start.x, start.y); losGraphics.lineTo(end.x, end.y); losGraphics.strokePath();
}

function loadScenario() {
    let txt = document.getElementById('json-input').value;
    txt = txt.replace(/[\n\r\t]+/g, ' ').replace(/\u00A0/g, ' ').trim();

    try {
        scenarioData = JSON.parse(txt);
        mapData = scenarioData.map; 

        units = []; trayUnits = [];
        
        if (scenarioData.units.locked) {
            scenarioData.units.locked.forEach(u => {
                u.isFixed = true; 
                
                // BACKWARD COMPATIBILITY & NEW NAMING
                if(u.type && !u.category) {
                     // Try to guess based on filename from registry
                     const info = UNIT_DATA_REGISTRY[u.type];
                     if(info) {
                         u.category = info.category;
                         u.name = info.name;
                     } else {
                         u.category = u.type; 
                     }
                }
                
                // Map type to unitType for internal engine consistency
                u.unitType = u.type;
                
                if(!u.stance) u.stance = 'deployed';
                
                // IMPORTANT LOGIC: Split "cover" based on category
                if(u.stance === 'cover' && u.category === 'hwt') u.stance = 'setup';
                
                units.push(u);
            });
        }
        
        if (scenarioData.units.tray) {
            trayUnits = [...scenarioData.units.tray];
            trayUnits.forEach(u => { 
                if(!u.category) u.category = u.type; 
                // Ensure name and specific type exist
                const info = UNIT_DATA_REGISTRY[u.type];
                if(info && !u.name) u.name = info.name;
            });
        }
        
        document.getElementById('scenario-info-box').innerHTML = `
            <strong style="color:white">${scenarioData.info.title}</strong><br>
            <span style="color:#aaa">${scenarioData.info.author}</span><br>
            <p style="margin:5px 0 0 0; font-size:11px; color:#888">${scenarioData.info.description}</p>
        `;
        document.getElementById('max-turns').innerText = scenarioData.info.maxTurns;

        currentPhase = 'SETUP';
        document.getElementById('phase-display').innerText = 'SETUP';
        document.getElementById('btn-phase').innerText = 'Finish Setup';
        
        displayMap(); 
        renderTray(); 
        toggleMapLoader();
        addToLog("Scenario Loaded. Begin Deployment.");
        
    } catch (e) { alert('Invalid JSON: ' + e.message); console.error(e); }
}

function displayMap() {
    if (!mapData) return;
    
    hexGroup.clear(true, true); 
    roadGraphics.clear(); 
    zoneGraphics.clear();
    objGraphics.clear();
    objectiveSprites.forEach(s => s.destroy());
    objectiveSprites = [];
    
    hexMap = {};
    const cols = mapData.cols || 0;
    const rows = mapData.rows || 0;

    for (let q = 0; q < cols; q++) {
        hexMap[q] = {};
        for (let r = 0; r < rows; r++) {
            const pos = getHexPosition(q, r);
            hexMap[q][r] = { terrain: 'clear', x: pos.x, y: pos.y, q: q, r: r, hasRoad: false, variant: null };
        }
    }
    
    if (mapData.terrain) mapData.terrain.forEach(t => { if (hexMap[t.q] && hexMap[t.q][t.r]) hexMap[t.q][t.r].terrain = t.type; });
    if (mapData.roads) mapData.roads.forEach(road => {
        if (hexMap[road.from.q]) hexMap[road.from.q][road.from.r].hasRoad = true;
        if (hexMap[road.to.q]) hexMap[road.to.q][road.to.r].hasRoad = true;
    });

    if (currentPhase === 'SETUP' && mapData.zones) {
        mapData.zones.forEach(z => {
            if (hexMap[z.q] && hexMap[z.q][z.r]) {
                hexMap[z.q][z.r].setupZone = z.side;
                const p = getHexPosition(z.q, z.r);
                const pts = []; 
                for(let i=0; i<6; i++) {
                    const a = Math.PI/3*i; 
                    pts.push({x: p.x+HEX_RADIUS*Math.cos(a), y: p.y+HEX_RADIUS*Math.sin(a)}); 
                }
                const color = z.side === 'blue' ? 0x4488ff : 0xff4444;
                zoneGraphics.fillStyle(color, 0.2).fillPoints(pts, true);
            }
        });
    }

    const oldObjectives = mapData.objectives || mapData.victoryHexes || [];
    const newObjectives = (scenarioData && scenarioData.victory && scenarioData.victory.locations) ? scenarioData.victory.locations : [];
    const allObjectives = [...oldObjectives, ...newObjectives];

    if (allObjectives.length > 0) {
        allObjectives.forEach(obj => {
            if (hexMap[obj.q] && hexMap[obj.q][obj.r]) {
                const hex = hexMap[obj.q][obj.r];
                hex.victoryPoints = obj.points || 100;
                const star = scene.add.star(hex.x, hex.y, 5, 8, 16, 0xffcc00);
                star.setStrokeStyle(2, 0x000000);
                star.setDepth(150);
                objectiveSprites.push(star);
                const txt = scene.add.text(hex.x, hex.y + 10, hex.victoryPoints.toString(), {
                    fontSize: '10px', stroke: '#000', strokeThickness: 3, fill: '#fff', fontStyle: 'bold'
                }).setOrigin(0.5).setDepth(151);
                objectiveSprites.push(txt);
            }
        });
    }

    for (let q = 0; q < cols; q++) { for (let r = 0; r < rows; r++) { drawHex(hexMap[q][r]); } }
    drawRoads(); redrawAllUnits();
}

function drawHex(hex) {
    const terrainType = hex.terrain; const x = hex.x; const y = hex.y;
    if (!hex.variant) hex.variant = Phaser.Math.Between(1, 3);
    const textureKey = `${terrainType}${hex.variant}`;
    
    // EDITOR STYLE LINES: 1px width, 0.5 opacity
    if (scene.textures.exists(textureKey)) {
        const img = scene.add.image(x, y, textureKey).setDisplaySize(HEX_RADIUS * 2, HEX_RADIUS * 2);
        const shape = scene.make.graphics().fillStyle(0xffffff).beginPath();
        for (let i = 0; i < 6; i++) { const angle = (Math.PI / 3) * i; const hx = x + HEX_RADIUS * Math.cos(angle); const hy = y + HEX_RADIUS * Math.sin(angle); if (i === 0) shape.moveTo(hx, hy); else shape.lineTo(hx, hy); }
        shape.closePath().fillPath();
        img.setMask(shape.createGeometryMask()); hexGroup.add(img);
        
        const outline = scene.add.graphics().lineStyle(1, 0x333333, 0.5).beginPath();
        for (let i = 0; i < 6; i++) { const angle = (Math.PI / 3) * i; const hx = x + HEX_RADIUS * Math.cos(angle); const hy = y + HEX_RADIUS * Math.sin(angle); if (i === 0) outline.moveTo(hx, hy); else outline.lineTo(hx, hy); }
        outline.closePath().strokePath(); hexGroup.add(outline);
    } else {
        const g = scene.add.graphics().fillStyle(TERRAIN_TYPES[terrainType].color).lineStyle(1, 0x333333, 0.5).beginPath();
        for (let i = 0; i < 6; i++) { const angle = (Math.PI / 3) * i; const hx = x + HEX_RADIUS * Math.cos(angle); const hy = y + HEX_RADIUS * Math.sin(angle); if (i === 0) g.moveTo(hx, hy); else g.lineTo(hx, hy); }
        g.closePath().fillPath().strokePath(); hexGroup.add(g);
    }
}
function drawRoads() {
    if (!mapData || !mapData.roads) return;
    roadGraphics.lineStyle(6, 0x555555, 0.8);
    mapData.roads.forEach(seg => {
        const h1 = hexMap[seg.from.q][seg.from.r]; const h2 = hexMap[seg.to.q][seg.to.r];
        if (h1 && h2) roadGraphics.beginPath().moveTo(h1.x, h1.y).lineTo(h2.x, h2.y).strokePath();
    });
}

// --- Hex Geometry & LOS ---
function getHexPosition(q, r) {
    const x = q * HEX_RADIUS * 1.5; const y = r * HEX_RADIUS * Math.sqrt(3) + (q % 2 === 1 ? HEX_RADIUS * Math.sqrt(3) / 2 : 0);
    return { x, y };
}
function offsetToCube(q, r) {
    const col = q; const row = r; const x = col; const z = row - (col - (col & 1)) / 2; const y = -x - z;
    return { x, y, z };
}
function getHexDistance(h1, h2) {
    const a = offsetToCube(h1.q, h1.r); const b = offsetToCube(h2.q, h2.r);
    return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y), Math.abs(a.z - b.z));
}
function getHexAtPoint(worldX, worldY) {
    if (!mapData) return null;
    let closestHex = null; let closestDist = Infinity;
    for (let q = 0; q < mapData.cols; q++) {
        for (let r = 0; r < mapData.rows; r++) {
            const hex = hexMap[q][r];
            const dist = Math.sqrt((hex.x - worldX) ** 2 + (hex.y - worldY) ** 2);
            if (dist < HEX_RADIUS && dist < closestDist) { closestDist = dist; closestHex = hex; }
        }
    }
    return closestHex;
}
function getPhysicalRange(startHex, targetHex) {
    const hexes = []; const dx = targetHex.x - startHex.x; const dy = targetHex.y - startHex.y;
    const dist = Math.sqrt(dx * dx + dy * dy); const steps = Math.ceil(dist / 2);
    for (let i = 0; i <= steps; i++) {
        const t = i / steps; const currX = startHex.x + dx * t; const currY = startHex.y + dy * t;
        const h = getHexAtPoint(currX, currY);
        if (h) { const key = `${h.q},${h.r}`; if (!hexes.includes(key) && !(h.q === startHex.q && h.r === startHex.r)) hexes.push(key); }
    }
    return hexes.length;
}
function calculateLOS(startHex, targetHex, unitType = 'infantry') {
    const fromTerrain = TERRAIN_TYPES[startHex.terrain];
    const fromUsableHeight = unitType === 'vehicle' ? fromTerrain.vehicleUsable : fromTerrain.infantryUsable;
    const dx = targetHex.x - startHex.x; const dy = targetHex.y - startHex.y; const distance = Math.sqrt(dx * dx + dy * dy); const steps = Math.ceil(distance / 2); 
    const hexesCrossed = new Set(); const edgeSegments = []; let edgeRunLength = 0; let edgeHexPair = null;
    for (let i = 0; i <= steps; i++) {
        const t = i / steps; const x = startHex.x + dx * t; const y = startHex.y + dy * t;
        const currentHex = getHexAtPoint(x, y);
        if (!currentHex) continue;
        if ((currentHex.q === startHex.q && currentHex.r === startHex.r) || (currentHex.q === targetHex.q && currentHex.r === targetHex.r)) continue;
        const perpDx = -dy / distance; const perpDy = dx / distance;
        const hex1 = getHexAtPoint(x + perpDx * 3, y + perpDy * 3); const hex2 = getHexAtPoint(x - perpDx * 3, y - perpDy * 3);
        if (hex1 && hex2 && (hex1.q !== hex2.q || hex1.r !== hex2.r)) {
            const pairKey = [`${hex1.q},${hex1.r}`, `${hex2.q},${hex2.r}`].sort().join('|');
            if (edgeHexPair === pairKey) edgeRunLength++;
            else { if (edgeRunLength > 5) edgeSegments.push(edgeHexPair); edgeHexPair = pairKey; edgeRunLength = 1; }
        } else {
            if (edgeRunLength > 5) edgeSegments.push(edgeHexPair);
            edgeRunLength = 0; edgeHexPair = null; hexesCrossed.add(`${currentHex.q},${currentHex.r}`);
        }
    }
    if (edgeRunLength > 5) edgeSegments.push(edgeHexPair);
    let degradingCount = 0; let hasBlocking = false;
    for (let key of hexesCrossed) {
        const [q, r] = key.split(',').map(Number); const terrain = TERRAIN_TYPES[hexMap[q][r].terrain];
        let losEffect = terrain.los;
        if (terrain.terrainHeight < fromUsableHeight) { if (losEffect === 'blocking') losEffect = 'degrading'; else if (losEffect === 'degrading') losEffect = 'clear'; }
        if (losEffect === 'blocking') hasBlocking = true; else if (losEffect === 'degrading') degradingCount++;
    }
    for (let edgePair of edgeSegments) {
        if (!edgePair) continue; const [k1, k2] = edgePair.split('|'); const [q1, r1] = k1.split(',').map(Number); const [q2, r2] = k2.split(',').map(Number);
        const t1 = TERRAIN_TYPES[hexMap[q1][r1].terrain]; const t2 = TERRAIN_TYPES[hexMap[q2][r2].terrain];
        let l1 = t1.los; let l2 = t2.los;
        if (t1.terrainHeight < fromUsableHeight) l1 = (l1==='blocking'?'degrading':(l1==='degrading'?'clear':l1));
        if (t2.terrainHeight < fromUsableHeight) l2 = (l2==='blocking'?'degrading':(l2==='degrading'?'clear':l2));
        if (l1 === 'blocking' && l2 === 'blocking') hasBlocking = true; else if (l1 === 'blocking' || l2 === 'blocking') degradingCount++; else if (l1 === 'degrading' && l2 === 'degrading') degradingCount++;
    }
    let standardStatus = 'clear';
    if (hasBlocking || degradingCount >= 2) standardStatus = 'blocked'; else if (degradingCount === 1) standardStatus = 'degraded';
    const hexesOnLine = getHexesAlongLine(startHex, targetHex); const roadLOSResult = checkRoadLOS(startHex, targetHex, hexesOnLine);
    if (roadLOSResult.isRoad) {
        const dist = getHexDistance(startHex, targetHex); let roadStatus = 'blocked';
        if (dist <= 5) roadStatus = 'clear'; else if (dist <= 10) roadStatus = 'degraded';
        const rank = { 'clear': 3, 'degraded': 2, 'blocked': 1 };
        if (rank[roadStatus] > rank[standardStatus]) return { status: roadStatus, isRoad: true };
    }
    return { status: standardStatus, isRoad: false };
}
function getHexesAlongLine(startHex, targetHex) {
    const hexes = []; const dx = targetHex.x - startHex.x; const dy = targetHex.y - startHex.y; const dist = Math.sqrt(dx*dx + dy*dy); const steps = Math.ceil(dist / 10);
    for(let i=0; i<=steps; i++) { const t = i/steps; const h = getHexAtPoint(startHex.x + dx*t, startHex.y + dy*t); if(h && !hexes.includes(h)) hexes.push(h); }
    return hexes;
}
function checkRoadLOS(startHex, targetHex, hexesOnLine) {
    if (!mapData || !mapData.roads) return { isRoad: false };
    if (!startHex.hasRoad || !targetHex.hasRoad) return { isRoad: false };
    const roadPath = findRoadPath(startHex, targetHex); if (!roadPath || roadPath.length < 2) return { isRoad: false };
    const idealDx = targetHex.x - startHex.x; const idealDy = targetHex.y - startHex.y; const idealLen = Math.sqrt(idealDx*idealDx + idealDy*idealDy);
    for (let i = 0; i < roadPath.length - 1; i++) {
        const c = roadPath[i]; const n = roadPath[i+1]; const sdx = n.x - c.x; const sdy = n.y - c.y; const slen = Math.sqrt(sdx*sdx + sdy*sdy);
        const dot = (idealDx/idealLen) * (sdx/slen) + (idealDy/idealLen) * (sdy/slen); if (dot < 0.96) return { isRoad: false }; 
    }
    for (let h of hexesOnLine) { if (!roadPath.find(rh => rh.q === h.q && rh.r === h.r)) return { isRoad: false }; }
    return { isRoad: true };
}
function findRoadPath(start, target) {
    const visited = new Set(); const queue = [[start]];
    while(queue.length > 0) {
        const path = queue.shift(); const curr = path[path.length-1];
        if(curr.q === target.q && curr.r === target.r) return path;
        const key = `${curr.q},${curr.r}`; if(visited.has(key)) continue; visited.add(key);
        mapData.roads.forEach(r => {
            let next = null;
            if(r.from.q === curr.q && r.from.r === curr.r) next = hexMap[r.to.q][r.to.r];
            else if(r.to.q === curr.q && r.to.r === curr.r) next = hexMap[r.from.q][r.from.r];
            if(next) queue.push([...path, next]);
        });
    }
    return null;
}
</script>
</body>
</html>
